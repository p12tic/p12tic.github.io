<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>libsimdpp: Operations: bitwise</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="main">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Operations: bitwise</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad065347d125f9e587850c0b4e2ffbe5d"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad065347d125f9e587850c0b4e2ffbe5d">simdpp::bit_and</a> (basic_int8x16 a, int128 b)</td></tr>
<tr class="memdesc:gad065347d125f9e587850c0b4e2ffbe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of integer vectors.  <a href="#gad065347d125f9e587850c0b4e2ffbe5d">More...</a><br/></td></tr>
<tr class="separator:gad065347d125f9e587850c0b4e2ffbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab9f7181fb699f03ee9bfcb0631cc23"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga7ab9f7181fb699f03ee9bfcb0631cc23">simdpp::bit_and</a> (basic_int16x8 a, int128 b)</td></tr>
<tr class="separator:ga7ab9f7181fb699f03ee9bfcb0631cc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa578278499dec0b2a195ef5976075626"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa578278499dec0b2a195ef5976075626">simdpp::bit_and</a> (basic_int32x4 a, int128 b)</td></tr>
<tr class="separator:gaa578278499dec0b2a195ef5976075626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21756d4c5ab1c0df8fe6070ecbb89a8"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf21756d4c5ab1c0df8fe6070ecbb89a8">simdpp::bit_and</a> (basic_int64x2 a, int128 b)</td></tr>
<tr class="separator:gaf21756d4c5ab1c0df8fe6070ecbb89a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db3bd5099262dd9c9122eef8d6f4bcc"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1db3bd5099262dd9c9122eef8d6f4bcc">simdpp::bit_and</a> (basic_int8x32 a, int256 b)</td></tr>
<tr class="separator:ga1db3bd5099262dd9c9122eef8d6f4bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac32297206e551cb0235ec44cd70720"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga4ac32297206e551cb0235ec44cd70720">simdpp::bit_and</a> (basic_int16x16 a, int256 b)</td></tr>
<tr class="separator:ga4ac32297206e551cb0235ec44cd70720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999480b1f72bae63fdf07b5da553ce5c"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga999480b1f72bae63fdf07b5da553ce5c">simdpp::bit_and</a> (basic_int32x8 a, int256 b)</td></tr>
<tr class="separator:ga999480b1f72bae63fdf07b5da553ce5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4d10e0f5fafcc3896aaf1d2907a1a5"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaab4d10e0f5fafcc3896aaf1d2907a1a5">simdpp::bit_and</a> (basic_int64x4 a, int256 b)</td></tr>
<tr class="separator:gaab4d10e0f5fafcc3896aaf1d2907a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c6f3080d03e43610f4ad231e710433"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab6c6f3080d03e43610f4ad231e710433">simdpp::bit_and</a> (basic_int8x16 a, mask_int8x16 b)</td></tr>
<tr class="separator:gab6c6f3080d03e43610f4ad231e710433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b8b0a9cd251fe197922243cbb979b1"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad2b8b0a9cd251fe197922243cbb979b1">simdpp::bit_and</a> (basic_int16x8 a, mask_int16x8 b)</td></tr>
<tr class="separator:gad2b8b0a9cd251fe197922243cbb979b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ee0c20b05029aea2acc32074b4361b"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad6ee0c20b05029aea2acc32074b4361b">simdpp::bit_and</a> (basic_int32x4 a, mask_int32x4 b)</td></tr>
<tr class="separator:gad6ee0c20b05029aea2acc32074b4361b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63ab0d887a6a7970bf8bdcdd42b945c"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gae63ab0d887a6a7970bf8bdcdd42b945c">simdpp::bit_and</a> (basic_int64x2 a, mask_int64x2 b)</td></tr>
<tr class="separator:gae63ab0d887a6a7970bf8bdcdd42b945c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b3e1721479be3d4dd07344e4850b4d3"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0b3e1721479be3d4dd07344e4850b4d3">simdpp::bit_and</a> (basic_int8x32 a, mask_int8x32 b)</td></tr>
<tr class="separator:ga0b3e1721479be3d4dd07344e4850b4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2f909a6440d3f2750a23a6055190f0"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga4b2f909a6440d3f2750a23a6055190f0">simdpp::bit_and</a> (basic_int16x16 a, mask_int16x16 b)</td></tr>
<tr class="separator:ga4b2f909a6440d3f2750a23a6055190f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a415dcd55e5e3dddd2c0bd3838d62b1"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0a415dcd55e5e3dddd2c0bd3838d62b1">simdpp::bit_and</a> (basic_int32x8 a, mask_int32x8 b)</td></tr>
<tr class="separator:ga0a415dcd55e5e3dddd2c0bd3838d62b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8aab353d18116cb2eddf6694a54b22"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gabe8aab353d18116cb2eddf6694a54b22">simdpp::bit_and</a> (basic_int64x4 a, mask_int64x4 b)</td></tr>
<tr class="separator:gabe8aab353d18116cb2eddf6694a54b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d19ef8c6e2e0b1ff0efa937cec17f8"><td class="memItemLeft" align="right" valign="top">mask_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga08d19ef8c6e2e0b1ff0efa937cec17f8">simdpp::bit_and</a> (mask_int8x16 a, mask_int8x16 b)</td></tr>
<tr class="separator:ga08d19ef8c6e2e0b1ff0efa937cec17f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f201f5bc7b25163b856f25fbaefeb4"><td class="memItemLeft" align="right" valign="top">mask_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga25f201f5bc7b25163b856f25fbaefeb4">simdpp::bit_and</a> (mask_int16x8 a, mask_int16x8 b)</td></tr>
<tr class="separator:ga25f201f5bc7b25163b856f25fbaefeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14b9dedb0bd7809440506123fb1657f"><td class="memItemLeft" align="right" valign="top">mask_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac14b9dedb0bd7809440506123fb1657f">simdpp::bit_and</a> (mask_int32x4 a, mask_int32x4 b)</td></tr>
<tr class="separator:gac14b9dedb0bd7809440506123fb1657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e67e5d94dc6868a6903be1d192a5f32"><td class="memItemLeft" align="right" valign="top">mask_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga2e67e5d94dc6868a6903be1d192a5f32">simdpp::bit_and</a> (mask_int64x2 a, mask_int64x2 b)</td></tr>
<tr class="separator:ga2e67e5d94dc6868a6903be1d192a5f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c113798ab21428e8517182c058c519"><td class="memItemLeft" align="right" valign="top">mask_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa2c113798ab21428e8517182c058c519">simdpp::bit_and</a> (mask_int8x32 a, mask_int8x32 b)</td></tr>
<tr class="separator:gaa2c113798ab21428e8517182c058c519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf3bd43045e3d326276ea2e2276fb97"><td class="memItemLeft" align="right" valign="top">mask_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gadaf3bd43045e3d326276ea2e2276fb97">simdpp::bit_and</a> (mask_int16x16 a, mask_int16x16 b)</td></tr>
<tr class="separator:gadaf3bd43045e3d326276ea2e2276fb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b0f35fe4719698786ca7e27a8b85f1"><td class="memItemLeft" align="right" valign="top">mask_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf3b0f35fe4719698786ca7e27a8b85f1">simdpp::bit_and</a> (mask_int32x8 a, mask_int32x8 b)</td></tr>
<tr class="separator:gaf3b0f35fe4719698786ca7e27a8b85f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97f86fcd1eb890fac794c1b3fc857b2"><td class="memItemLeft" align="right" valign="top">mask_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa97f86fcd1eb890fac794c1b3fc857b2">simdpp::bit_and</a> (mask_int64x4 a, mask_int64x4 b)</td></tr>
<tr class="separator:gaa97f86fcd1eb890fac794c1b3fc857b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c80ed0acc7824f1c76b42750a571343"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga2c80ed0acc7824f1c76b42750a571343">simdpp::bit_and</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:ga2c80ed0acc7824f1c76b42750a571343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga2c80ed0acc7824f1c76b42750a571343">More...</a><br/></td></tr>
<tr class="separator:ga2c80ed0acc7824f1c76b42750a571343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea919967acc78208ce9bf31433bf4f4"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaaea919967acc78208ce9bf31433bf4f4">simdpp::bit_and</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:gaaea919967acc78208ce9bf31433bf4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gaaea919967acc78208ce9bf31433bf4f4">More...</a><br/></td></tr>
<tr class="separator:gaaea919967acc78208ce9bf31433bf4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa44241edb6e43d94074805a5488aebf2"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa44241edb6e43d94074805a5488aebf2">simdpp::bit_and</a> (float32x4 a, int128 b)</td></tr>
<tr class="memdesc:gaa44241edb6e43d94074805a5488aebf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gaa44241edb6e43d94074805a5488aebf2">More...</a><br/></td></tr>
<tr class="separator:gaa44241edb6e43d94074805a5488aebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c59608632e597d7dbe9721c8fdce14e"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga3c59608632e597d7dbe9721c8fdce14e">simdpp::bit_and</a> (float32x8 a, int256 b)</td></tr>
<tr class="memdesc:ga3c59608632e597d7dbe9721c8fdce14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga3c59608632e597d7dbe9721c8fdce14e">More...</a><br/></td></tr>
<tr class="separator:ga3c59608632e597d7dbe9721c8fdce14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec03d8007e973a5a3b9b5244be2a5e3d"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaec03d8007e973a5a3b9b5244be2a5e3d">simdpp::bit_and</a> (float32x4 a, mask_float32x4 b)</td></tr>
<tr class="memdesc:gaec03d8007e973a5a3b9b5244be2a5e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gaec03d8007e973a5a3b9b5244be2a5e3d">More...</a><br/></td></tr>
<tr class="separator:gaec03d8007e973a5a3b9b5244be2a5e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5240532c077d733d9d9a1991f04f72aa"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5240532c077d733d9d9a1991f04f72aa">simdpp::bit_and</a> (float32x8 a, mask_float32x8 b)</td></tr>
<tr class="memdesc:ga5240532c077d733d9d9a1991f04f72aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga5240532c077d733d9d9a1991f04f72aa">More...</a><br/></td></tr>
<tr class="separator:ga5240532c077d733d9d9a1991f04f72aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b02df63cc18b6aec7ebe271c3f9ea19"><td class="memItemLeft" align="right" valign="top">mask_float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga6b02df63cc18b6aec7ebe271c3f9ea19">simdpp::bit_and</a> (mask_float32x4 a, mask_float32x4 b)</td></tr>
<tr class="memdesc:ga6b02df63cc18b6aec7ebe271c3f9ea19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga6b02df63cc18b6aec7ebe271c3f9ea19">More...</a><br/></td></tr>
<tr class="separator:ga6b02df63cc18b6aec7ebe271c3f9ea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7dec285b91098e64559a05ea53b7ab6"><td class="memItemLeft" align="right" valign="top">mask_float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab7dec285b91098e64559a05ea53b7ab6">simdpp::bit_and</a> (mask_float32x8 a, mask_float32x8 b)</td></tr>
<tr class="memdesc:gab7dec285b91098e64559a05ea53b7ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gab7dec285b91098e64559a05ea53b7ab6">More...</a><br/></td></tr>
<tr class="separator:gab7dec285b91098e64559a05ea53b7ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7502addcadb5aa83597d8f788ea1a77"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab7502addcadb5aa83597d8f788ea1a77">simdpp::bit_and</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:gab7502addcadb5aa83597d8f788ea1a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gab7502addcadb5aa83597d8f788ea1a77">More...</a><br/></td></tr>
<tr class="separator:gab7502addcadb5aa83597d8f788ea1a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70f49acc4cddb15ec941dcc6d7c05fd"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf70f49acc4cddb15ec941dcc6d7c05fd">simdpp::bit_and</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:gaf70f49acc4cddb15ec941dcc6d7c05fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gaf70f49acc4cddb15ec941dcc6d7c05fd">More...</a><br/></td></tr>
<tr class="separator:gaf70f49acc4cddb15ec941dcc6d7c05fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d5a105d788d9a2ba7120cdd014fcd8"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga30d5a105d788d9a2ba7120cdd014fcd8">simdpp::bit_and</a> (float64x2 a, int128 b)</td></tr>
<tr class="memdesc:ga30d5a105d788d9a2ba7120cdd014fcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga30d5a105d788d9a2ba7120cdd014fcd8">More...</a><br/></td></tr>
<tr class="separator:ga30d5a105d788d9a2ba7120cdd014fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3f1e5ff54eb931bacce8daba98b528"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga2f3f1e5ff54eb931bacce8daba98b528">simdpp::bit_and</a> (float64x4 a, int256 b)</td></tr>
<tr class="memdesc:ga2f3f1e5ff54eb931bacce8daba98b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga2f3f1e5ff54eb931bacce8daba98b528">More...</a><br/></td></tr>
<tr class="separator:ga2f3f1e5ff54eb931bacce8daba98b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae82cdc4193410b872124e791cc7b85bd"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gae82cdc4193410b872124e791cc7b85bd">simdpp::bit_and</a> (float64x2 a, mask_float64x2 b)</td></tr>
<tr class="memdesc:gae82cdc4193410b872124e791cc7b85bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gae82cdc4193410b872124e791cc7b85bd">More...</a><br/></td></tr>
<tr class="separator:gae82cdc4193410b872124e791cc7b85bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e07b0de62efda0795fee0cefef4a18"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga13e07b0de62efda0795fee0cefef4a18">simdpp::bit_and</a> (float64x4 a, mask_float64x4 b)</td></tr>
<tr class="memdesc:ga13e07b0de62efda0795fee0cefef4a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga13e07b0de62efda0795fee0cefef4a18">More...</a><br/></td></tr>
<tr class="separator:ga13e07b0de62efda0795fee0cefef4a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf683c09e35deccd2226aa2cc929304da"><td class="memItemLeft" align="right" valign="top">mask_float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf683c09e35deccd2226aa2cc929304da">simdpp::bit_and</a> (mask_float64x2 a, mask_float64x2 b)</td></tr>
<tr class="memdesc:gaf683c09e35deccd2226aa2cc929304da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#gaf683c09e35deccd2226aa2cc929304da">More...</a><br/></td></tr>
<tr class="separator:gaf683c09e35deccd2226aa2cc929304da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287b7e879879ab33baec49f6b9f9f33b"><td class="memItemLeft" align="right" valign="top">mask_float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga287b7e879879ab33baec49f6b9f9f33b">simdpp::bit_and</a> (mask_float64x4 a, mask_float64x4 b)</td></tr>
<tr class="memdesc:ga287b7e879879ab33baec49f6b9f9f33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of floating-point vectors.  <a href="#ga287b7e879879ab33baec49f6b9f9f33b">More...</a><br/></td></tr>
<tr class="separator:ga287b7e879879ab33baec49f6b9f9f33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf37019b14a33b2da3f46dabf0c2b8a"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga7bf37019b14a33b2da3f46dabf0c2b8a">simdpp::bit_andnot</a> (basic_int8x16 a, int128 b)</td></tr>
<tr class="memdesc:ga7bf37019b14a33b2da3f46dabf0c2b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga7bf37019b14a33b2da3f46dabf0c2b8a">More...</a><br/></td></tr>
<tr class="separator:ga7bf37019b14a33b2da3f46dabf0c2b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9736affcc74ed8ea90e8f1df371ec6f"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab9736affcc74ed8ea90e8f1df371ec6f">simdpp::bit_andnot</a> (basic_int16x8 a, int128 b)</td></tr>
<tr class="memdesc:gab9736affcc74ed8ea90e8f1df371ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#gab9736affcc74ed8ea90e8f1df371ec6f">More...</a><br/></td></tr>
<tr class="separator:gab9736affcc74ed8ea90e8f1df371ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ec4ec1c5fd41c8eca05859a05e41eb"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga98ec4ec1c5fd41c8eca05859a05e41eb">simdpp::bit_andnot</a> (basic_int32x4 a, int128 b)</td></tr>
<tr class="memdesc:ga98ec4ec1c5fd41c8eca05859a05e41eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga98ec4ec1c5fd41c8eca05859a05e41eb">More...</a><br/></td></tr>
<tr class="separator:ga98ec4ec1c5fd41c8eca05859a05e41eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce4b1d90a20bd206fe97be9d53b9b82"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gadce4b1d90a20bd206fe97be9d53b9b82">simdpp::bit_andnot</a> (basic_int64x2 a, int128 b)</td></tr>
<tr class="memdesc:gadce4b1d90a20bd206fe97be9d53b9b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#gadce4b1d90a20bd206fe97be9d53b9b82">More...</a><br/></td></tr>
<tr class="separator:gadce4b1d90a20bd206fe97be9d53b9b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d561032c1a7dfb336ea9d9304b88ed"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga37d561032c1a7dfb336ea9d9304b88ed">simdpp::bit_andnot</a> (basic_int8x32 a, int256 b)</td></tr>
<tr class="memdesc:ga37d561032c1a7dfb336ea9d9304b88ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga37d561032c1a7dfb336ea9d9304b88ed">More...</a><br/></td></tr>
<tr class="separator:ga37d561032c1a7dfb336ea9d9304b88ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13427756c772d7456d3ca8309cb1d75c"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga13427756c772d7456d3ca8309cb1d75c">simdpp::bit_andnot</a> (basic_int16x16 a, int256 b)</td></tr>
<tr class="memdesc:ga13427756c772d7456d3ca8309cb1d75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga13427756c772d7456d3ca8309cb1d75c">More...</a><br/></td></tr>
<tr class="separator:ga13427756c772d7456d3ca8309cb1d75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05de150c123e36e26c1741294b1578bc"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga05de150c123e36e26c1741294b1578bc">simdpp::bit_andnot</a> (basic_int32x8 a, int256 b)</td></tr>
<tr class="memdesc:ga05de150c123e36e26c1741294b1578bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga05de150c123e36e26c1741294b1578bc">More...</a><br/></td></tr>
<tr class="separator:ga05de150c123e36e26c1741294b1578bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6275a99347cb206ddac483d1c0ed04d5"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga6275a99347cb206ddac483d1c0ed04d5">simdpp::bit_andnot</a> (basic_int64x4 a, int256 b)</td></tr>
<tr class="memdesc:ga6275a99347cb206ddac483d1c0ed04d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga6275a99347cb206ddac483d1c0ed04d5">More...</a><br/></td></tr>
<tr class="separator:ga6275a99347cb206ddac483d1c0ed04d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00819672baf72b861584c322e6ad1229"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga00819672baf72b861584c322e6ad1229">simdpp::bit_andnot</a> (basic_int8x16 a, mask_int8x16 b)</td></tr>
<tr class="memdesc:ga00819672baf72b861584c322e6ad1229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga00819672baf72b861584c322e6ad1229">More...</a><br/></td></tr>
<tr class="separator:ga00819672baf72b861584c322e6ad1229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc298ddb17c09f2177590d00717c3647"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gadc298ddb17c09f2177590d00717c3647">simdpp::bit_andnot</a> (basic_int16x8 a, mask_int16x8 b)</td></tr>
<tr class="memdesc:gadc298ddb17c09f2177590d00717c3647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#gadc298ddb17c09f2177590d00717c3647">More...</a><br/></td></tr>
<tr class="separator:gadc298ddb17c09f2177590d00717c3647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0378cdb816f4aa6647f6cc0a9bee6602"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0378cdb816f4aa6647f6cc0a9bee6602">simdpp::bit_andnot</a> (basic_int32x4 a, mask_int32x4 b)</td></tr>
<tr class="memdesc:ga0378cdb816f4aa6647f6cc0a9bee6602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga0378cdb816f4aa6647f6cc0a9bee6602">More...</a><br/></td></tr>
<tr class="separator:ga0378cdb816f4aa6647f6cc0a9bee6602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c0dfa89561901d84f94531f0ee6ffc"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa9c0dfa89561901d84f94531f0ee6ffc">simdpp::bit_andnot</a> (basic_int64x2 a, mask_int64x2 b)</td></tr>
<tr class="memdesc:gaa9c0dfa89561901d84f94531f0ee6ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#gaa9c0dfa89561901d84f94531f0ee6ffc">More...</a><br/></td></tr>
<tr class="separator:gaa9c0dfa89561901d84f94531f0ee6ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da2763dc5c6a7a229291adb037be516"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga6da2763dc5c6a7a229291adb037be516">simdpp::bit_andnot</a> (basic_int8x32 a, mask_int8x32 b)</td></tr>
<tr class="memdesc:ga6da2763dc5c6a7a229291adb037be516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga6da2763dc5c6a7a229291adb037be516">More...</a><br/></td></tr>
<tr class="separator:ga6da2763dc5c6a7a229291adb037be516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67bca35f0edcbf347424ddd401bdba06"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga67bca35f0edcbf347424ddd401bdba06">simdpp::bit_andnot</a> (basic_int16x16 a, mask_int16x16 b)</td></tr>
<tr class="memdesc:ga67bca35f0edcbf347424ddd401bdba06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga67bca35f0edcbf347424ddd401bdba06">More...</a><br/></td></tr>
<tr class="separator:ga67bca35f0edcbf347424ddd401bdba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd220df628f84e13269f323c2964db67"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gadd220df628f84e13269f323c2964db67">simdpp::bit_andnot</a> (basic_int32x8 a, mask_int32x8 b)</td></tr>
<tr class="memdesc:gadd220df628f84e13269f323c2964db67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#gadd220df628f84e13269f323c2964db67">More...</a><br/></td></tr>
<tr class="separator:gadd220df628f84e13269f323c2964db67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250db0598dcc1badc8a463083966f293"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga250db0598dcc1badc8a463083966f293">simdpp::bit_andnot</a> (basic_int64x4 a, mask_int64x4 b)</td></tr>
<tr class="memdesc:ga250db0598dcc1badc8a463083966f293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga250db0598dcc1badc8a463083966f293">More...</a><br/></td></tr>
<tr class="separator:ga250db0598dcc1badc8a463083966f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0a1d5b83bdfa9af63f112d0a1e6e70"><td class="memItemLeft" align="right" valign="top">mask_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaba0a1d5b83bdfa9af63f112d0a1e6e70">simdpp::bit_andnot</a> (mask_int8x16 a, mask_int8x16 b)</td></tr>
<tr class="memdesc:gaba0a1d5b83bdfa9af63f112d0a1e6e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#gaba0a1d5b83bdfa9af63f112d0a1e6e70">More...</a><br/></td></tr>
<tr class="separator:gaba0a1d5b83bdfa9af63f112d0a1e6e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739060c8c8e59d3d38c981c851b9be9a"><td class="memItemLeft" align="right" valign="top">mask_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga739060c8c8e59d3d38c981c851b9be9a">simdpp::bit_andnot</a> (mask_int16x8 a, mask_int16x8 b)</td></tr>
<tr class="memdesc:ga739060c8c8e59d3d38c981c851b9be9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga739060c8c8e59d3d38c981c851b9be9a">More...</a><br/></td></tr>
<tr class="separator:ga739060c8c8e59d3d38c981c851b9be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773466353f82f3f8cec8b2f093d77a21"><td class="memItemLeft" align="right" valign="top">mask_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga773466353f82f3f8cec8b2f093d77a21">simdpp::bit_andnot</a> (mask_int32x4 a, mask_int32x4 b)</td></tr>
<tr class="memdesc:ga773466353f82f3f8cec8b2f093d77a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga773466353f82f3f8cec8b2f093d77a21">More...</a><br/></td></tr>
<tr class="separator:ga773466353f82f3f8cec8b2f093d77a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0ba9f49cda80ba7e476d675477e31f"><td class="memItemLeft" align="right" valign="top">mask_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga8e0ba9f49cda80ba7e476d675477e31f">simdpp::bit_andnot</a> (mask_int64x2 a, mask_int64x2 b)</td></tr>
<tr class="memdesc:ga8e0ba9f49cda80ba7e476d675477e31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga8e0ba9f49cda80ba7e476d675477e31f">More...</a><br/></td></tr>
<tr class="separator:ga8e0ba9f49cda80ba7e476d675477e31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e56608f88d37bb4d75d3509b63a258d"><td class="memItemLeft" align="right" valign="top">mask_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5e56608f88d37bb4d75d3509b63a258d">simdpp::bit_andnot</a> (mask_int8x32 a, mask_int8x32 b)</td></tr>
<tr class="memdesc:ga5e56608f88d37bb4d75d3509b63a258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga5e56608f88d37bb4d75d3509b63a258d">More...</a><br/></td></tr>
<tr class="separator:ga5e56608f88d37bb4d75d3509b63a258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e618858f4f5204e64180c4060888d5"><td class="memItemLeft" align="right" valign="top">mask_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga68e618858f4f5204e64180c4060888d5">simdpp::bit_andnot</a> (mask_int16x16 a, mask_int16x16 b)</td></tr>
<tr class="memdesc:ga68e618858f4f5204e64180c4060888d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga68e618858f4f5204e64180c4060888d5">More...</a><br/></td></tr>
<tr class="separator:ga68e618858f4f5204e64180c4060888d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50345fe2411fe11cc72a6806ba950097"><td class="memItemLeft" align="right" valign="top">mask_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga50345fe2411fe11cc72a6806ba950097">simdpp::bit_andnot</a> (mask_int32x8 a, mask_int32x8 b)</td></tr>
<tr class="memdesc:ga50345fe2411fe11cc72a6806ba950097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga50345fe2411fe11cc72a6806ba950097">More...</a><br/></td></tr>
<tr class="separator:ga50345fe2411fe11cc72a6806ba950097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08760d225cc119c477b24aecc982b675"><td class="memItemLeft" align="right" valign="top">mask_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga08760d225cc119c477b24aecc982b675">simdpp::bit_andnot</a> (mask_int64x4 a, mask_int64x4 b)</td></tr>
<tr class="memdesc:ga08760d225cc119c477b24aecc982b675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of integer vectors.  <a href="#ga08760d225cc119c477b24aecc982b675">More...</a><br/></td></tr>
<tr class="separator:ga08760d225cc119c477b24aecc982b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8461c07bae5722ab871bdf84b0c997b0"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga8461c07bae5722ab871bdf84b0c997b0">simdpp::bit_andnot</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:ga8461c07bae5722ab871bdf84b0c997b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga8461c07bae5722ab871bdf84b0c997b0">More...</a><br/></td></tr>
<tr class="separator:ga8461c07bae5722ab871bdf84b0c997b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39839d14a8f5aed751cf6055305582be"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga39839d14a8f5aed751cf6055305582be">simdpp::bit_andnot</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:ga39839d14a8f5aed751cf6055305582be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga39839d14a8f5aed751cf6055305582be">More...</a><br/></td></tr>
<tr class="separator:ga39839d14a8f5aed751cf6055305582be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ec5e88179efc48ddb268b705abd366"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa7ec5e88179efc48ddb268b705abd366">simdpp::bit_andnot</a> (float32x4 a, int128 b)</td></tr>
<tr class="memdesc:gaa7ec5e88179efc48ddb268b705abd366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#gaa7ec5e88179efc48ddb268b705abd366">More...</a><br/></td></tr>
<tr class="separator:gaa7ec5e88179efc48ddb268b705abd366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea3561376503dfd21dc027176da9358"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaaea3561376503dfd21dc027176da9358">simdpp::bit_andnot</a> (float32x8 a, int256 b)</td></tr>
<tr class="memdesc:gaaea3561376503dfd21dc027176da9358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#gaaea3561376503dfd21dc027176da9358">More...</a><br/></td></tr>
<tr class="separator:gaaea3561376503dfd21dc027176da9358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4721c3679acaaa5a5ce92d6f8eec47a1"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga4721c3679acaaa5a5ce92d6f8eec47a1">simdpp::bit_andnot</a> (float32x4 a, mask_float32x4 b)</td></tr>
<tr class="memdesc:ga4721c3679acaaa5a5ce92d6f8eec47a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga4721c3679acaaa5a5ce92d6f8eec47a1">More...</a><br/></td></tr>
<tr class="separator:ga4721c3679acaaa5a5ce92d6f8eec47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb8c3c1258315c89600decb3b313e396"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gacb8c3c1258315c89600decb3b313e396">simdpp::bit_andnot</a> (float32x8 a, mask_float32x8 b)</td></tr>
<tr class="memdesc:gacb8c3c1258315c89600decb3b313e396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#gacb8c3c1258315c89600decb3b313e396">More...</a><br/></td></tr>
<tr class="separator:gacb8c3c1258315c89600decb3b313e396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936f3d9d8758c28d28fac621d4fb8ea0"><td class="memItemLeft" align="right" valign="top">mask_float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga936f3d9d8758c28d28fac621d4fb8ea0">simdpp::bit_andnot</a> (mask_float32x4 a, mask_float32x4 b)</td></tr>
<tr class="memdesc:ga936f3d9d8758c28d28fac621d4fb8ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga936f3d9d8758c28d28fac621d4fb8ea0">More...</a><br/></td></tr>
<tr class="separator:ga936f3d9d8758c28d28fac621d4fb8ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f5d24fb122853e0d7e3599b3250c4a"><td class="memItemLeft" align="right" valign="top">mask_float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad5f5d24fb122853e0d7e3599b3250c4a">simdpp::bit_andnot</a> (mask_float32x8 a, mask_float32x8 b)</td></tr>
<tr class="memdesc:gad5f5d24fb122853e0d7e3599b3250c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#gad5f5d24fb122853e0d7e3599b3250c4a">More...</a><br/></td></tr>
<tr class="separator:gad5f5d24fb122853e0d7e3599b3250c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c520d14c813692296450d2b846606e"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga39c520d14c813692296450d2b846606e">simdpp::bit_andnot</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:ga39c520d14c813692296450d2b846606e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga39c520d14c813692296450d2b846606e">More...</a><br/></td></tr>
<tr class="separator:ga39c520d14c813692296450d2b846606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee1d48b2607e29ab97b0dab0125b685"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gadee1d48b2607e29ab97b0dab0125b685">simdpp::bit_andnot</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:gadee1d48b2607e29ab97b0dab0125b685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#gadee1d48b2607e29ab97b0dab0125b685">More...</a><br/></td></tr>
<tr class="separator:gadee1d48b2607e29ab97b0dab0125b685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12968608c7c7a375169ab2d7b34e00f"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf12968608c7c7a375169ab2d7b34e00f">simdpp::bit_andnot</a> (float64x2 a, int128 b)</td></tr>
<tr class="memdesc:gaf12968608c7c7a375169ab2d7b34e00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#gaf12968608c7c7a375169ab2d7b34e00f">More...</a><br/></td></tr>
<tr class="separator:gaf12968608c7c7a375169ab2d7b34e00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d05d7cd31f47af7003c25407a39566f"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga2d05d7cd31f47af7003c25407a39566f">simdpp::bit_andnot</a> (float64x4 a, int256 b)</td></tr>
<tr class="memdesc:ga2d05d7cd31f47af7003c25407a39566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga2d05d7cd31f47af7003c25407a39566f">More...</a><br/></td></tr>
<tr class="separator:ga2d05d7cd31f47af7003c25407a39566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769c14670ba6685ad42a043219bc8599"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga769c14670ba6685ad42a043219bc8599">simdpp::bit_andnot</a> (float64x2 a, mask_float64x2 b)</td></tr>
<tr class="memdesc:ga769c14670ba6685ad42a043219bc8599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga769c14670ba6685ad42a043219bc8599">More...</a><br/></td></tr>
<tr class="separator:ga769c14670ba6685ad42a043219bc8599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eac3fa204b23b45ea558699400cd191"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga2eac3fa204b23b45ea558699400cd191">simdpp::bit_andnot</a> (float64x4 a, mask_float64x4 b)</td></tr>
<tr class="memdesc:ga2eac3fa204b23b45ea558699400cd191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga2eac3fa204b23b45ea558699400cd191">More...</a><br/></td></tr>
<tr class="separator:ga2eac3fa204b23b45ea558699400cd191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c346651ddf93fa6513e6124bdb694c"><td class="memItemLeft" align="right" valign="top">mask_float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga07c346651ddf93fa6513e6124bdb694c">simdpp::bit_andnot</a> (mask_float64x2 a, mask_float64x2 b)</td></tr>
<tr class="memdesc:ga07c346651ddf93fa6513e6124bdb694c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga07c346651ddf93fa6513e6124bdb694c">More...</a><br/></td></tr>
<tr class="separator:ga07c346651ddf93fa6513e6124bdb694c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e0cd9caaeb0ec4436ba7f5c52d2675"><td class="memItemLeft" align="right" valign="top">mask_float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga34e0cd9caaeb0ec4436ba7f5c52d2675">simdpp::bit_andnot</a> (mask_float64x4 a, mask_float64x4 b)</td></tr>
<tr class="memdesc:ga34e0cd9caaeb0ec4436ba7f5c52d2675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of floating-point vectors.  <a href="#ga34e0cd9caaeb0ec4436ba7f5c52d2675">More...</a><br/></td></tr>
<tr class="separator:ga34e0cd9caaeb0ec4436ba7f5c52d2675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1958e6bb0a65b36eb4af2d1ca6fc8e7d"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1958e6bb0a65b36eb4af2d1ca6fc8e7d">simdpp::bit_or</a> (basic_int8x16 a, int128 b)</td></tr>
<tr class="memdesc:ga1958e6bb0a65b36eb4af2d1ca6fc8e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga1958e6bb0a65b36eb4af2d1ca6fc8e7d">More...</a><br/></td></tr>
<tr class="separator:ga1958e6bb0a65b36eb4af2d1ca6fc8e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75dc563e5346e4ab4c77026194bd586c"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga75dc563e5346e4ab4c77026194bd586c">simdpp::bit_or</a> (basic_int16x8 a, int128 b)</td></tr>
<tr class="memdesc:ga75dc563e5346e4ab4c77026194bd586c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga75dc563e5346e4ab4c77026194bd586c">More...</a><br/></td></tr>
<tr class="separator:ga75dc563e5346e4ab4c77026194bd586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0e9486d0810a6ecff973e0c83ad9601"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gae0e9486d0810a6ecff973e0c83ad9601">simdpp::bit_or</a> (basic_int32x4 a, int128 b)</td></tr>
<tr class="memdesc:gae0e9486d0810a6ecff973e0c83ad9601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#gae0e9486d0810a6ecff973e0c83ad9601">More...</a><br/></td></tr>
<tr class="separator:gae0e9486d0810a6ecff973e0c83ad9601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250f3cbd55a5a5bfd355cf7e6c6781d4"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga250f3cbd55a5a5bfd355cf7e6c6781d4">simdpp::bit_or</a> (basic_int64x2 a, int128 b)</td></tr>
<tr class="memdesc:ga250f3cbd55a5a5bfd355cf7e6c6781d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga250f3cbd55a5a5bfd355cf7e6c6781d4">More...</a><br/></td></tr>
<tr class="separator:ga250f3cbd55a5a5bfd355cf7e6c6781d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494bc23fdd3f1ff650dab50608c6ab5a"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga494bc23fdd3f1ff650dab50608c6ab5a">simdpp::bit_or</a> (basic_int8x32 a, int256 b)</td></tr>
<tr class="memdesc:ga494bc23fdd3f1ff650dab50608c6ab5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga494bc23fdd3f1ff650dab50608c6ab5a">More...</a><br/></td></tr>
<tr class="separator:ga494bc23fdd3f1ff650dab50608c6ab5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac945c90073aaf0c4331ed4e97e02a8d7"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac945c90073aaf0c4331ed4e97e02a8d7">simdpp::bit_or</a> (basic_int16x16 a, int256 b)</td></tr>
<tr class="memdesc:gac945c90073aaf0c4331ed4e97e02a8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#gac945c90073aaf0c4331ed4e97e02a8d7">More...</a><br/></td></tr>
<tr class="separator:gac945c90073aaf0c4331ed4e97e02a8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2d8ade8cf9e94ea682a9f4fa80d87f"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1f2d8ade8cf9e94ea682a9f4fa80d87f">simdpp::bit_or</a> (basic_int32x8 a, int256 b)</td></tr>
<tr class="memdesc:ga1f2d8ade8cf9e94ea682a9f4fa80d87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga1f2d8ade8cf9e94ea682a9f4fa80d87f">More...</a><br/></td></tr>
<tr class="separator:ga1f2d8ade8cf9e94ea682a9f4fa80d87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71261893a4d7f8e92b7b81356cbbc31a"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga71261893a4d7f8e92b7b81356cbbc31a">simdpp::bit_or</a> (basic_int64x4 a, int256 b)</td></tr>
<tr class="memdesc:ga71261893a4d7f8e92b7b81356cbbc31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga71261893a4d7f8e92b7b81356cbbc31a">More...</a><br/></td></tr>
<tr class="separator:ga71261893a4d7f8e92b7b81356cbbc31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5544235096824a5153e96855f58f8be3"><td class="memItemLeft" align="right" valign="top">mask_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5544235096824a5153e96855f58f8be3">simdpp::bit_or</a> (mask_int8x16 a, mask_int8x16 b)</td></tr>
<tr class="memdesc:ga5544235096824a5153e96855f58f8be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga5544235096824a5153e96855f58f8be3">More...</a><br/></td></tr>
<tr class="separator:ga5544235096824a5153e96855f58f8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga303e1a6ada60a5a685a526087d8fcea0"><td class="memItemLeft" align="right" valign="top">mask_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga303e1a6ada60a5a685a526087d8fcea0">simdpp::bit_or</a> (mask_int16x8 a, mask_int16x8 b)</td></tr>
<tr class="memdesc:ga303e1a6ada60a5a685a526087d8fcea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga303e1a6ada60a5a685a526087d8fcea0">More...</a><br/></td></tr>
<tr class="separator:ga303e1a6ada60a5a685a526087d8fcea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6945d466390e945b26c6aee72fbb0cd"><td class="memItemLeft" align="right" valign="top">mask_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad6945d466390e945b26c6aee72fbb0cd">simdpp::bit_or</a> (mask_int32x4 a, mask_int32x4 b)</td></tr>
<tr class="memdesc:gad6945d466390e945b26c6aee72fbb0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#gad6945d466390e945b26c6aee72fbb0cd">More...</a><br/></td></tr>
<tr class="separator:gad6945d466390e945b26c6aee72fbb0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c041ac3b13229162aab0c2e9d6d484"><td class="memItemLeft" align="right" valign="top">mask_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga38c041ac3b13229162aab0c2e9d6d484">simdpp::bit_or</a> (mask_int64x2 a, mask_int64x2 b)</td></tr>
<tr class="memdesc:ga38c041ac3b13229162aab0c2e9d6d484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga38c041ac3b13229162aab0c2e9d6d484">More...</a><br/></td></tr>
<tr class="separator:ga38c041ac3b13229162aab0c2e9d6d484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556355954203641fc165bd2aa8f7681d"><td class="memItemLeft" align="right" valign="top">mask_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga556355954203641fc165bd2aa8f7681d">simdpp::bit_or</a> (mask_int8x32 a, mask_int8x32 b)</td></tr>
<tr class="memdesc:ga556355954203641fc165bd2aa8f7681d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga556355954203641fc165bd2aa8f7681d">More...</a><br/></td></tr>
<tr class="separator:ga556355954203641fc165bd2aa8f7681d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c2bdc5e38519720a4027d276dd2e29"><td class="memItemLeft" align="right" valign="top">mask_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga92c2bdc5e38519720a4027d276dd2e29">simdpp::bit_or</a> (mask_int16x16 a, mask_int16x16 b)</td></tr>
<tr class="memdesc:ga92c2bdc5e38519720a4027d276dd2e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga92c2bdc5e38519720a4027d276dd2e29">More...</a><br/></td></tr>
<tr class="separator:ga92c2bdc5e38519720a4027d276dd2e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff22e2053cfa8323cc8aebeb49fe887"><td class="memItemLeft" align="right" valign="top">mask_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga3ff22e2053cfa8323cc8aebeb49fe887">simdpp::bit_or</a> (mask_int32x8 a, mask_int32x8 b)</td></tr>
<tr class="memdesc:ga3ff22e2053cfa8323cc8aebeb49fe887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#ga3ff22e2053cfa8323cc8aebeb49fe887">More...</a><br/></td></tr>
<tr class="separator:ga3ff22e2053cfa8323cc8aebeb49fe887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3c2b83b4bed02d2635fee5d7bf8680"><td class="memItemLeft" align="right" valign="top">mask_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaaa3c2b83b4bed02d2635fee5d7bf8680">simdpp::bit_or</a> (mask_int64x4 a, mask_int64x4 b)</td></tr>
<tr class="memdesc:gaaa3c2b83b4bed02d2635fee5d7bf8680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#gaaa3c2b83b4bed02d2635fee5d7bf8680">More...</a><br/></td></tr>
<tr class="separator:gaaa3c2b83b4bed02d2635fee5d7bf8680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb06909c2b8306d7d9b01af24aa0276b"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gabb06909c2b8306d7d9b01af24aa0276b">simdpp::bit_or</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:gabb06909c2b8306d7d9b01af24aa0276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#gabb06909c2b8306d7d9b01af24aa0276b">More...</a><br/></td></tr>
<tr class="separator:gabb06909c2b8306d7d9b01af24aa0276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad55e53d6035ef9bf31aba0ebf7468deb"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad55e53d6035ef9bf31aba0ebf7468deb">simdpp::bit_or</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:gad55e53d6035ef9bf31aba0ebf7468deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#gad55e53d6035ef9bf31aba0ebf7468deb">More...</a><br/></td></tr>
<tr class="separator:gad55e53d6035ef9bf31aba0ebf7468deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78aba2dae1d820c8ebbeeb8ec7a4dc5"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac78aba2dae1d820c8ebbeeb8ec7a4dc5">simdpp::bit_or</a> (float32x4 a, int128 b)</td></tr>
<tr class="memdesc:gac78aba2dae1d820c8ebbeeb8ec7a4dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#gac78aba2dae1d820c8ebbeeb8ec7a4dc5">More...</a><br/></td></tr>
<tr class="separator:gac78aba2dae1d820c8ebbeeb8ec7a4dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a912490552ee8919aad4de46ea043c"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab3a912490552ee8919aad4de46ea043c">simdpp::bit_or</a> (float32x8 a, int256 b)</td></tr>
<tr class="memdesc:gab3a912490552ee8919aad4de46ea043c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#gab3a912490552ee8919aad4de46ea043c">More...</a><br/></td></tr>
<tr class="separator:gab3a912490552ee8919aad4de46ea043c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd99747ebc1f3401c729c5f03f34a735"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gafd99747ebc1f3401c729c5f03f34a735">simdpp::bit_or</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:gafd99747ebc1f3401c729c5f03f34a735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#gafd99747ebc1f3401c729c5f03f34a735">More...</a><br/></td></tr>
<tr class="separator:gafd99747ebc1f3401c729c5f03f34a735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827adc4d9970cd6062533b691490584f"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga827adc4d9970cd6062533b691490584f">simdpp::bit_or</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:ga827adc4d9970cd6062533b691490584f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#ga827adc4d9970cd6062533b691490584f">More...</a><br/></td></tr>
<tr class="separator:ga827adc4d9970cd6062533b691490584f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e63689904d74befc189dc032513e7f9"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga2e63689904d74befc189dc032513e7f9">simdpp::bit_or</a> (float64x2 a, int128 b)</td></tr>
<tr class="memdesc:ga2e63689904d74befc189dc032513e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#ga2e63689904d74befc189dc032513e7f9">More...</a><br/></td></tr>
<tr class="separator:ga2e63689904d74befc189dc032513e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99982dc8d31e449820cc84be902d2fc4"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga99982dc8d31e449820cc84be902d2fc4">simdpp::bit_or</a> (float64x4 a, int256 b)</td></tr>
<tr class="memdesc:ga99982dc8d31e449820cc84be902d2fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#ga99982dc8d31e449820cc84be902d2fc4">More...</a><br/></td></tr>
<tr class="separator:ga99982dc8d31e449820cc84be902d2fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92297d7d89a0ada503225d3024144871"><td class="memItemLeft" align="right" valign="top">mask_float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga92297d7d89a0ada503225d3024144871">simdpp::bit_or</a> (mask_float32x4 a, mask_float32x4 b)</td></tr>
<tr class="memdesc:ga92297d7d89a0ada503225d3024144871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#ga92297d7d89a0ada503225d3024144871">More...</a><br/></td></tr>
<tr class="separator:ga92297d7d89a0ada503225d3024144871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6253e7ba3f657dc25fce5db55b2f3347"><td class="memItemLeft" align="right" valign="top">mask_float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga6253e7ba3f657dc25fce5db55b2f3347">simdpp::bit_or</a> (mask_float64x2 a, mask_float64x2 b)</td></tr>
<tr class="memdesc:ga6253e7ba3f657dc25fce5db55b2f3347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#ga6253e7ba3f657dc25fce5db55b2f3347">More...</a><br/></td></tr>
<tr class="separator:ga6253e7ba3f657dc25fce5db55b2f3347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bdf97619fe90a85ec4955597b47366"><td class="memItemLeft" align="right" valign="top">mask_float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab4bdf97619fe90a85ec4955597b47366">simdpp::bit_or</a> (mask_float32x8 a, mask_float32x8 b)</td></tr>
<tr class="memdesc:gab4bdf97619fe90a85ec4955597b47366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#gab4bdf97619fe90a85ec4955597b47366">More...</a><br/></td></tr>
<tr class="separator:gab4bdf97619fe90a85ec4955597b47366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c94548272da48f86c4510b7158f1d21"><td class="memItemLeft" align="right" valign="top">mask_float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga9c94548272da48f86c4510b7158f1d21">simdpp::bit_or</a> (mask_float64x4 a, mask_float64x4 b)</td></tr>
<tr class="memdesc:ga9c94548272da48f86c4510b7158f1d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of floating-point vectors.  <a href="#ga9c94548272da48f86c4510b7158f1d21">More...</a><br/></td></tr>
<tr class="separator:ga9c94548272da48f86c4510b7158f1d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b1932f11922f9d1e4900a849c0aa9f"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf2b1932f11922f9d1e4900a849c0aa9f">simdpp::bit_xor</a> (basic_int8x16 a, int128 b)</td></tr>
<tr class="memdesc:gaf2b1932f11922f9d1e4900a849c0aa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#gaf2b1932f11922f9d1e4900a849c0aa9f">More...</a><br/></td></tr>
<tr class="separator:gaf2b1932f11922f9d1e4900a849c0aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e12d2804344944c0dcc665fa27df7e"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga02e12d2804344944c0dcc665fa27df7e">simdpp::bit_xor</a> (basic_int16x8 a, int128 b)</td></tr>
<tr class="memdesc:ga02e12d2804344944c0dcc665fa27df7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga02e12d2804344944c0dcc665fa27df7e">More...</a><br/></td></tr>
<tr class="separator:ga02e12d2804344944c0dcc665fa27df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1840c34a21627fc524d7606fa2304ee1"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1840c34a21627fc524d7606fa2304ee1">simdpp::bit_xor</a> (basic_int32x4 a, int128 b)</td></tr>
<tr class="memdesc:ga1840c34a21627fc524d7606fa2304ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga1840c34a21627fc524d7606fa2304ee1">More...</a><br/></td></tr>
<tr class="separator:ga1840c34a21627fc524d7606fa2304ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29781261137b95e86ebfdc167810b72"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab29781261137b95e86ebfdc167810b72">simdpp::bit_xor</a> (basic_int64x2 a, int128 b)</td></tr>
<tr class="memdesc:gab29781261137b95e86ebfdc167810b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#gab29781261137b95e86ebfdc167810b72">More...</a><br/></td></tr>
<tr class="separator:gab29781261137b95e86ebfdc167810b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0f9b30e0b722003d9d5100e31d3299"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga9c0f9b30e0b722003d9d5100e31d3299">simdpp::bit_xor</a> (basic_int8x32 a, int256 b)</td></tr>
<tr class="memdesc:ga9c0f9b30e0b722003d9d5100e31d3299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga9c0f9b30e0b722003d9d5100e31d3299">More...</a><br/></td></tr>
<tr class="separator:ga9c0f9b30e0b722003d9d5100e31d3299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15eb76e6d9603f03231ae04b56bccee6"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga15eb76e6d9603f03231ae04b56bccee6">simdpp::bit_xor</a> (basic_int16x16 a, int256 b)</td></tr>
<tr class="memdesc:ga15eb76e6d9603f03231ae04b56bccee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga15eb76e6d9603f03231ae04b56bccee6">More...</a><br/></td></tr>
<tr class="separator:ga15eb76e6d9603f03231ae04b56bccee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794540ddc79e9cd97a70dd36f4920434"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga794540ddc79e9cd97a70dd36f4920434">simdpp::bit_xor</a> (basic_int32x8 a, int256 b)</td></tr>
<tr class="memdesc:ga794540ddc79e9cd97a70dd36f4920434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga794540ddc79e9cd97a70dd36f4920434">More...</a><br/></td></tr>
<tr class="separator:ga794540ddc79e9cd97a70dd36f4920434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa76cef51f7f383d096a9f7649ea24cc"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaaa76cef51f7f383d096a9f7649ea24cc">simdpp::bit_xor</a> (basic_int64x4 a, int256 b)</td></tr>
<tr class="memdesc:gaaa76cef51f7f383d096a9f7649ea24cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#gaaa76cef51f7f383d096a9f7649ea24cc">More...</a><br/></td></tr>
<tr class="separator:gaaa76cef51f7f383d096a9f7649ea24cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5c2810e912dec374f1a5fe9be0110a"><td class="memItemLeft" align="right" valign="top">mask_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gafa5c2810e912dec374f1a5fe9be0110a">simdpp::bit_xor</a> (mask_int8x16 a, mask_int8x16 b)</td></tr>
<tr class="memdesc:gafa5c2810e912dec374f1a5fe9be0110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#gafa5c2810e912dec374f1a5fe9be0110a">More...</a><br/></td></tr>
<tr class="separator:gafa5c2810e912dec374f1a5fe9be0110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a044e97f486ccda685c341bdaf1594"><td class="memItemLeft" align="right" valign="top">mask_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga30a044e97f486ccda685c341bdaf1594">simdpp::bit_xor</a> (mask_int16x8 a, mask_int16x8 b)</td></tr>
<tr class="memdesc:ga30a044e97f486ccda685c341bdaf1594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga30a044e97f486ccda685c341bdaf1594">More...</a><br/></td></tr>
<tr class="separator:ga30a044e97f486ccda685c341bdaf1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1086ab55b2418284c230071ef142d6fd"><td class="memItemLeft" align="right" valign="top">mask_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1086ab55b2418284c230071ef142d6fd">simdpp::bit_xor</a> (mask_int32x4 a, mask_int32x4 b)</td></tr>
<tr class="memdesc:ga1086ab55b2418284c230071ef142d6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga1086ab55b2418284c230071ef142d6fd">More...</a><br/></td></tr>
<tr class="separator:ga1086ab55b2418284c230071ef142d6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e95c442e3770fa30737d34c741a59ea"><td class="memItemLeft" align="right" valign="top">mask_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1e95c442e3770fa30737d34c741a59ea">simdpp::bit_xor</a> (mask_int64x2 a, mask_int64x2 b)</td></tr>
<tr class="memdesc:ga1e95c442e3770fa30737d34c741a59ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga1e95c442e3770fa30737d34c741a59ea">More...</a><br/></td></tr>
<tr class="separator:ga1e95c442e3770fa30737d34c741a59ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae7b6e480898c941038ed6ec0250c76"><td class="memItemLeft" align="right" valign="top">mask_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gabae7b6e480898c941038ed6ec0250c76">simdpp::bit_xor</a> (mask_int8x32 a, mask_int8x32 b)</td></tr>
<tr class="memdesc:gabae7b6e480898c941038ed6ec0250c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#gabae7b6e480898c941038ed6ec0250c76">More...</a><br/></td></tr>
<tr class="separator:gabae7b6e480898c941038ed6ec0250c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558e650637536f69b18433c59c973fe6"><td class="memItemLeft" align="right" valign="top">mask_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga558e650637536f69b18433c59c973fe6">simdpp::bit_xor</a> (mask_int16x16 a, mask_int16x16 b)</td></tr>
<tr class="memdesc:ga558e650637536f69b18433c59c973fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga558e650637536f69b18433c59c973fe6">More...</a><br/></td></tr>
<tr class="separator:ga558e650637536f69b18433c59c973fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd01d926189f390680f7df640f07f5c"><td class="memItemLeft" align="right" valign="top">mask_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5dd01d926189f390680f7df640f07f5c">simdpp::bit_xor</a> (mask_int32x8 a, mask_int32x8 b)</td></tr>
<tr class="memdesc:ga5dd01d926189f390680f7df640f07f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#ga5dd01d926189f390680f7df640f07f5c">More...</a><br/></td></tr>
<tr class="separator:ga5dd01d926189f390680f7df640f07f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9db76ea4a3e7f5271babf666c77ab3d"><td class="memItemLeft" align="right" valign="top">mask_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gab9db76ea4a3e7f5271babf666c77ab3d">simdpp::bit_xor</a> (mask_int64x4 a, mask_int64x4 b)</td></tr>
<tr class="memdesc:gab9db76ea4a3e7f5271babf666c77ab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer vectors.  <a href="#gab9db76ea4a3e7f5271babf666c77ab3d">More...</a><br/></td></tr>
<tr class="separator:gab9db76ea4a3e7f5271babf666c77ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga419ddb312581a1ce0f4e88d4fa19e942"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga419ddb312581a1ce0f4e88d4fa19e942">simdpp::bit_xor</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:ga419ddb312581a1ce0f4e88d4fa19e942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#ga419ddb312581a1ce0f4e88d4fa19e942">More...</a><br/></td></tr>
<tr class="separator:ga419ddb312581a1ce0f4e88d4fa19e942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b3aea71e672c9a4bf4b7c1ad5a7161f"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1b3aea71e672c9a4bf4b7c1ad5a7161f">simdpp::bit_xor</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:ga1b3aea71e672c9a4bf4b7c1ad5a7161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#ga1b3aea71e672c9a4bf4b7c1ad5a7161f">More...</a><br/></td></tr>
<tr class="separator:ga1b3aea71e672c9a4bf4b7c1ad5a7161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae20a79b519ef2d0d6635c575dd3312d3"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gae20a79b519ef2d0d6635c575dd3312d3">simdpp::bit_xor</a> (float32x4 a, int128 b)</td></tr>
<tr class="memdesc:gae20a79b519ef2d0d6635c575dd3312d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#gae20a79b519ef2d0d6635c575dd3312d3">More...</a><br/></td></tr>
<tr class="separator:gae20a79b519ef2d0d6635c575dd3312d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d80a83b15a99c162908cb1bebe0caa"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga40d80a83b15a99c162908cb1bebe0caa">simdpp::bit_xor</a> (float32x8 a, int256 b)</td></tr>
<tr class="memdesc:ga40d80a83b15a99c162908cb1bebe0caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#ga40d80a83b15a99c162908cb1bebe0caa">More...</a><br/></td></tr>
<tr class="separator:ga40d80a83b15a99c162908cb1bebe0caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7716e5ea80431ee536f4ddb76efdcd5b"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga7716e5ea80431ee536f4ddb76efdcd5b">simdpp::bit_xor</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:ga7716e5ea80431ee536f4ddb76efdcd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#ga7716e5ea80431ee536f4ddb76efdcd5b">More...</a><br/></td></tr>
<tr class="separator:ga7716e5ea80431ee536f4ddb76efdcd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0afde8c400e117bfcc8f7e028907e6"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga9c0afde8c400e117bfcc8f7e028907e6">simdpp::bit_xor</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:ga9c0afde8c400e117bfcc8f7e028907e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#ga9c0afde8c400e117bfcc8f7e028907e6">More...</a><br/></td></tr>
<tr class="separator:ga9c0afde8c400e117bfcc8f7e028907e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6b66ba24a63186aa81c15dedd15a23"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaae6b66ba24a63186aa81c15dedd15a23">simdpp::bit_xor</a> (float64x2 a, int128 b)</td></tr>
<tr class="memdesc:gaae6b66ba24a63186aa81c15dedd15a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#gaae6b66ba24a63186aa81c15dedd15a23">More...</a><br/></td></tr>
<tr class="separator:gaae6b66ba24a63186aa81c15dedd15a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb64a752dace42356ecc5746c82b0e34"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gafb64a752dace42356ecc5746c82b0e34">simdpp::bit_xor</a> (float64x4 a, int256 b)</td></tr>
<tr class="memdesc:gafb64a752dace42356ecc5746c82b0e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#gafb64a752dace42356ecc5746c82b0e34">More...</a><br/></td></tr>
<tr class="separator:gafb64a752dace42356ecc5746c82b0e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac049081ee84c452f73aef0a5fa465378"><td class="memItemLeft" align="right" valign="top">mask_float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac049081ee84c452f73aef0a5fa465378">simdpp::bit_xor</a> (mask_float32x4 a, mask_float32x4 b)</td></tr>
<tr class="memdesc:gac049081ee84c452f73aef0a5fa465378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#gac049081ee84c452f73aef0a5fa465378">More...</a><br/></td></tr>
<tr class="separator:gac049081ee84c452f73aef0a5fa465378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7dcf40fb93d8de141af1e6af2cf763"><td class="memItemLeft" align="right" valign="top">mask_float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1d7dcf40fb93d8de141af1e6af2cf763">simdpp::bit_xor</a> (mask_float64x2 a, mask_float64x2 b)</td></tr>
<tr class="memdesc:ga1d7dcf40fb93d8de141af1e6af2cf763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#ga1d7dcf40fb93d8de141af1e6af2cf763">More...</a><br/></td></tr>
<tr class="separator:ga1d7dcf40fb93d8de141af1e6af2cf763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b603982930258eed51555820ed216c"><td class="memItemLeft" align="right" valign="top">mask_float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa4b603982930258eed51555820ed216c">simdpp::bit_xor</a> (mask_float32x8 a, mask_float32x8 b)</td></tr>
<tr class="memdesc:gaa4b603982930258eed51555820ed216c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#gaa4b603982930258eed51555820ed216c">More...</a><br/></td></tr>
<tr class="separator:gaa4b603982930258eed51555820ed216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87b04a4ab8b2493dc91405c40c48bd6"><td class="memItemLeft" align="right" valign="top">mask_float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad87b04a4ab8b2493dc91405c40c48bd6">simdpp::bit_xor</a> (mask_float64x4 a, mask_float64x4 b)</td></tr>
<tr class="memdesc:gad87b04a4ab8b2493dc91405c40c48bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of floating-point vectors.  <a href="#gad87b04a4ab8b2493dc91405c40c48bd6">More...</a><br/></td></tr>
<tr class="separator:gad87b04a4ab8b2493dc91405c40c48bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef152d274d5f826635a104871d03cb18"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaef152d274d5f826635a104871d03cb18">simdpp::bit_not</a> (basic_int8x16 a)</td></tr>
<tr class="memdesc:gaef152d274d5f826635a104871d03cb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#gaef152d274d5f826635a104871d03cb18">More...</a><br/></td></tr>
<tr class="separator:gaef152d274d5f826635a104871d03cb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0c7c3e846be8b6e55a901b18707ef1"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga4f0c7c3e846be8b6e55a901b18707ef1">simdpp::bit_not</a> (basic_int16x8 a)</td></tr>
<tr class="memdesc:ga4f0c7c3e846be8b6e55a901b18707ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga4f0c7c3e846be8b6e55a901b18707ef1">More...</a><br/></td></tr>
<tr class="separator:ga4f0c7c3e846be8b6e55a901b18707ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad40543c32573a6e7d0c77e52ea971ee5"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gad40543c32573a6e7d0c77e52ea971ee5">simdpp::bit_not</a> (basic_int32x4 a)</td></tr>
<tr class="memdesc:gad40543c32573a6e7d0c77e52ea971ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#gad40543c32573a6e7d0c77e52ea971ee5">More...</a><br/></td></tr>
<tr class="separator:gad40543c32573a6e7d0c77e52ea971ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga803f75bee47baceb71badc200af676e3"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga803f75bee47baceb71badc200af676e3">simdpp::bit_not</a> (basic_int64x2 a)</td></tr>
<tr class="memdesc:ga803f75bee47baceb71badc200af676e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga803f75bee47baceb71badc200af676e3">More...</a><br/></td></tr>
<tr class="separator:ga803f75bee47baceb71badc200af676e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e4e2d54384f796f29d51bbd81dc8d2"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga76e4e2d54384f796f29d51bbd81dc8d2">simdpp::bit_not</a> (basic_int8x32 a)</td></tr>
<tr class="memdesc:ga76e4e2d54384f796f29d51bbd81dc8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga76e4e2d54384f796f29d51bbd81dc8d2">More...</a><br/></td></tr>
<tr class="separator:ga76e4e2d54384f796f29d51bbd81dc8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac346bf59a1223a48e7d786be1dc50143"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac346bf59a1223a48e7d786be1dc50143">simdpp::bit_not</a> (basic_int16x16 a)</td></tr>
<tr class="memdesc:gac346bf59a1223a48e7d786be1dc50143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#gac346bf59a1223a48e7d786be1dc50143">More...</a><br/></td></tr>
<tr class="separator:gac346bf59a1223a48e7d786be1dc50143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1a8ae2b8276491ba839b8d9ad47d79"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0d1a8ae2b8276491ba839b8d9ad47d79">simdpp::bit_not</a> (basic_int32x8 a)</td></tr>
<tr class="memdesc:ga0d1a8ae2b8276491ba839b8d9ad47d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga0d1a8ae2b8276491ba839b8d9ad47d79">More...</a><br/></td></tr>
<tr class="separator:ga0d1a8ae2b8276491ba839b8d9ad47d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf7d3a42f6d8e2c4d2929a005966d5e"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga8cf7d3a42f6d8e2c4d2929a005966d5e">simdpp::bit_not</a> (basic_int64x4 a)</td></tr>
<tr class="memdesc:ga8cf7d3a42f6d8e2c4d2929a005966d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga8cf7d3a42f6d8e2c4d2929a005966d5e">More...</a><br/></td></tr>
<tr class="separator:ga8cf7d3a42f6d8e2c4d2929a005966d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c52030ae7174e40cb15009238c1dd1"><td class="memItemLeft" align="right" valign="top">mask_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga23c52030ae7174e40cb15009238c1dd1">simdpp::bit_not</a> (mask_int8x16 a)</td></tr>
<tr class="memdesc:ga23c52030ae7174e40cb15009238c1dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga23c52030ae7174e40cb15009238c1dd1">More...</a><br/></td></tr>
<tr class="separator:ga23c52030ae7174e40cb15009238c1dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf764bfe544bfd088dec4f64f26a2d554"><td class="memItemLeft" align="right" valign="top">mask_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaf764bfe544bfd088dec4f64f26a2d554">simdpp::bit_not</a> (mask_int16x8 a)</td></tr>
<tr class="memdesc:gaf764bfe544bfd088dec4f64f26a2d554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#gaf764bfe544bfd088dec4f64f26a2d554">More...</a><br/></td></tr>
<tr class="separator:gaf764bfe544bfd088dec4f64f26a2d554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138f2ef4c8c2d694683260591a166be1"><td class="memItemLeft" align="right" valign="top">mask_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga138f2ef4c8c2d694683260591a166be1">simdpp::bit_not</a> (mask_int32x4 a)</td></tr>
<tr class="memdesc:ga138f2ef4c8c2d694683260591a166be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga138f2ef4c8c2d694683260591a166be1">More...</a><br/></td></tr>
<tr class="separator:ga138f2ef4c8c2d694683260591a166be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f958862956772dec15097349f3baa3"><td class="memItemLeft" align="right" valign="top">mask_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga09f958862956772dec15097349f3baa3">simdpp::bit_not</a> (mask_int64x2 a)</td></tr>
<tr class="memdesc:ga09f958862956772dec15097349f3baa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga09f958862956772dec15097349f3baa3">More...</a><br/></td></tr>
<tr class="separator:ga09f958862956772dec15097349f3baa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c8c28167ffd6ed3337bb841845243c0"><td class="memItemLeft" align="right" valign="top">mask_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga9c8c28167ffd6ed3337bb841845243c0">simdpp::bit_not</a> (mask_int8x32 a)</td></tr>
<tr class="memdesc:ga9c8c28167ffd6ed3337bb841845243c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga9c8c28167ffd6ed3337bb841845243c0">More...</a><br/></td></tr>
<tr class="separator:ga9c8c28167ffd6ed3337bb841845243c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa938b5ecce6572026726be1f606f173b"><td class="memItemLeft" align="right" valign="top">mask_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaa938b5ecce6572026726be1f606f173b">simdpp::bit_not</a> (mask_int16x16 a)</td></tr>
<tr class="memdesc:gaa938b5ecce6572026726be1f606f173b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#gaa938b5ecce6572026726be1f606f173b">More...</a><br/></td></tr>
<tr class="separator:gaa938b5ecce6572026726be1f606f173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb31389ff02374830fc520d418f25a2b"><td class="memItemLeft" align="right" valign="top">mask_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gaeb31389ff02374830fc520d418f25a2b">simdpp::bit_not</a> (mask_int32x8 a)</td></tr>
<tr class="memdesc:gaeb31389ff02374830fc520d418f25a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#gaeb31389ff02374830fc520d418f25a2b">More...</a><br/></td></tr>
<tr class="separator:gaeb31389ff02374830fc520d418f25a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bbeda5cf0eda061f121a5d26ec2c985"><td class="memItemLeft" align="right" valign="top">mask_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga0bbeda5cf0eda061f121a5d26ec2c985">simdpp::bit_not</a> (mask_int64x4 a)</td></tr>
<tr class="memdesc:ga0bbeda5cf0eda061f121a5d26ec2c985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer vector.  <a href="#ga0bbeda5cf0eda061f121a5d26ec2c985">More...</a><br/></td></tr>
<tr class="separator:ga0bbeda5cf0eda061f121a5d26ec2c985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d9687a753754269ccdd3f93c5bc04b5"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga1d9687a753754269ccdd3f93c5bc04b5">simdpp::bit_not</a> (float32x4 a)</td></tr>
<tr class="memdesc:ga1d9687a753754269ccdd3f93c5bc04b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#ga1d9687a753754269ccdd3f93c5bc04b5">More...</a><br/></td></tr>
<tr class="separator:ga1d9687a753754269ccdd3f93c5bc04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe290b8ccbbc3bbf7e9a8bbf16bba55c"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gabe290b8ccbbc3bbf7e9a8bbf16bba55c">simdpp::bit_not</a> (float64x2 a)</td></tr>
<tr class="memdesc:gabe290b8ccbbc3bbf7e9a8bbf16bba55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#gabe290b8ccbbc3bbf7e9a8bbf16bba55c">More...</a><br/></td></tr>
<tr class="separator:gabe290b8ccbbc3bbf7e9a8bbf16bba55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6fc80f7c054d523389159202aecbed"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga4b6fc80f7c054d523389159202aecbed">simdpp::bit_not</a> (float32x8 a)</td></tr>
<tr class="memdesc:ga4b6fc80f7c054d523389159202aecbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#ga4b6fc80f7c054d523389159202aecbed">More...</a><br/></td></tr>
<tr class="separator:ga4b6fc80f7c054d523389159202aecbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510fd0a7ddbb197fb73b75ac3ada4fd6"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga510fd0a7ddbb197fb73b75ac3ada4fd6">simdpp::bit_not</a> (float64x4 a)</td></tr>
<tr class="memdesc:ga510fd0a7ddbb197fb73b75ac3ada4fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#ga510fd0a7ddbb197fb73b75ac3ada4fd6">More...</a><br/></td></tr>
<tr class="separator:ga510fd0a7ddbb197fb73b75ac3ada4fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f934a00d51ce9799b82fcec0cf3875"><td class="memItemLeft" align="right" valign="top">mask_float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga78f934a00d51ce9799b82fcec0cf3875">simdpp::bit_not</a> (mask_float32x4 a)</td></tr>
<tr class="memdesc:ga78f934a00d51ce9799b82fcec0cf3875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#ga78f934a00d51ce9799b82fcec0cf3875">More...</a><br/></td></tr>
<tr class="separator:ga78f934a00d51ce9799b82fcec0cf3875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga870c0879f3f40507f629667e8d4213b7"><td class="memItemLeft" align="right" valign="top">mask_float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga870c0879f3f40507f629667e8d4213b7">simdpp::bit_not</a> (mask_float64x2 a)</td></tr>
<tr class="memdesc:ga870c0879f3f40507f629667e8d4213b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#ga870c0879f3f40507f629667e8d4213b7">More...</a><br/></td></tr>
<tr class="separator:ga870c0879f3f40507f629667e8d4213b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5136489ee4a01cf50f3c749354383029"><td class="memItemLeft" align="right" valign="top">mask_float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#ga5136489ee4a01cf50f3c749354383029">simdpp::bit_not</a> (mask_float32x8 a)</td></tr>
<tr class="memdesc:ga5136489ee4a01cf50f3c749354383029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#ga5136489ee4a01cf50f3c749354383029">More...</a><br/></td></tr>
<tr class="separator:ga5136489ee4a01cf50f3c749354383029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57c8d0021331a8249afc01f2eb4b7c1"><td class="memItemLeft" align="right" valign="top">mask_float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html#gac57c8d0021331a8249afc01f2eb4b7c1">simdpp::bit_not</a> (mask_float64x4 a)</td></tr>
<tr class="memdesc:gac57c8d0021331a8249afc01f2eb4b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of a floating-point vector.  <a href="#gac57c8d0021331a8249afc01f2eb4b7c1">More...</a><br/></td></tr>
<tr class="separator:gac57c8d0021331a8249afc01f2eb4b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad065347d125f9e587850c0b4e2ffbe5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7ab9f7181fb699f03ee9bfcb0631cc23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa578278499dec0b2a195ef5976075626"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf21756d4c5ab1c0df8fe6070ecbb89a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1db3bd5099262dd9c9122eef8d6f4bcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4ac32297206e551cb0235ec44cd70720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga999480b1f72bae63fdf07b5da553ce5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaab4d10e0f5fafcc3896aaf1d2907a1a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab6c6f3080d03e43610f4ad231e710433"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad2b8b0a9cd251fe197922243cbb979b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad6ee0c20b05029aea2acc32074b4361b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae63ab0d887a6a7970bf8bdcdd42b945c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0b3e1721479be3d4dd07344e4850b4d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4b2f909a6440d3f2750a23a6055190f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0a415dcd55e5e3dddd2c0bd3838d62b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gabe8aab353d18116cb2eddf6694a54b22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga08d19ef8c6e2e0b1ff0efa937cec17f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x16 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga25f201f5bc7b25163b856f25fbaefeb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac14b9dedb0bd7809440506123fb1657f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2e67e5d94dc6868a6903be1d192a5f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x2 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa2c113798ab21428e8517182c058c519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x32 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadaf3bd43045e3d326276ea2e2276fb97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x16 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf3b0f35fe4719698786ca7e27a8b85f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa97f86fcd1eb890fac794c1b3fc857b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2c80ed0acc7824f1c76b42750a571343"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaea919967acc78208ce9bf31433bf4f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa44241edb6e43d94074805a5488aebf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3c59608632e597d7dbe9721c8fdce14e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaec03d8007e973a5a3b9b5244be2a5e3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5240532c077d733d9d9a1991f04f72aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6b02df63cc18b6aec7ebe271c3f9ea19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab7dec285b91098e64559a05ea53b7ab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x8 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab7502addcadb5aa83597d8f788ea1a77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf70f49acc4cddb15ec941dcc6d7c05fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga30d5a105d788d9a2ba7120cdd014fcd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2f3f1e5ff54eb931bacce8daba98b528"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae82cdc4193410b872124e791cc7b85bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga13e07b0de62efda0795fee0cefef4a18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf683c09e35deccd2226aa2cc929304da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x2 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga287b7e879879ab33baec49f6b9f9f33b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x4 simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7bf37019b14a33b2da3f46dabf0c2b8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab9736affcc74ed8ea90e8f1df371ec6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga98ec4ec1c5fd41c8eca05859a05e41eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadce4b1d90a20bd206fe97be9d53b9b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga37d561032c1a7dfb336ea9d9304b88ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga13427756c772d7456d3ca8309cb1d75c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga05de150c123e36e26c1741294b1578bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6275a99347cb206ddac483d1c0ed04d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga00819672baf72b861584c322e6ad1229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadc298ddb17c09f2177590d00717c3647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0378cdb816f4aa6647f6cc0a9bee6602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa9c0dfa89561901d84f94531f0ee6ffc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6da2763dc5c6a7a229291adb037be516"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga67bca35f0edcbf347424ddd401bdba06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadd220df628f84e13269f323c2964db67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga250db0598dcc1badc8a463083966f293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaba0a1d5b83bdfa9af63f112d0a1e6e70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x16 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga739060c8c8e59d3d38c981c851b9be9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga773466353f82f3f8cec8b2f093d77a21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8e0ba9f49cda80ba7e476d675477e31f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x2 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5e56608f88d37bb4d75d3509b63a258d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x32 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga68e618858f4f5204e64180c4060888d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x16 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga50345fe2411fe11cc72a6806ba950097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga08760d225cc119c477b24aecc982b675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8461c07bae5722ab871bdf84b0c997b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga39839d14a8f5aed751cf6055305582be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa7ec5e88179efc48ddb268b705abd366"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaea3561376503dfd21dc027176da9358"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4721c3679acaaa5a5ce92d6f8eec47a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gacb8c3c1258315c89600decb3b313e396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga936f3d9d8758c28d28fac621d4fb8ea0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad5f5d24fb122853e0d7e3599b3250c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x8 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga39c520d14c813692296450d2b846606e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadee1d48b2607e29ab97b0dab0125b685"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf12968608c7c7a375169ab2d7b34e00f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2d05d7cd31f47af7003c25407a39566f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga769c14670ba6685ad42a043219bc8599"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2eac3fa204b23b45ea558699400cd191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga07c346651ddf93fa6513e6124bdb694c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x2 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga34e0cd9caaeb0ec4436ba7f5c52d2675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x4 simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaef152d274d5f826635a104871d03cb18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4f0c7c3e846be8b6e55a901b18707ef1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad40543c32573a6e7d0c77e52ea971ee5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga803f75bee47baceb71badc200af676e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga76e4e2d54384f796f29d51bbd81dc8d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac346bf59a1223a48e7d786be1dc50143"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0d1a8ae2b8276491ba839b8d9ad47d79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8cf7d3a42f6d8e2c4d2929a005966d5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga23c52030ae7174e40cb15009238c1dd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x16 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf764bfe544bfd088dec4f64f26a2d554"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x8 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga138f2ef4c8c2d694683260591a166be1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga09f958862956772dec15097349f3baa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x2 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9c8c28167ffd6ed3337bb841845243c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x32 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa938b5ecce6572026726be1f606f173b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x16 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaeb31389ff02374830fc520d418f25a2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x8 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0bbeda5cf0eda061f121a5d26ec2c985"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1d9687a753754269ccdd3f93c5bc04b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabe290b8ccbbc3bbf7e9a8bbf16bba55c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4b6fc80f7c054d523389159202aecbed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga510fd0a7ddbb197fb73b75ac3ada4fd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga78f934a00d51ce9799b82fcec0cf3875"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga870c0879f3f40507f629667e8d4213b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x2 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5136489ee4a01cf50f3c749354383029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x8 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac57c8d0021331a8249afc01f2eb4b7c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x4 simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise NOT of a floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1958e6bb0a65b36eb4af2d1ca6fc8e7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga75dc563e5346e4ab4c77026194bd586c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae0e9486d0810a6ecff973e0c83ad9601"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga250f3cbd55a5a5bfd355cf7e6c6781d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga494bc23fdd3f1ff650dab50608c6ab5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac945c90073aaf0c4331ed4e97e02a8d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1f2d8ade8cf9e94ea682a9f4fa80d87f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga71261893a4d7f8e92b7b81356cbbc31a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5544235096824a5153e96855f58f8be3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x16 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga303e1a6ada60a5a685a526087d8fcea0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x8 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad6945d466390e945b26c6aee72fbb0cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga38c041ac3b13229162aab0c2e9d6d484"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x2 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga556355954203641fc165bd2aa8f7681d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x32 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga92c2bdc5e38519720a4027d276dd2e29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x16 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3ff22e2053cfa8323cc8aebeb49fe887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x8 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaa3c2b83b4bed02d2635fee5d7bf8680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabb06909c2b8306d7d9b01af24aa0276b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad55e53d6035ef9bf31aba0ebf7468deb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac78aba2dae1d820c8ebbeeb8ec7a4dc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab3a912490552ee8919aad4de46ea043c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gafd99747ebc1f3401c729c5f03f34a735"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga827adc4d9970cd6062533b691490584f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2e63689904d74befc189dc032513e7f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga99982dc8d31e449820cc84be902d2fc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga92297d7d89a0ada503225d3024144871"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6253e7ba3f657dc25fce5db55b2f3347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x2 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab4bdf97619fe90a85ec4955597b47366"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x8 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9c94548272da48f86c4510b7158f1d21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x4 simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise OR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf2b1932f11922f9d1e4900a849c0aa9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga02e12d2804344944c0dcc665fa27df7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1840c34a21627fc524d7606fa2304ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab29781261137b95e86ebfdc167810b72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9c0f9b30e0b722003d9d5100e31d3299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga15eb76e6d9603f03231ae04b56bccee6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga794540ddc79e9cd97a70dd36f4920434"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaa76cef51f7f383d096a9f7649ea24cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gafa5c2810e912dec374f1a5fe9be0110a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x16 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga30a044e97f486ccda685c341bdaf1594"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x8 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1086ab55b2418284c230071ef142d6fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1e95c442e3770fa30737d34c741a59ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x2 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabae7b6e480898c941038ed6ec0250c76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int8x32 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga558e650637536f69b18433c59c973fe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int16x16 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5dd01d926189f390680f7df640f07f5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int32x8 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab9db76ea4a3e7f5271babf666c77ab3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_int64x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga419ddb312581a1ce0f4e88d4fa19e942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1b3aea71e672c9a4bf4b7c1ad5a7161f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae20a79b519ef2d0d6635c575dd3312d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga40d80a83b15a99c162908cb1bebe0caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7716e5ea80431ee536f4ddb76efdcd5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9c0afde8c400e117bfcc8f7e028907e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaae6b66ba24a63186aa81c15dedd15a23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gafb64a752dace42356ecc5746c82b0e34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac049081ee84c452f73aef0a5fa465378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1d7dcf40fb93d8de141af1e6af2cf763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x2 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa4b603982930258eed51555820ed216c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float32x8 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad87b04a4ab8b2493dc91405c40c48bd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mask_float64x4 simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask_float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes bitwise XOR of floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 31 2013 04:08:50 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</div>
</body>
</html>
