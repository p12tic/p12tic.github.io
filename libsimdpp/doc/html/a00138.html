<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>libsimdpp: Operations: shuffle elements within vectors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Operations: shuffle elements within vectors</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5a3442a5125f66e0e3c8633f896f693e"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga5a3442a5125f66e0e3c8633f896f693e">simdpp::zip_lo</a> (basic_int8x16 a, basic_int8x16 b)</td></tr>
<tr class="memdesc:ga5a3442a5125f66e0e3c8633f896f693e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#ga5a3442a5125f66e0e3c8633f896f693e">More...</a><br/></td></tr>
<tr class="separator:ga5a3442a5125f66e0e3c8633f896f693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf084e5798e6470299811c19b2eb0d8f"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gacf084e5798e6470299811c19b2eb0d8f">simdpp::zip_lo</a> (basic_int8x32 a, basic_int8x32 b)</td></tr>
<tr class="separator:gacf084e5798e6470299811c19b2eb0d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf950c12e66a5e457b3ab800f572f4c66"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaf950c12e66a5e457b3ab800f572f4c66">simdpp::zip_lo</a> (basic_int16x8 a, basic_int16x8 b)</td></tr>
<tr class="separator:gaf950c12e66a5e457b3ab800f572f4c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda5c78cf82e3932b4418801ffe73682"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gafda5c78cf82e3932b4418801ffe73682">simdpp::zip_lo</a> (basic_int16x16 a, basic_int16x16 b)</td></tr>
<tr class="separator:gafda5c78cf82e3932b4418801ffe73682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac1f09b54bfaee90ee54b98c3ecb6de"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gafac1f09b54bfaee90ee54b98c3ecb6de">simdpp::zip_lo</a> (basic_int32x4 a, basic_int32x4 b)</td></tr>
<tr class="separator:gafac1f09b54bfaee90ee54b98c3ecb6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c2db798e9b97669484ae7f67fffd6e"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae0c2db798e9b97669484ae7f67fffd6e">simdpp::zip_lo</a> (basic_int32x8 a, basic_int32x8 b)</td></tr>
<tr class="separator:gae0c2db798e9b97669484ae7f67fffd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62ec3026fbe36a9697ac41577aec443"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae62ec3026fbe36a9697ac41577aec443">simdpp::zip_lo</a> (basic_int64x2 a, basic_int64x2 b)</td></tr>
<tr class="separator:gae62ec3026fbe36a9697ac41577aec443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c1261eff359a9ab7fb2411d39969be"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa4c1261eff359a9ab7fb2411d39969be">simdpp::zip_lo</a> (basic_int64x4 a, basic_int64x4 b)</td></tr>
<tr class="separator:gaa4c1261eff359a9ab7fb2411d39969be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae61c49e9957279af09350d27a092b120"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1&gt; </td></tr>
<tr class="memitem:gae61c49e9957279af09350d27a092b120"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gae61c49e9957279af09350d27a092b120">simdpp::make_shuffle_bytes16_mask</a> (basic_int8x16 &amp;mask)</td></tr>
<tr class="memdesc:gae61c49e9957279af09350d27a092b120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#gae61c49e9957279af09350d27a092b120">More...</a><br/></td></tr>
<tr class="separator:gae61c49e9957279af09350d27a092b120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694d9d0eb46030a8dbb248c81be18463"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1&gt; </td></tr>
<tr class="memitem:ga694d9d0eb46030a8dbb248c81be18463"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga694d9d0eb46030a8dbb248c81be18463">simdpp::make_shuffle_bytes16_mask</a> (basic_int8x32 &amp;mask)</td></tr>
<tr class="memdesc:ga694d9d0eb46030a8dbb248c81be18463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#ga694d9d0eb46030a8dbb248c81be18463">More...</a><br/></td></tr>
<tr class="separator:ga694d9d0eb46030a8dbb248c81be18463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab45e3176ae6661fd389890f02b0db3e8"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab45e3176ae6661fd389890f02b0db3e8">simdpp::zip_lo</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:gab45e3176ae6661fd389890f02b0db3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#gab45e3176ae6661fd389890f02b0db3e8">More...</a><br/></td></tr>
<tr class="separator:gab45e3176ae6661fd389890f02b0db3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92465d8750270b142d2b1f21e39d7c17"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga92465d8750270b142d2b1f21e39d7c17">simdpp::zip_lo</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:ga92465d8750270b142d2b1f21e39d7c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#ga92465d8750270b142d2b1f21e39d7c17">More...</a><br/></td></tr>
<tr class="separator:ga92465d8750270b142d2b1f21e39d7c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a792fb4e41c4db087db85d018bdbd2a"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga6a792fb4e41c4db087db85d018bdbd2a">simdpp::zip_lo</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:ga6a792fb4e41c4db087db85d018bdbd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#ga6a792fb4e41c4db087db85d018bdbd2a">More...</a><br/></td></tr>
<tr class="separator:ga6a792fb4e41c4db087db85d018bdbd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab797f50f9a526802ec7c4c6f8e59d061"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab797f50f9a526802ec7c4c6f8e59d061">simdpp::zip_lo</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:gab797f50f9a526802ec7c4c6f8e59d061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#gab797f50f9a526802ec7c4c6f8e59d061">More...</a><br/></td></tr>
<tr class="separator:gab797f50f9a526802ec7c4c6f8e59d061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64860db308be1786a08a3a57d20b8dcb"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga64860db308be1786a08a3a57d20b8dcb">simdpp::zip_hi</a> (basic_int8x16 a, basic_int8x16 b)</td></tr>
<tr class="memdesc:ga64860db308be1786a08a3a57d20b8dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ga64860db308be1786a08a3a57d20b8dcb">More...</a><br/></td></tr>
<tr class="separator:ga64860db308be1786a08a3a57d20b8dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f5a8dedcd70966cdbd06ec17f20b92"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga76f5a8dedcd70966cdbd06ec17f20b92">simdpp::zip_hi</a> (basic_int8x32 a, basic_int8x32 b)</td></tr>
<tr class="memdesc:ga76f5a8dedcd70966cdbd06ec17f20b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ga76f5a8dedcd70966cdbd06ec17f20b92">More...</a><br/></td></tr>
<tr class="separator:ga76f5a8dedcd70966cdbd06ec17f20b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8384b7e8497054d962934e89803f825"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae8384b7e8497054d962934e89803f825">simdpp::zip_hi</a> (basic_int16x8 a, basic_int16x8 b)</td></tr>
<tr class="memdesc:gae8384b7e8497054d962934e89803f825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#gae8384b7e8497054d962934e89803f825">More...</a><br/></td></tr>
<tr class="separator:gae8384b7e8497054d962934e89803f825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab596314d94e8bfcf2e172b1b9f607302"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab596314d94e8bfcf2e172b1b9f607302">simdpp::zip_hi</a> (basic_int16x16 a, basic_int16x16 b)</td></tr>
<tr class="memdesc:gab596314d94e8bfcf2e172b1b9f607302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#gab596314d94e8bfcf2e172b1b9f607302">More...</a><br/></td></tr>
<tr class="separator:gab596314d94e8bfcf2e172b1b9f607302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b1f8733d36ba1073a7e0553342f4fe"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga38b1f8733d36ba1073a7e0553342f4fe">simdpp::zip_hi</a> (basic_int32x4 a, basic_int32x4 b)</td></tr>
<tr class="memdesc:ga38b1f8733d36ba1073a7e0553342f4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ga38b1f8733d36ba1073a7e0553342f4fe">More...</a><br/></td></tr>
<tr class="separator:ga38b1f8733d36ba1073a7e0553342f4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae64382bc666752c3759148416377cb"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga3ae64382bc666752c3759148416377cb">simdpp::zip_hi</a> (basic_int32x8 a, basic_int32x8 b)</td></tr>
<tr class="memdesc:ga3ae64382bc666752c3759148416377cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ga3ae64382bc666752c3759148416377cb">More...</a><br/></td></tr>
<tr class="separator:ga3ae64382bc666752c3759148416377cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8882eee76298860268fa8af3f742e3f4"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga8882eee76298860268fa8af3f742e3f4">simdpp::zip_hi</a> (basic_int64x2 a, basic_int64x2 b)</td></tr>
<tr class="memdesc:ga8882eee76298860268fa8af3f742e3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ga8882eee76298860268fa8af3f742e3f4">More...</a><br/></td></tr>
<tr class="separator:ga8882eee76298860268fa8af3f742e3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7eed2f705da7875abe019792e51e717"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa7eed2f705da7875abe019792e51e717">simdpp::zip_hi</a> (basic_int64x4 a, basic_int64x4 b)</td></tr>
<tr class="memdesc:gaa7eed2f705da7875abe019792e51e717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#gaa7eed2f705da7875abe019792e51e717">More...</a><br/></td></tr>
<tr class="separator:gaa7eed2f705da7875abe019792e51e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab748b9e5dcb3eb79703a6b06ac8d8b04"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab748b9e5dcb3eb79703a6b06ac8d8b04">simdpp::zip_hi</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:gab748b9e5dcb3eb79703a6b06ac8d8b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#gab748b9e5dcb3eb79703a6b06ac8d8b04">More...</a><br/></td></tr>
<tr class="separator:gab748b9e5dcb3eb79703a6b06ac8d8b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf017f9f875186958691b99500b397dd1"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaf017f9f875186958691b99500b397dd1">simdpp::zip_hi</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:gaf017f9f875186958691b99500b397dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#gaf017f9f875186958691b99500b397dd1">More...</a><br/></td></tr>
<tr class="separator:gaf017f9f875186958691b99500b397dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga414deb829db4fc078339d69473cd3bf1"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga414deb829db4fc078339d69473cd3bf1">simdpp::zip_hi</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:ga414deb829db4fc078339d69473cd3bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ga414deb829db4fc078339d69473cd3bf1">More...</a><br/></td></tr>
<tr class="separator:ga414deb829db4fc078339d69473cd3bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c81602b6990e266d3b267c3f5cac2bd"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga7c81602b6990e266d3b267c3f5cac2bd">simdpp::zip_hi</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:ga7c81602b6990e266d3b267c3f5cac2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ga7c81602b6990e266d3b267c3f5cac2bd">More...</a><br/></td></tr>
<tr class="separator:ga7c81602b6990e266d3b267c3f5cac2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5c4df0231fb6d26e6fcbaaababaf9e"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gabf5c4df0231fb6d26e6fcbaaababaf9e"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gabf5c4df0231fb6d26e6fcbaaababaf9e">simdpp::move_l</a> (basic_int8x16 a)</td></tr>
<tr class="memdesc:gabf5c4df0231fb6d26e6fcbaaababaf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector to the left by <em>shift</em> positions.  <a href="#gabf5c4df0231fb6d26e6fcbaaababaf9e">More...</a><br/></td></tr>
<tr class="separator:gabf5c4df0231fb6d26e6fcbaaababaf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd0d078e6f64f7b229c487f9ab6ce0f7"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gadd0d078e6f64f7b229c487f9ab6ce0f7"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gadd0d078e6f64f7b229c487f9ab6ce0f7">simdpp::move_l</a> (basic_int8x32 a)</td></tr>
<tr class="memdesc:gadd0d078e6f64f7b229c487f9ab6ce0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector to the left by <em>shift</em> positions.  <a href="#gadd0d078e6f64f7b229c487f9ab6ce0f7">More...</a><br/></td></tr>
<tr class="separator:gadd0d078e6f64f7b229c487f9ab6ce0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091f48b58c4359cd0eaa868ab9f8c658"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga091f48b58c4359cd0eaa868ab9f8c658"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga091f48b58c4359cd0eaa868ab9f8c658">simdpp::move_l</a> (basic_int16x8 a)</td></tr>
<tr class="memdesc:ga091f48b58c4359cd0eaa868ab9f8c658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 16-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#ga091f48b58c4359cd0eaa868ab9f8c658">More...</a><br/></td></tr>
<tr class="separator:ga091f48b58c4359cd0eaa868ab9f8c658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c4af646de8c0d78e308a0a7d860438"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga69c4af646de8c0d78e308a0a7d860438"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga69c4af646de8c0d78e308a0a7d860438">simdpp::move_l</a> (basic_int16x16 a)</td></tr>
<tr class="memdesc:ga69c4af646de8c0d78e308a0a7d860438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 16-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#ga69c4af646de8c0d78e308a0a7d860438">More...</a><br/></td></tr>
<tr class="separator:ga69c4af646de8c0d78e308a0a7d860438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeadaddeccce01a69b6ad1ee9d9bef9a"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gaaeadaddeccce01a69b6ad1ee9d9bef9a"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaaeadaddeccce01a69b6ad1ee9d9bef9a">simdpp::move_l</a> (basic_int32x4 a)</td></tr>
<tr class="memdesc:gaaeadaddeccce01a69b6ad1ee9d9bef9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#gaaeadaddeccce01a69b6ad1ee9d9bef9a">More...</a><br/></td></tr>
<tr class="separator:gaaeadaddeccce01a69b6ad1ee9d9bef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7323ea40ffe56b8cbf1d04b115fe8abc"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga7323ea40ffe56b8cbf1d04b115fe8abc"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga7323ea40ffe56b8cbf1d04b115fe8abc">simdpp::move_l</a> (basic_int32x8 a)</td></tr>
<tr class="memdesc:ga7323ea40ffe56b8cbf1d04b115fe8abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#ga7323ea40ffe56b8cbf1d04b115fe8abc">More...</a><br/></td></tr>
<tr class="separator:ga7323ea40ffe56b8cbf1d04b115fe8abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808347e7d20c776cf2805cff8c549fc2"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga808347e7d20c776cf2805cff8c549fc2"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga808347e7d20c776cf2805cff8c549fc2">simdpp::move_l</a> (basic_int64x2 a)</td></tr>
<tr class="memdesc:ga808347e7d20c776cf2805cff8c549fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#ga808347e7d20c776cf2805cff8c549fc2">More...</a><br/></td></tr>
<tr class="separator:ga808347e7d20c776cf2805cff8c549fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6483c5997ef72a168ef5b29293199d86"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga6483c5997ef72a168ef5b29293199d86"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga6483c5997ef72a168ef5b29293199d86">simdpp::move_l</a> (basic_int64x4 a)</td></tr>
<tr class="memdesc:ga6483c5997ef72a168ef5b29293199d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#ga6483c5997ef72a168ef5b29293199d86">More...</a><br/></td></tr>
<tr class="separator:ga6483c5997ef72a168ef5b29293199d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8e0d2f0f78ce0d13eb29dff352e575"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga1e8e0d2f0f78ce0d13eb29dff352e575"><td class="memTemplItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga1e8e0d2f0f78ce0d13eb29dff352e575">simdpp::move_l</a> (float32x4 a)</td></tr>
<tr class="memdesc:ga1e8e0d2f0f78ce0d13eb29dff352e575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#ga1e8e0d2f0f78ce0d13eb29dff352e575">More...</a><br/></td></tr>
<tr class="separator:ga1e8e0d2f0f78ce0d13eb29dff352e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53ea882d2b2d826dd1d9b648b9c9791"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gad53ea882d2b2d826dd1d9b648b9c9791"><td class="memTemplItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gad53ea882d2b2d826dd1d9b648b9c9791">simdpp::move_l</a> (float32x8 a)</td></tr>
<tr class="memdesc:gad53ea882d2b2d826dd1d9b648b9c9791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#gad53ea882d2b2d826dd1d9b648b9c9791">More...</a><br/></td></tr>
<tr class="separator:gad53ea882d2b2d826dd1d9b648b9c9791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7e230d030b4efcf9f48f720cc9eb0f"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gafa7e230d030b4efcf9f48f720cc9eb0f"><td class="memTemplItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gafa7e230d030b4efcf9f48f720cc9eb0f">simdpp::move_l</a> (float64x2 a)</td></tr>
<tr class="memdesc:gafa7e230d030b4efcf9f48f720cc9eb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#gafa7e230d030b4efcf9f48f720cc9eb0f">More...</a><br/></td></tr>
<tr class="separator:gafa7e230d030b4efcf9f48f720cc9eb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2157a96ec2fc274e8cc152db209803db"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga2157a96ec2fc274e8cc152db209803db"><td class="memTemplItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga2157a96ec2fc274e8cc152db209803db">simdpp::move_l</a> (float64x4 a)</td></tr>
<tr class="memdesc:ga2157a96ec2fc274e8cc152db209803db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#ga2157a96ec2fc274e8cc152db209803db">More...</a><br/></td></tr>
<tr class="separator:ga2157a96ec2fc274e8cc152db209803db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6231a4e695e5f0631b30597850a1db8"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gaf6231a4e695e5f0631b30597850a1db8"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaf6231a4e695e5f0631b30597850a1db8">simdpp::move_r</a> (basic_int8x16 a)</td></tr>
<tr class="memdesc:gaf6231a4e695e5f0631b30597850a1db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 8-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#gaf6231a4e695e5f0631b30597850a1db8">More...</a><br/></td></tr>
<tr class="separator:gaf6231a4e695e5f0631b30597850a1db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82564dafdc4ac0ea12383e7eed171f98"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga82564dafdc4ac0ea12383e7eed171f98"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga82564dafdc4ac0ea12383e7eed171f98">simdpp::move_r</a> (basic_int8x32 a)</td></tr>
<tr class="memdesc:ga82564dafdc4ac0ea12383e7eed171f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 8-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#ga82564dafdc4ac0ea12383e7eed171f98">More...</a><br/></td></tr>
<tr class="separator:ga82564dafdc4ac0ea12383e7eed171f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff88d8bfb30fad1b46fb48b84fc6ba9"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gafff88d8bfb30fad1b46fb48b84fc6ba9"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gafff88d8bfb30fad1b46fb48b84fc6ba9">simdpp::move_r</a> (basic_int16x8 a)</td></tr>
<tr class="memdesc:gafff88d8bfb30fad1b46fb48b84fc6ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 16-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#gafff88d8bfb30fad1b46fb48b84fc6ba9">More...</a><br/></td></tr>
<tr class="separator:gafff88d8bfb30fad1b46fb48b84fc6ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cdc362fdf99272d2573d9c550702c04"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga5cdc362fdf99272d2573d9c550702c04"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga5cdc362fdf99272d2573d9c550702c04">simdpp::move_r</a> (basic_int16x16 a)</td></tr>
<tr class="memdesc:ga5cdc362fdf99272d2573d9c550702c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 16-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#ga5cdc362fdf99272d2573d9c550702c04">More...</a><br/></td></tr>
<tr class="separator:ga5cdc362fdf99272d2573d9c550702c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e334a718f54a2dbd7809e4216ed394"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga58e334a718f54a2dbd7809e4216ed394"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga58e334a718f54a2dbd7809e4216ed394">simdpp::move_r</a> (basic_int32x4 a)</td></tr>
<tr class="memdesc:ga58e334a718f54a2dbd7809e4216ed394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#ga58e334a718f54a2dbd7809e4216ed394">More...</a><br/></td></tr>
<tr class="separator:ga58e334a718f54a2dbd7809e4216ed394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c42e10ab20fe1d1ec8197cf029ed60"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga26c42e10ab20fe1d1ec8197cf029ed60"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga26c42e10ab20fe1d1ec8197cf029ed60">simdpp::move_r</a> (basic_int32x8 a)</td></tr>
<tr class="memdesc:ga26c42e10ab20fe1d1ec8197cf029ed60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#ga26c42e10ab20fe1d1ec8197cf029ed60">More...</a><br/></td></tr>
<tr class="separator:ga26c42e10ab20fe1d1ec8197cf029ed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c5a9e672c18dc6e36787e2576c9706"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gae2c5a9e672c18dc6e36787e2576c9706"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gae2c5a9e672c18dc6e36787e2576c9706">simdpp::move_r</a> (basic_int64x2 a)</td></tr>
<tr class="memdesc:gae2c5a9e672c18dc6e36787e2576c9706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#gae2c5a9e672c18dc6e36787e2576c9706">More...</a><br/></td></tr>
<tr class="separator:gae2c5a9e672c18dc6e36787e2576c9706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b6edaae0cbb730ed668abf9dda8cf8"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gae8b6edaae0cbb730ed668abf9dda8cf8"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gae8b6edaae0cbb730ed668abf9dda8cf8">simdpp::move_r</a> (basic_int64x4 a)</td></tr>
<tr class="memdesc:gae8b6edaae0cbb730ed668abf9dda8cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#gae8b6edaae0cbb730ed668abf9dda8cf8">More...</a><br/></td></tr>
<tr class="separator:gae8b6edaae0cbb730ed668abf9dda8cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ec8f6fea98810961b203daa7d77b253"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga0ec8f6fea98810961b203daa7d77b253"><td class="memTemplItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga0ec8f6fea98810961b203daa7d77b253">simdpp::move_r</a> (float32x4 a)</td></tr>
<tr class="memdesc:ga0ec8f6fea98810961b203daa7d77b253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#ga0ec8f6fea98810961b203daa7d77b253">More...</a><br/></td></tr>
<tr class="separator:ga0ec8f6fea98810961b203daa7d77b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf620f9a38221cbab1fefd86770507b7"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gaaf620f9a38221cbab1fefd86770507b7"><td class="memTemplItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaaf620f9a38221cbab1fefd86770507b7">simdpp::move_r</a> (float32x8 a)</td></tr>
<tr class="memdesc:gaaf620f9a38221cbab1fefd86770507b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#gaaf620f9a38221cbab1fefd86770507b7">More...</a><br/></td></tr>
<tr class="separator:gaaf620f9a38221cbab1fefd86770507b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bddcd2bea1fb1745d754cb9865826d9"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga6bddcd2bea1fb1745d754cb9865826d9"><td class="memTemplItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga6bddcd2bea1fb1745d754cb9865826d9">simdpp::move_r</a> (float64x2 a)</td></tr>
<tr class="memdesc:ga6bddcd2bea1fb1745d754cb9865826d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#ga6bddcd2bea1fb1745d754cb9865826d9">More...</a><br/></td></tr>
<tr class="separator:ga6bddcd2bea1fb1745d754cb9865826d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf808d819219c237cfc60ceb483ddc5"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gaeaf808d819219c237cfc60ceb483ddc5"><td class="memTemplItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaeaf808d819219c237cfc60ceb483ddc5">simdpp::move_r</a> (float64x4 a)</td></tr>
<tr class="memdesc:gaeaf808d819219c237cfc60ceb483ddc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#gaeaf808d819219c237cfc60ceb483ddc5">More...</a><br/></td></tr>
<tr class="separator:gaeaf808d819219c237cfc60ceb483ddc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac159d566b6e11d7548579903f8f2e41a"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:gac159d566b6e11d7548579903f8f2e41a"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gac159d566b6e11d7548579903f8f2e41a">simdpp::broadcast</a> (basic_int8x16 a)</td></tr>
<tr class="memdesc:gac159d566b6e11d7548579903f8f2e41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 8-bit value to all elements.  <a href="#gac159d566b6e11d7548579903f8f2e41a">More...</a><br/></td></tr>
<tr class="separator:gac159d566b6e11d7548579903f8f2e41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e7038ecfb4db46c7d9ef647a20f43c"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:gaf5e7038ecfb4db46c7d9ef647a20f43c"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaf5e7038ecfb4db46c7d9ef647a20f43c">simdpp::broadcast</a> (basic_int8x32 a)</td></tr>
<tr class="memdesc:gaf5e7038ecfb4db46c7d9ef647a20f43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 8-bit value to all elements.  <a href="#gaf5e7038ecfb4db46c7d9ef647a20f43c">More...</a><br/></td></tr>
<tr class="separator:gaf5e7038ecfb4db46c7d9ef647a20f43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38073dbf9b5e18495c33bcf6c95047e1"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:ga38073dbf9b5e18495c33bcf6c95047e1"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga38073dbf9b5e18495c33bcf6c95047e1">simdpp::broadcast</a> (basic_int16x8 a)</td></tr>
<tr class="memdesc:ga38073dbf9b5e18495c33bcf6c95047e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 16-bit value to all elements within a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector.  <a href="#ga38073dbf9b5e18495c33bcf6c95047e1">More...</a><br/></td></tr>
<tr class="separator:ga38073dbf9b5e18495c33bcf6c95047e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3520e0c81a6f7473a41104c3483776b"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:gae3520e0c81a6f7473a41104c3483776b"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gae3520e0c81a6f7473a41104c3483776b">simdpp::broadcast</a> (basic_int16x16 a)</td></tr>
<tr class="memdesc:gae3520e0c81a6f7473a41104c3483776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 16-bit value to all elements within a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector.  <a href="#gae3520e0c81a6f7473a41104c3483776b">More...</a><br/></td></tr>
<tr class="separator:gae3520e0c81a6f7473a41104c3483776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga655a9cd34998198dbbd6ce8562adb528"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:ga655a9cd34998198dbbd6ce8562adb528"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga655a9cd34998198dbbd6ce8562adb528">simdpp::broadcast</a> (basic_int32x4 a)</td></tr>
<tr class="memdesc:ga655a9cd34998198dbbd6ce8562adb528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector.  <a href="#ga655a9cd34998198dbbd6ce8562adb528">More...</a><br/></td></tr>
<tr class="separator:ga655a9cd34998198dbbd6ce8562adb528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ddb9baaf8666da71d97e8db4aba246b"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:ga0ddb9baaf8666da71d97e8db4aba246b"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga0ddb9baaf8666da71d97e8db4aba246b">simdpp::broadcast</a> (basic_int32x8 a)</td></tr>
<tr class="memdesc:ga0ddb9baaf8666da71d97e8db4aba246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector.  <a href="#ga0ddb9baaf8666da71d97e8db4aba246b">More...</a><br/></td></tr>
<tr class="separator:ga0ddb9baaf8666da71d97e8db4aba246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674202293bf84a14547b525e1aabf055"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:ga674202293bf84a14547b525e1aabf055"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga674202293bf84a14547b525e1aabf055">simdpp::broadcast</a> (basic_int64x2 a)</td></tr>
<tr class="memdesc:ga674202293bf84a14547b525e1aabf055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector.  <a href="#ga674202293bf84a14547b525e1aabf055">More...</a><br/></td></tr>
<tr class="separator:ga674202293bf84a14547b525e1aabf055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab711ec88859d8b81d1481c36e873ccd"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:gaab711ec88859d8b81d1481c36e873ccd"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaab711ec88859d8b81d1481c36e873ccd">simdpp::broadcast</a> (basic_int64x4 a)</td></tr>
<tr class="memdesc:gaab711ec88859d8b81d1481c36e873ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector.  <a href="#gaab711ec88859d8b81d1481c36e873ccd">More...</a><br/></td></tr>
<tr class="separator:gaab711ec88859d8b81d1481c36e873ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c22f737d225ee2c4867acdbeceb52e8"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:ga8c22f737d225ee2c4867acdbeceb52e8"><td class="memTemplItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga8c22f737d225ee2c4867acdbeceb52e8">simdpp::broadcast</a> (float32x4 a)</td></tr>
<tr class="memdesc:ga8c22f737d225ee2c4867acdbeceb52e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector.  <a href="#ga8c22f737d225ee2c4867acdbeceb52e8">More...</a><br/></td></tr>
<tr class="separator:ga8c22f737d225ee2c4867acdbeceb52e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50227bf98a9256c7d233cadaa46814b7"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:ga50227bf98a9256c7d233cadaa46814b7"><td class="memTemplItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga50227bf98a9256c7d233cadaa46814b7">simdpp::broadcast</a> (float32x8 a)</td></tr>
<tr class="memdesc:ga50227bf98a9256c7d233cadaa46814b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector.  <a href="#ga50227bf98a9256c7d233cadaa46814b7">More...</a><br/></td></tr>
<tr class="separator:ga50227bf98a9256c7d233cadaa46814b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cbd716174a33be9b23b9bb0571176f"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:gae8cbd716174a33be9b23b9bb0571176f"><td class="memTemplItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gae8cbd716174a33be9b23b9bb0571176f">simdpp::broadcast</a> (float64x2 a)</td></tr>
<tr class="memdesc:gae8cbd716174a33be9b23b9bb0571176f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00012.html">float64x2</a> vector.  <a href="#gae8cbd716174a33be9b23b9bb0571176f">More...</a><br/></td></tr>
<tr class="separator:gae8cbd716174a33be9b23b9bb0571176f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee2d08cdb64f26666530fe646c072d4"><td class="memTemplParams" colspan="2">template&lt;unsigned s&gt; </td></tr>
<tr class="memitem:ga4ee2d08cdb64f26666530fe646c072d4"><td class="memTemplItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga4ee2d08cdb64f26666530fe646c072d4">simdpp::broadcast</a> (float64x4 a)</td></tr>
<tr class="memdesc:ga4ee2d08cdb64f26666530fe646c072d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00012.html">float64x2</a> vector.  <a href="#ga4ee2d08cdb64f26666530fe646c072d4">More...</a><br/></td></tr>
<tr class="separator:ga4ee2d08cdb64f26666530fe646c072d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11e97c96666d23b392e5e2003ec96db"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gaa11e97c96666d23b392e5e2003ec96db"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaa11e97c96666d23b392e5e2003ec96db">simdpp::align</a> (basic_int8x16 lower, basic_int8x16 upper)</td></tr>
<tr class="memdesc:gaa11e97c96666d23b392e5e2003ec96db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector from two concatenated <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors.  <a href="#gaa11e97c96666d23b392e5e2003ec96db">More...</a><br/></td></tr>
<tr class="separator:gaa11e97c96666d23b392e5e2003ec96db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeeb2ac1fc05f359072916798309052b"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gafeeb2ac1fc05f359072916798309052b"><td class="memTemplItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gafeeb2ac1fc05f359072916798309052b">simdpp::align</a> (basic_int8x32 lower, basic_int8x32 upper)</td></tr>
<tr class="memdesc:gafeeb2ac1fc05f359072916798309052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector from two concatenated <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors.  <a href="#gafeeb2ac1fc05f359072916798309052b">More...</a><br/></td></tr>
<tr class="separator:gafeeb2ac1fc05f359072916798309052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa893e752172c778446ff192992ec4f10"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gaa893e752172c778446ff192992ec4f10"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaa893e752172c778446ff192992ec4f10">simdpp::align</a> (basic_int16x8 lower, basic_int16x8 upper)</td></tr>
<tr class="memdesc:gaa893e752172c778446ff192992ec4f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector from two concatenated <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors.  <a href="#gaa893e752172c778446ff192992ec4f10">More...</a><br/></td></tr>
<tr class="separator:gaa893e752172c778446ff192992ec4f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0009cc8f52038af9b42091047e2a93c8"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga0009cc8f52038af9b42091047e2a93c8"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga0009cc8f52038af9b42091047e2a93c8">simdpp::align</a> (basic_int16x16 lower, basic_int16x16 upper)</td></tr>
<tr class="memdesc:ga0009cc8f52038af9b42091047e2a93c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector from two concatenated <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors.  <a href="#ga0009cc8f52038af9b42091047e2a93c8">More...</a><br/></td></tr>
<tr class="separator:ga0009cc8f52038af9b42091047e2a93c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55a53714b754b653139c749be77ced9"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gab55a53714b754b653139c749be77ced9"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gab55a53714b754b653139c749be77ced9">simdpp::align</a> (basic_int32x4 lower, basic_int32x4 upper)</td></tr>
<tr class="memdesc:gab55a53714b754b653139c749be77ced9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector from two concatenated <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors.  <a href="#gab55a53714b754b653139c749be77ced9">More...</a><br/></td></tr>
<tr class="separator:gab55a53714b754b653139c749be77ced9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf001e435076c56bcc61a693ac2e8cca"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gadf001e435076c56bcc61a693ac2e8cca"><td class="memTemplItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gadf001e435076c56bcc61a693ac2e8cca">simdpp::align</a> (basic_int32x8 lower, basic_int32x8 upper)</td></tr>
<tr class="memdesc:gadf001e435076c56bcc61a693ac2e8cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector from two concatenated <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors.  <a href="#gadf001e435076c56bcc61a693ac2e8cca">More...</a><br/></td></tr>
<tr class="separator:gadf001e435076c56bcc61a693ac2e8cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbdc44acbe15aae301f10289fbd5e80"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gaecbdc44acbe15aae301f10289fbd5e80"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gaecbdc44acbe15aae301f10289fbd5e80">simdpp::align</a> (basic_int64x2 lower, basic_int64x2 upper)</td></tr>
<tr class="memdesc:gaecbdc44acbe15aae301f10289fbd5e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector from two concatenated <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors.  <a href="#gaecbdc44acbe15aae301f10289fbd5e80">More...</a><br/></td></tr>
<tr class="separator:gaecbdc44acbe15aae301f10289fbd5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191f71c87c586350e6c6e1e729ef64a5"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga191f71c87c586350e6c6e1e729ef64a5"><td class="memTemplItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga191f71c87c586350e6c6e1e729ef64a5">simdpp::align</a> (basic_int64x4 lower, basic_int64x4 upper)</td></tr>
<tr class="memdesc:ga191f71c87c586350e6c6e1e729ef64a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector from two concatenated <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors.  <a href="#ga191f71c87c586350e6c6e1e729ef64a5">More...</a><br/></td></tr>
<tr class="separator:ga191f71c87c586350e6c6e1e729ef64a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87555dff938aafce8da3091b263676b3"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga87555dff938aafce8da3091b263676b3"><td class="memTemplItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga87555dff938aafce8da3091b263676b3">simdpp::align</a> (float32x4 lower, float32x4 upper)</td></tr>
<tr class="memdesc:ga87555dff938aafce8da3091b263676b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector from two concatenated <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors.  <a href="#ga87555dff938aafce8da3091b263676b3">More...</a><br/></td></tr>
<tr class="separator:ga87555dff938aafce8da3091b263676b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2ce857ff2bc9027046ba18aff3c12ff"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gac2ce857ff2bc9027046ba18aff3c12ff"><td class="memTemplItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gac2ce857ff2bc9027046ba18aff3c12ff">simdpp::align</a> (float32x8 lower, float32x8 upper)</td></tr>
<tr class="memdesc:gac2ce857ff2bc9027046ba18aff3c12ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector from two concatenated <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors.  <a href="#gac2ce857ff2bc9027046ba18aff3c12ff">More...</a><br/></td></tr>
<tr class="separator:gac2ce857ff2bc9027046ba18aff3c12ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b2b666d3bbc2c0f41194e1ea1c0eca"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:ga48b2b666d3bbc2c0f41194e1ea1c0eca"><td class="memTemplItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga48b2b666d3bbc2c0f41194e1ea1c0eca">simdpp::align</a> (float64x2 lower, float64x2 upper)</td></tr>
<tr class="memdesc:ga48b2b666d3bbc2c0f41194e1ea1c0eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00012.html">float64x2</a> vector from two concatenated <a class="el" href="a00012.html">float64x2</a> vectors.  <a href="#ga48b2b666d3bbc2c0f41194e1ea1c0eca">More...</a><br/></td></tr>
<tr class="separator:ga48b2b666d3bbc2c0f41194e1ea1c0eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacdde5f01de641587438aff8feb662c"><td class="memTemplParams" colspan="2">template&lt;unsigned shift&gt; </td></tr>
<tr class="memitem:gadacdde5f01de641587438aff8feb662c"><td class="memTemplItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gadacdde5f01de641587438aff8feb662c">simdpp::align</a> (float64x4 lower, float64x4 upper)</td></tr>
<tr class="memdesc:gadacdde5f01de641587438aff8feb662c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a <a class="el" href="a00012.html">float64x2</a> vector from two concatenated <a class="el" href="a00012.html">float64x2</a> vectors.  <a href="#gadacdde5f01de641587438aff8feb662c">More...</a><br/></td></tr>
<tr class="separator:gadacdde5f01de641587438aff8feb662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bab6c7487b2cf6ee9cd28793c33621d"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga6bab6c7487b2cf6ee9cd28793c33621d">simdpp::blend</a> (basic_int8x16 on, basic_int8x16 off, basic_int8x16 mask)</td></tr>
<tr class="memdesc:ga6bab6c7487b2cf6ee9cd28793c33621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga6bab6c7487b2cf6ee9cd28793c33621d">More...</a><br/></td></tr>
<tr class="separator:ga6bab6c7487b2cf6ee9cd28793c33621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed977a048d17dab3823c43e015df063d"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaed977a048d17dab3823c43e015df063d">simdpp::blend</a> (basic_int8x32 on, basic_int8x32 off, basic_int8x32 mask)</td></tr>
<tr class="memdesc:gaed977a048d17dab3823c43e015df063d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#gaed977a048d17dab3823c43e015df063d">More...</a><br/></td></tr>
<tr class="separator:gaed977a048d17dab3823c43e015df063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7834d8e45937d3a656b9ab79c75dbd"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga9d7834d8e45937d3a656b9ab79c75dbd">simdpp::blend</a> (basic_int16x8 on, basic_int16x8 off, basic_int16x8 mask)</td></tr>
<tr class="memdesc:ga9d7834d8e45937d3a656b9ab79c75dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes vector from two sources according to a mask.  <a href="#ga9d7834d8e45937d3a656b9ab79c75dbd">More...</a><br/></td></tr>
<tr class="separator:ga9d7834d8e45937d3a656b9ab79c75dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42fcb4adaa91e74b731e29de14bed412"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga42fcb4adaa91e74b731e29de14bed412">simdpp::blend</a> (basic_int16x16 on, basic_int16x16 off, basic_int16x16 mask)</td></tr>
<tr class="memdesc:ga42fcb4adaa91e74b731e29de14bed412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes vector from two sources according to a mask.  <a href="#ga42fcb4adaa91e74b731e29de14bed412">More...</a><br/></td></tr>
<tr class="separator:ga42fcb4adaa91e74b731e29de14bed412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8101d8873ecfebb209243166f02636f9"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga8101d8873ecfebb209243166f02636f9">simdpp::blend</a> (basic_int32x4 on, basic_int32x4 off, basic_int32x4 mask)</td></tr>
<tr class="memdesc:ga8101d8873ecfebb209243166f02636f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga8101d8873ecfebb209243166f02636f9">More...</a><br/></td></tr>
<tr class="separator:ga8101d8873ecfebb209243166f02636f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e7d8fe51bb4f57338bc4417a1938fb"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga00e7d8fe51bb4f57338bc4417a1938fb">simdpp::blend</a> (basic_int32x8 on, basic_int32x8 off, basic_int32x8 mask)</td></tr>
<tr class="memdesc:ga00e7d8fe51bb4f57338bc4417a1938fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga00e7d8fe51bb4f57338bc4417a1938fb">More...</a><br/></td></tr>
<tr class="separator:ga00e7d8fe51bb4f57338bc4417a1938fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c097ddf4b9e6fdbcdedbd9eed893159"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga9c097ddf4b9e6fdbcdedbd9eed893159">simdpp::blend</a> (basic_int64x2 on, basic_int64x2 off, basic_int64x2 mask)</td></tr>
<tr class="memdesc:ga9c097ddf4b9e6fdbcdedbd9eed893159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga9c097ddf4b9e6fdbcdedbd9eed893159">More...</a><br/></td></tr>
<tr class="separator:ga9c097ddf4b9e6fdbcdedbd9eed893159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bb4d45e4748e1609ab22df13016c7c"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga53bb4d45e4748e1609ab22df13016c7c">simdpp::blend</a> (basic_int64x4 on, basic_int64x4 off, basic_int64x4 mask)</td></tr>
<tr class="memdesc:ga53bb4d45e4748e1609ab22df13016c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga53bb4d45e4748e1609ab22df13016c7c">More...</a><br/></td></tr>
<tr class="separator:ga53bb4d45e4748e1609ab22df13016c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ba41ff86a9d1d562c2eb3908b176ad"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaf4ba41ff86a9d1d562c2eb3908b176ad">simdpp::blend</a> (float32x4 on, float32x4 off, float32x4 mask)</td></tr>
<tr class="memdesc:gaf4ba41ff86a9d1d562c2eb3908b176ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#gaf4ba41ff86a9d1d562c2eb3908b176ad">More...</a><br/></td></tr>
<tr class="separator:gaf4ba41ff86a9d1d562c2eb3908b176ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e40aba385aa4cd9eae9e76eb0f90a51"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga2e40aba385aa4cd9eae9e76eb0f90a51">simdpp::blend</a> (float32x4 on, float32x4 off, int128 mask)</td></tr>
<tr class="memdesc:ga2e40aba385aa4cd9eae9e76eb0f90a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga2e40aba385aa4cd9eae9e76eb0f90a51">More...</a><br/></td></tr>
<tr class="separator:ga2e40aba385aa4cd9eae9e76eb0f90a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c1024cd86bef506e105af7ec0082f5"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab8c1024cd86bef506e105af7ec0082f5">simdpp::blend</a> (float32x8 on, float32x8 off, float32x8 mask)</td></tr>
<tr class="memdesc:gab8c1024cd86bef506e105af7ec0082f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#gab8c1024cd86bef506e105af7ec0082f5">More...</a><br/></td></tr>
<tr class="separator:gab8c1024cd86bef506e105af7ec0082f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad32f180fab3ca988cb4d926a227f48ea"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gad32f180fab3ca988cb4d926a227f48ea">simdpp::blend</a> (float32x8 on, float32x8 off, int256 mask)</td></tr>
<tr class="memdesc:gad32f180fab3ca988cb4d926a227f48ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#gad32f180fab3ca988cb4d926a227f48ea">More...</a><br/></td></tr>
<tr class="separator:gad32f180fab3ca988cb4d926a227f48ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a30eb6a29eb323a758a7a0618b1f95"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gae3a30eb6a29eb323a758a7a0618b1f95">simdpp::blend</a> (float64x2 on, float64x2 off, float64x2 mask)</td></tr>
<tr class="memdesc:gae3a30eb6a29eb323a758a7a0618b1f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#gae3a30eb6a29eb323a758a7a0618b1f95">More...</a><br/></td></tr>
<tr class="separator:gae3a30eb6a29eb323a758a7a0618b1f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ee12d48e6026bb5f1e0f8c4d768c6f"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga65ee12d48e6026bb5f1e0f8c4d768c6f">simdpp::blend</a> (float64x2 on, float64x2 off, int128 mask)</td></tr>
<tr class="memdesc:ga65ee12d48e6026bb5f1e0f8c4d768c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga65ee12d48e6026bb5f1e0f8c4d768c6f">More...</a><br/></td></tr>
<tr class="separator:ga65ee12d48e6026bb5f1e0f8c4d768c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e4ca5189e927bf0e99e0e3fff2c947"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga45e4ca5189e927bf0e99e0e3fff2c947">simdpp::blend</a> (float64x4 on, float64x4 off, float64x4 mask)</td></tr>
<tr class="memdesc:ga45e4ca5189e927bf0e99e0e3fff2c947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga45e4ca5189e927bf0e99e0e3fff2c947">More...</a><br/></td></tr>
<tr class="separator:ga45e4ca5189e927bf0e99e0e3fff2c947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3281cae6e221faaa66534b0cc0ff8d42"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga3281cae6e221faaa66534b0cc0ff8d42">simdpp::blend</a> (float64x4 on, float64x4 off, int256 mask)</td></tr>
<tr class="memdesc:ga3281cae6e221faaa66534b0cc0ff8d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#ga3281cae6e221faaa66534b0cc0ff8d42">More...</a><br/></td></tr>
<tr class="separator:ga3281cae6e221faaa66534b0cc0ff8d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779149f7266b4909070f61e405718498"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga779149f7266b4909070f61e405718498">simdpp::unzip_lo</a> (basic_int8x16 a, basic_int8x16 b)</td></tr>
<tr class="memdesc:ga779149f7266b4909070f61e405718498"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors.  <a href="#ga779149f7266b4909070f61e405718498">More...</a><br/></td></tr>
<tr class="separator:ga779149f7266b4909070f61e405718498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88cf3619fb96e5098c668112d9206623"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga88cf3619fb96e5098c668112d9206623">simdpp::unzip_lo</a> (basic_int8x32 a, basic_int8x32 b)</td></tr>
<tr class="memdesc:ga88cf3619fb96e5098c668112d9206623"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors.  <a href="#ga88cf3619fb96e5098c668112d9206623">More...</a><br/></td></tr>
<tr class="separator:ga88cf3619fb96e5098c668112d9206623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4839bfa148d3adc320e4d3ab9a5400e"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa4839bfa148d3adc320e4d3ab9a5400e">simdpp::unzip_lo</a> (basic_int16x8 a, basic_int16x8 b)</td></tr>
<tr class="memdesc:gaa4839bfa148d3adc320e4d3ab9a5400e"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors.  <a href="#gaa4839bfa148d3adc320e4d3ab9a5400e">More...</a><br/></td></tr>
<tr class="separator:gaa4839bfa148d3adc320e4d3ab9a5400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771f80fe67d730dfa4049fd59754b2b0"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga771f80fe67d730dfa4049fd59754b2b0">simdpp::unzip_lo</a> (basic_int16x16 a, basic_int16x16 b)</td></tr>
<tr class="memdesc:ga771f80fe67d730dfa4049fd59754b2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors.  <a href="#ga771f80fe67d730dfa4049fd59754b2b0">More...</a><br/></td></tr>
<tr class="separator:ga771f80fe67d730dfa4049fd59754b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7d47730074b30dca6af16c7dcb09a8"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaec7d47730074b30dca6af16c7dcb09a8">simdpp::unzip_lo</a> (basic_int32x4 a, basic_int32x4 b)</td></tr>
<tr class="memdesc:gaec7d47730074b30dca6af16c7dcb09a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors.  <a href="#gaec7d47730074b30dca6af16c7dcb09a8">More...</a><br/></td></tr>
<tr class="separator:gaec7d47730074b30dca6af16c7dcb09a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdf9f78cdebf59f616be2844c2ace56"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga6bdf9f78cdebf59f616be2844c2ace56">simdpp::unzip_lo</a> (basic_int32x8 a, basic_int32x8 b)</td></tr>
<tr class="memdesc:ga6bdf9f78cdebf59f616be2844c2ace56"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors.  <a href="#ga6bdf9f78cdebf59f616be2844c2ace56">More...</a><br/></td></tr>
<tr class="separator:ga6bdf9f78cdebf59f616be2844c2ace56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb6af6db9912430d831cb830f210caa"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga2bb6af6db9912430d831cb830f210caa">simdpp::unzip_lo</a> (basic_int64x2 a, basic_int64x2 b)</td></tr>
<tr class="memdesc:ga2bb6af6db9912430d831cb830f210caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors.  <a href="#ga2bb6af6db9912430d831cb830f210caa">More...</a><br/></td></tr>
<tr class="separator:ga2bb6af6db9912430d831cb830f210caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90cf9a94a89ef6ef60eaac781df28ccb"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga90cf9a94a89ef6ef60eaac781df28ccb">simdpp::unzip_lo</a> (basic_int64x4 a, basic_int64x4 b)</td></tr>
<tr class="memdesc:ga90cf9a94a89ef6ef60eaac781df28ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors.  <a href="#ga90cf9a94a89ef6ef60eaac781df28ccb">More...</a><br/></td></tr>
<tr class="separator:ga90cf9a94a89ef6ef60eaac781df28ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4956f59a712359d2b40a56ee700ff9a1"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga4956f59a712359d2b40a56ee700ff9a1">simdpp::unzip_lo</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:ga4956f59a712359d2b40a56ee700ff9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors.  <a href="#ga4956f59a712359d2b40a56ee700ff9a1">More...</a><br/></td></tr>
<tr class="separator:ga4956f59a712359d2b40a56ee700ff9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba35a84baccf72455c53f418e66a4ec"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gafba35a84baccf72455c53f418e66a4ec">simdpp::unzip_lo</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:gafba35a84baccf72455c53f418e66a4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors.  <a href="#gafba35a84baccf72455c53f418e66a4ec">More...</a><br/></td></tr>
<tr class="separator:gafba35a84baccf72455c53f418e66a4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf205a50b2da4cc95fca63bb2fa68be0"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gadf205a50b2da4cc95fca63bb2fa68be0">simdpp::unzip_lo</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:gadf205a50b2da4cc95fca63bb2fa68be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00012.html">float64x2</a> vectors.  <a href="#gadf205a50b2da4cc95fca63bb2fa68be0">More...</a><br/></td></tr>
<tr class="separator:gadf205a50b2da4cc95fca63bb2fa68be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5a4a38b62a32ba9a738c08a49ab03a"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga2b5a4a38b62a32ba9a738c08a49ab03a">simdpp::unzip_lo</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:ga2b5a4a38b62a32ba9a738c08a49ab03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two <a class="el" href="a00012.html">float64x2</a> vectors.  <a href="#ga2b5a4a38b62a32ba9a738c08a49ab03a">More...</a><br/></td></tr>
<tr class="separator:ga2b5a4a38b62a32ba9a738c08a49ab03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e406f0a6736ac6d8a83f5e8fb452fd"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga37e406f0a6736ac6d8a83f5e8fb452fd">simdpp::unzip_hi</a> (basic_int8x16 a, basic_int8x16 b)</td></tr>
<tr class="memdesc:ga37e406f0a6736ac6d8a83f5e8fb452fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors.  <a href="#ga37e406f0a6736ac6d8a83f5e8fb452fd">More...</a><br/></td></tr>
<tr class="separator:ga37e406f0a6736ac6d8a83f5e8fb452fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fd116ca26d0822ab7a40c60e392eb6"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab7fd116ca26d0822ab7a40c60e392eb6">simdpp::unzip_hi</a> (basic_int8x32 a, basic_int8x32 b)</td></tr>
<tr class="memdesc:gab7fd116ca26d0822ab7a40c60e392eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors.  <a href="#gab7fd116ca26d0822ab7a40c60e392eb6">More...</a><br/></td></tr>
<tr class="separator:gab7fd116ca26d0822ab7a40c60e392eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1668b25227651bd339944b38d7a1faed"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga1668b25227651bd339944b38d7a1faed">simdpp::unzip_hi</a> (basic_int16x8 a, basic_int16x8 b)</td></tr>
<tr class="memdesc:ga1668b25227651bd339944b38d7a1faed"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors.  <a href="#ga1668b25227651bd339944b38d7a1faed">More...</a><br/></td></tr>
<tr class="separator:ga1668b25227651bd339944b38d7a1faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6cccd443cb9f3686007646af333bf4"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaae6cccd443cb9f3686007646af333bf4">simdpp::unzip_hi</a> (basic_int16x16 a, basic_int16x16 b)</td></tr>
<tr class="memdesc:gaae6cccd443cb9f3686007646af333bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors.  <a href="#gaae6cccd443cb9f3686007646af333bf4">More...</a><br/></td></tr>
<tr class="separator:gaae6cccd443cb9f3686007646af333bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga870855fdd1f5b9fb21b9b59e7bd39705"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga870855fdd1f5b9fb21b9b59e7bd39705">simdpp::unzip_hi</a> (basic_int32x4 a, basic_int32x4 b)</td></tr>
<tr class="memdesc:ga870855fdd1f5b9fb21b9b59e7bd39705"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors.  <a href="#ga870855fdd1f5b9fb21b9b59e7bd39705">More...</a><br/></td></tr>
<tr class="separator:ga870855fdd1f5b9fb21b9b59e7bd39705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace28fd9f7a7da4ea1c2589bec72beac6"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gace28fd9f7a7da4ea1c2589bec72beac6">simdpp::unzip_hi</a> (basic_int32x8 a, basic_int32x8 b)</td></tr>
<tr class="memdesc:gace28fd9f7a7da4ea1c2589bec72beac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors.  <a href="#gace28fd9f7a7da4ea1c2589bec72beac6">More...</a><br/></td></tr>
<tr class="separator:gace28fd9f7a7da4ea1c2589bec72beac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcae5bf49d4c7954309da09388f4727a"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gadcae5bf49d4c7954309da09388f4727a">simdpp::unzip_hi</a> (basic_int64x2 a, basic_int64x2 b)</td></tr>
<tr class="memdesc:gadcae5bf49d4c7954309da09388f4727a"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors.  <a href="#gadcae5bf49d4c7954309da09388f4727a">More...</a><br/></td></tr>
<tr class="separator:gadcae5bf49d4c7954309da09388f4727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa582084a4b6f2537f5c0487fd0400999"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaa582084a4b6f2537f5c0487fd0400999">simdpp::unzip_hi</a> (basic_int64x4 a, basic_int64x4 b)</td></tr>
<tr class="memdesc:gaa582084a4b6f2537f5c0487fd0400999"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors.  <a href="#gaa582084a4b6f2537f5c0487fd0400999">More...</a><br/></td></tr>
<tr class="separator:gaa582084a4b6f2537f5c0487fd0400999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c06035072bbd024745ea7a4da141f4d"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga8c06035072bbd024745ea7a4da141f4d">simdpp::unzip_hi</a> (float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:ga8c06035072bbd024745ea7a4da141f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors.  <a href="#ga8c06035072bbd024745ea7a4da141f4d">More...</a><br/></td></tr>
<tr class="separator:ga8c06035072bbd024745ea7a4da141f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30df036901ddc190ffd6523e37c20c21"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga30df036901ddc190ffd6523e37c20c21">simdpp::unzip_hi</a> (float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:ga30df036901ddc190ffd6523e37c20c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors.  <a href="#ga30df036901ddc190ffd6523e37c20c21">More...</a><br/></td></tr>
<tr class="separator:ga30df036901ddc190ffd6523e37c20c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c538ed0e293dce74c6aa9ea54ca59a"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga27c538ed0e293dce74c6aa9ea54ca59a">simdpp::unzip_hi</a> (float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:ga27c538ed0e293dce74c6aa9ea54ca59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00012.html">float64x2</a> vectors.  <a href="#ga27c538ed0e293dce74c6aa9ea54ca59a">More...</a><br/></td></tr>
<tr class="separator:ga27c538ed0e293dce74c6aa9ea54ca59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac14d916fc0f87bcc158d69d4bd13873"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaac14d916fc0f87bcc158d69d4bd13873">simdpp::unzip_hi</a> (float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:gaac14d916fc0f87bcc158d69d4bd13873"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two <a class="el" href="a00012.html">float64x2</a> vectors.  <a href="#gaac14d916fc0f87bcc158d69d4bd13873">More...</a><br/></td></tr>
<tr class="separator:gaac14d916fc0f87bcc158d69d4bd13873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a069b3af02a1434e6b9275b89029ec9"><td class="memItemLeft" align="right" valign="top">int128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga6a069b3af02a1434e6b9275b89029ec9">simdpp::permute_bytes16</a> (int128 a, int128 mask)</td></tr>
<tr class="memdesc:ga6a069b3af02a1434e6b9275b89029ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#ga6a069b3af02a1434e6b9275b89029ec9">More...</a><br/></td></tr>
<tr class="separator:ga6a069b3af02a1434e6b9275b89029ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab576cebb34533ccb36cd7f7f084a5850"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gab576cebb34533ccb36cd7f7f084a5850">simdpp::permute_bytes16</a> (float32x4 a, int128 mask)</td></tr>
<tr class="memdesc:gab576cebb34533ccb36cd7f7f084a5850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#gab576cebb34533ccb36cd7f7f084a5850">More...</a><br/></td></tr>
<tr class="separator:gab576cebb34533ccb36cd7f7f084a5850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaaa73124337439afbfd129ee20ce223"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gaeaaa73124337439afbfd129ee20ce223">simdpp::permute_bytes16</a> (float64x2 a, int128 mask)</td></tr>
<tr class="memdesc:gaeaaa73124337439afbfd129ee20ce223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#gaeaaa73124337439afbfd129ee20ce223">More...</a><br/></td></tr>
<tr class="separator:gaeaaa73124337439afbfd129ee20ce223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ec95ddc21caf8e8274b1778bc5ef08"><td class="memItemLeft" align="right" valign="top">int256&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gac1ec95ddc21caf8e8274b1778bc5ef08">simdpp::permute_bytes16</a> (int256 a, int256 mask)</td></tr>
<tr class="memdesc:gac1ec95ddc21caf8e8274b1778bc5ef08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#gac1ec95ddc21caf8e8274b1778bc5ef08">More...</a><br/></td></tr>
<tr class="separator:gac1ec95ddc21caf8e8274b1778bc5ef08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad063e853a0ec6e0c9f750f839e485373"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#gad063e853a0ec6e0c9f750f839e485373">simdpp::permute_bytes16</a> (float32x8 a, int256 mask)</td></tr>
<tr class="memdesc:gad063e853a0ec6e0c9f750f839e485373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#gad063e853a0ec6e0c9f750f839e485373">More...</a><br/></td></tr>
<tr class="separator:gad063e853a0ec6e0c9f750f839e485373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712121541c0a822b56216721fc5aa2da"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ga712121541c0a822b56216721fc5aa2da">simdpp::permute_bytes16</a> (float64x4 a, int256 mask)</td></tr>
<tr class="memdesc:ga712121541c0a822b56216721fc5aa2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#ga712121541c0a822b56216721fc5aa2da">More...</a><br/></td></tr>
<tr class="separator:ga712121541c0a822b56216721fc5aa2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12532b16a59e6bdcd3a7e7c51aa107fe"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3&gt; </td></tr>
<tr class="memitem:ga12532b16a59e6bdcd3a7e7c51aa107fe"><td class="memTemplItemLeft" align="right" valign="top">int128&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#ga12532b16a59e6bdcd3a7e7c51aa107fe">simdpp::permute</a> (basic_int16x8 a)</td></tr>
<tr class="memdesc:ga12532b16a59e6bdcd3a7e7c51aa107fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the 16-bit values within each 4 consecutive values of the vector.  <a href="#ga12532b16a59e6bdcd3a7e7c51aa107fe">More...</a><br/></td></tr>
<tr class="separator:ga12532b16a59e6bdcd3a7e7c51aa107fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad137839c20c24e5d474ad89e39a651a9"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3&gt; </td></tr>
<tr class="memitem:gad137839c20c24e5d474ad89e39a651a9"><td class="memTemplItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gad137839c20c24e5d474ad89e39a651a9">simdpp::permute</a> (basic_int16x16 a)</td></tr>
<tr class="memdesc:gad137839c20c24e5d474ad89e39a651a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the 16-bit values within each 4 consecutive values of the vector.  <a href="#gad137839c20c24e5d474ad89e39a651a9">More...</a><br/></td></tr>
<tr class="separator:gad137839c20c24e5d474ad89e39a651a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa11e97c96666d23b392e5e2003ec96db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector from two concatenated <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ l0  l1   .  l14 l15 ]</div>
<div class="line"> 1      r = [ l1  l2   .  l15 u0  ]</div>
<div class="line"> 2      r = [ l2  l3   .  u0  l1  ]</div>
<div class="line">  ...    ..   .. ..  ... .. ..</div>
<div class="line"> 14     r = [ l15 u0   .  u13 u14 ]</div>
<div class="line"> 15     r = [ u0  u1   .  u14 u15 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gafeeb2ac1fc05f359072916798309052b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector from two concatenated <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ l0  l1   .  l14 l15 ]</div>
<div class="line"> 1      r = [ l1  l2   .  l15 u0  ]</div>
<div class="line"> 2      r = [ l2  l3   .  u0  l1  ]</div>
<div class="line">  ...    ..   .. ..  ... .. ..</div>
<div class="line"> 14     r = [ l15 u0   .  u13 u14 ]</div>
<div class="line"> 15     r = [ u0  u1   .  u14 u15 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa893e752172c778446ff192992ec4f10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector from two concatenated <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1    .  6  7  |</div>
<div class="line"> 0      r = [ l0 l1   .  l6 l7 ]</div>
<div class="line"> 1      r = [ l1 l2   .  l7 u0 ]</div>
<div class="line"> 2      r = [ l2 l3   .  u0 l1 ]</div>
<div class="line">  ...    ..   .. ..  ... .. ..</div>
<div class="line"> 6      r = [ l3 u0   .  u5 u6 ]</div>
<div class="line"> 7      r = [ u0 u1   .  u6 u7 ]</div>
</div><!-- fragment --> <ul>
<li>In SSE2 and SSE3 this intrinsic results in at least 3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga0009cc8f52038af9b42091047e2a93c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector from two concatenated <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1    .  6  7  |</div>
<div class="line"> 0      r = [ l0 l1   .  l6 l7 ]</div>
<div class="line"> 1      r = [ l1 l2   .  l7 u0 ]</div>
<div class="line"> 2      r = [ l2 l3   .  u0 l1 ]</div>
<div class="line">  ...    ..   .. ..  ... .. ..</div>
<div class="line"> 6      r = [ l3 u0   .  u5 u6 ]</div>
<div class="line"> 7      r = [ u0 u1   .  u6 u7 ]</div>
</div><!-- fragment --> <ul>
<li>In SSE2 and SSE3 this intrinsic results in at least 3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="gab55a53714b754b653139c749be77ced9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector from two concatenated <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ l0 l1 l2 l3 ]</div>
<div class="line"> 1      r = [ l1 l2 l3 u0 ]</div>
<div class="line"> 2      r = [ l2 l3 u0 u1 ]</div>
<div class="line"> 3      r = [ l3 u0 u1 u2 ]</div>
<div class="line"> 4      r = [ u0 u1 u2 u3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf001e435076c56bcc61a693ac2e8cca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector from two concatenated <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ l0 l1 l2 l3 ]</div>
<div class="line"> 1      r = [ l1 l2 l3 u0 ]</div>
<div class="line"> 2      r = [ l2 l3 u0 u1 ]</div>
<div class="line"> 3      r = [ l3 u0 u1 u2 ]</div>
<div class="line"> 4      r = [ u0 u1 u2 u3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaecbdc44acbe15aae301f10289fbd5e80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector from two concatenated <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ l0 l1 ]</div>
<div class="line"> 1      r = [ l1 u0 ]</div>
<div class="line"> 2      r = [ u0 u1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga191f71c87c586350e6c6e1e729ef64a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector from two concatenated <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ l0 l1 ]</div>
<div class="line"> 1      r = [ l1 u0 ]</div>
<div class="line"> 2      r = [ u0 u1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga87555dff938aafce8da3091b263676b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector from two concatenated <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ l0 l1 l2 l3 ]</div>
<div class="line"> 1      r = [ l1 l2 l3 u0 ]</div>
<div class="line"> 2      r = [ l2 l3 u0 u1 ]</div>
<div class="line"> 3      r = [ l3 u0 u1 u2 ]</div>
<div class="line"> 4      r = [ u0 u1 u2 u3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2ce857ff2bc9027046ba18aff3c12ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector from two concatenated <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ l0 l1 l2 l3 ]</div>
<div class="line"> 1      r = [ l1 l2 l3 u0 ]</div>
<div class="line"> 2      r = [ l2 l3 u0 u1 ]</div>
<div class="line"> 3      r = [ l3 u0 u1 u2 ]</div>
<div class="line"> 4      r = [ u0 u1 u2 u3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48b2b666d3bbc2c0f41194e1ea1c0eca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00012.html">float64x2</a> vector from two concatenated <a class="el" href="a00012.html">float64x2</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ l0 l1 ]</div>
<div class="line"> 1      r = [ l1 u0 ]</div>
<div class="line"> 2      r = [ u0 u1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gadacdde5f01de641587438aff8feb662c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::align </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a <a class="el" href="a00012.html">float64x2</a> vector from two concatenated <a class="el" href="a00012.html">float64x2</a> vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ l0 l1 ]</div>
<div class="line"> 1      r = [ l1 u0 ]</div>
<div class="line"> 2      r = [ u0 u1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bab6c7487b2cf6ee9cd28793c33621d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaed977a048d17dab3823c43e015df063d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9d7834d8e45937d3a656b9ab79c75dbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga42fcb4adaa91e74b731e29de14bed412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8101d8873ecfebb209243166f02636f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga00e7d8fe51bb4f57338bc4417a1938fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9c097ddf4b9e6fdbcdedbd9eed893159"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga53bb4d45e4748e1609ab22df13016c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf4ba41ff86a9d1d562c2eb3908b176ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2e40aba385aa4cd9eae9e76eb0f90a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab8c1024cd86bef506e105af7ec0082f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad32f180fab3ca988cb4d926a227f48ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae3a30eb6a29eb323a758a7a0618b1f95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffffffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffffffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga65ee12d48e6026bb5f1e0f8c4d768c6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffffffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffffffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga45e4ca5189e927bf0e99e0e3fff2c947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffffffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffffffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3281cae6e221faaa66534b0cc0ff8d42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xffffffffffffffff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xffffffffffffffff ) ? onN : offN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>In NEON and SSE-AVX2 this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac159d566b6e11d7548579903f8f2e41a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 8-bit value to all elements. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">rN = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 5 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf5e7038ecfb4db46c7d9ef647a20f43c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 8-bit value to all elements. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">rN = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 5 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga38073dbf9b5e18495c33bcf6c95047e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 16-bit value to all elements within a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">r7 = a[s]</div>
</div><!-- fragment --> <ul>
<li>In SSE2, SSE3, SSSE3 and SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae3520e0c81a6f7473a41104c3483776b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 16-bit value to all elements within a <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">r7 = a[s]</div>
</div><!-- fragment --> <ul>
<li>In SSE2, SSE3, SSSE3 and SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga655a9cd34998198dbbd6ce8562adb528"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">r2 = a[s]</div>
<div class="line">r3 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0ddb9baaf8666da71d97e8db4aba246b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">r2 = a[s]</div>
<div class="line">r3 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga674202293bf84a14547b525e1aabf055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaab711ec88859d8b81d1481c36e873ccd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga8c22f737d225ee2c4867acdbeceb52e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">r2 = a[s]</div>
<div class="line">r3 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga50227bf98a9256c7d233cadaa46814b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 32-bit value to all elements within a <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">r2 = a[s]</div>
<div class="line">r3 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae8cbd716174a33be9b23b9bb0571176f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00012.html">float64x2</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4ee2d08cdb64f26666530fe646c072d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::broadcast </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 64-bit value to all elements within a <a class="el" href="a00012.html">float64x2</a> vector. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae61c49e9957279af09350d27a092b120"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16 &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of two adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,1] select elements from the first vector. Values [2,3] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0] : b[s0])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1] : b[s1])</div>
<div class="line">r2 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+2] : b[s0+2])</div>
<div class="line">r3 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+2] : b[s1+2])</div>
<div class="line">...</div>
<div class="line">r14 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+14] : b[s0+14])</div>
<div class="line">r15 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+14] : b[s1+14])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="ga694d9d0eb46030a8dbb248c81be18463"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32 &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of two adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,1] select elements from the first vector. Values [2,3] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0] : b[s0])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1] : b[s1])</div>
<div class="line">r2 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+2] : b[s0+2])</div>
<div class="line">r3 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+2] : b[s1+2])</div>
<div class="line">...</div>
<div class="line">r14 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+14] : b[s0+14])</div>
<div class="line">r15 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+14] : b[s1+14])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="gabf5c4df0231fb6d26e6fcbaaababaf9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the elements in an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ a0  a1   .  a14 a15 ]</div>
<div class="line"> 1      r = [ a1  a2   .  a15  0  ]</div>
<div class="line"> 2      r = [ a2  a3   .   0   0  ]</div>
<div class="line">  ...    ..   .. ..   ...  ..  .. ..</div>
<div class="line"> 14     r = [ a15  0   .   0   0  ]</div>
<div class="line"> 15     r = [  0   0   .   0   0  ]</div>
<div class="line"> 16     r = [  0   0   .   0   0  ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd0d078e6f64f7b229c487f9ab6ce0f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the elements in an <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ a0  a1   .  a14 a15 ]</div>
<div class="line"> 1      r = [ a1  a2   .  a15  0  ]</div>
<div class="line"> 2      r = [ a2  a3   .   0   0  ]</div>
<div class="line">  ...    ..   .. ..   ...  ..  .. ..</div>
<div class="line"> 14     r = [ a15  0   .   0   0  ]</div>
<div class="line"> 15     r = [  0   0   .   0   0  ]</div>
<div class="line"> 16     r = [  0   0   .   0   0  ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga091f48b58c4359cd0eaa868ab9f8c658"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 16-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1   . 6  7  |</div>
<div class="line"> 0      r = [ a0 a1  . a6 a7 ]</div>
<div class="line"> 1      r = [ a1 a2  . a7  0 ]</div>
<div class="line"> 2      r = [ a2 a3  .  0  0 ]</div>
<div class="line">  ...    ..   .. .. ... .. ..</div>
<div class="line"> 6      r = [ a6 a7  .  0  0 ]</div>
<div class="line"> 7      r = [ a7  0  .  0  0 ]</div>
<div class="line"> 8      r = [  0  0  .  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga69c4af646de8c0d78e308a0a7d860438"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 16-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1   . 6  7  |</div>
<div class="line"> 0      r = [ a0 a1  . a6 a7 ]</div>
<div class="line"> 1      r = [ a1 a2  . a7  0 ]</div>
<div class="line"> 2      r = [ a2 a3  .  0  0 ]</div>
<div class="line">  ...    ..   .. .. ... .. ..</div>
<div class="line"> 6      r = [ a6 a7  .  0  0 ]</div>
<div class="line"> 7      r = [ a7  0  .  0  0 ]</div>
<div class="line"> 8      r = [  0  0  .  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaeadaddeccce01a69b6ad1ee9d9bef9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 1      r = [ a1 a2 a3  0 ]</div>
<div class="line"> 2      r = [ a2 a3  0  0 ]</div>
<div class="line"> 3      r = [ a3  0  0  0 ]</div>
<div class="line"> 4      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7323ea40ffe56b8cbf1d04b115fe8abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 1      r = [ a1 a2 a3  0 ]</div>
<div class="line"> 2      r = [ a2 a3  0  0 ]</div>
<div class="line"> 3      r = [ a3  0  0  0 ]</div>
<div class="line"> 4      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga808347e7d20c776cf2805cff8c549fc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [ a1  0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6483c5997ef72a168ef5b29293199d86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [ a1  0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e8e0d2f0f78ce0d13eb29dff352e575"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 1      r = [ a1 a2 a3  0 ]</div>
<div class="line"> 2      r = [ a2 a3  0  0 ]</div>
<div class="line"> 3      r = [ a3  0  0  0 ]</div>
<div class="line"> 4      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gad53ea882d2b2d826dd1d9b648b9c9791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 1      r = [ a1 a2 a3  0 ]</div>
<div class="line"> 2      r = [ a2 a3  0  0 ]</div>
<div class="line"> 3      r = [ a3  0  0  0 ]</div>
<div class="line"> 4      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa7e230d030b4efcf9f48f720cc9eb0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [ a1  0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2157a96ec2fc274e8cc152db209803db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::move_l </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [ a1  0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6231a4e695e5f0631b30597850a1db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 8-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ a0  a1   .  a14 a15 ]</div>
<div class="line"> 1      r = [  0  a0   .  a13 a14 ]</div>
<div class="line"> 2      r = [  0   0   .  a12 a13 ]</div>
<div class="line">  ...    ..   .. ..   ...  ..  .. ..</div>
<div class="line"> 14     r = [  0   0   .  a0  a1  ]</div>
<div class="line"> 15     r = [  0   0   .   0  a0  ]</div>
<div class="line"> 16     r = [  0   0   .   0   0  ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga82564dafdc4ac0ea12383e7eed171f98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 8-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ a0  a1   .  a14 a15 ]</div>
<div class="line"> 1      r = [  0  a0   .  a13 a14 ]</div>
<div class="line"> 2      r = [  0   0   .  a12 a13 ]</div>
<div class="line">  ...    ..   .. ..   ...  ..  .. ..</div>
<div class="line"> 14     r = [  0   0   .  a0  a1  ]</div>
<div class="line"> 15     r = [  0   0   .   0  a0  ]</div>
<div class="line"> 16     r = [  0   0   .   0   0  ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gafff88d8bfb30fad1b46fb48b84fc6ba9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 16-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1   . 6  7  |</div>
<div class="line"> 0      r = [ a0 a1  . a6 a7 ]</div>
<div class="line"> 1      r = [  0 a0  . a5 a6 ]</div>
<div class="line"> 2      r = [  0  0  . a4 a5 ]</div>
<div class="line">  ...    ..   .. .. ... .. ..</div>
<div class="line"> 6      r = [  0  0  . a0 a1 ]</div>
<div class="line"> 7      r = [  0  0  .  0 a0 ]</div>
<div class="line"> 8      r = [  0  0  .  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5cdc362fdf99272d2573d9c550702c04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 16-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1   . 6  7  |</div>
<div class="line"> 0      r = [ a0 a1  . a6 a7 ]</div>
<div class="line"> 1      r = [  0 a0  . a5 a6 ]</div>
<div class="line"> 2      r = [  0  0  . a4 a5 ]</div>
<div class="line">  ...    ..   .. .. ... .. ..</div>
<div class="line"> 6      r = [  0  0  . a0 a1 ]</div>
<div class="line"> 7      r = [  0  0  .  0 a0 ]</div>
<div class="line"> 8      r = [  0  0  .  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga58e334a718f54a2dbd7809e4216ed394"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 0      r = [  0 a0 a1 a2 ]</div>
<div class="line"> 0      r = [  0  0 a0 a1 ]</div>
<div class="line"> 0      r = [  0  0  0 a0 ]</div>
<div class="line"> 0      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26c42e10ab20fe1d1ec8197cf029ed60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 0      r = [  0 a0 a1 a2 ]</div>
<div class="line"> 0      r = [  0  0 a0 a1 ]</div>
<div class="line"> 0      r = [  0  0  0 a0 ]</div>
<div class="line"> 0      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gae2c5a9e672c18dc6e36787e2576c9706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [  0 a0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8b6edaae0cbb730ed668abf9dda8cf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [  0 a0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ec8f6fea98810961b203daa7d77b253"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 0      r = [  0 a0 a1 a2 ]</div>
<div class="line"> 0      r = [  0  0 a0 a1 ]</div>
<div class="line"> 0      r = [  0  0  0 a0 ]</div>
<div class="line"> 0      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf620f9a38221cbab1fefd86770507b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 0      r = [  0 a0 a1 a2 ]</div>
<div class="line"> 0      r = [  0  0 a0 a1 ]</div>
<div class="line"> 0      r = [  0  0  0 a0 ]</div>
<div class="line"> 0      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bddcd2bea1fb1745d754cb9865826d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [  0 a0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaf808d819219c237cfc60ceb483ddc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::move_r </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [  0 a0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12532b16a59e6bdcd3a7e7c51aa107fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int128 simdpp::permute </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the 16-bit values within each 4 consecutive values of the vector. </p>
<p>The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">...</div>
<div class="line">r3 = a[s3]</div>
<div class="line">r4 = a[s0+4]</div>
<div class="line">...</div>
<div class="line">r7 = a[s3+4]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line"></div>
<div class="line">r8 = a[s0+8]</div>
<div class="line">...</div>
<div class="line">r11 = a[s3+8]</div>
<div class="line">r12 = a[s0+12]</div>
<div class="line">...</div>
<div class="line">r15 = a[s3+12]</div>
</div><!-- fragment --><dl class="section user"><dt>: 128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 1-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>: 256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-10 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad137839c20c24e5d474ad89e39a651a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::permute </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the 16-bit values within each 4 consecutive values of the vector. </p>
<p>The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">...</div>
<div class="line">r3 = a[s3]</div>
<div class="line">r4 = a[s0+4]</div>
<div class="line">...</div>
<div class="line">r7 = a[s3+4]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line"></div>
<div class="line">r8 = a[s0+8]</div>
<div class="line">...</div>
<div class="line">r11 = a[s3+8]</div>
<div class="line">r12 = a[s0+12]</div>
<div class="line">...</div>
<div class="line">r15 = a[s3+12]</div>
</div><!-- fragment --><dl class="section user"><dt>: 128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 1-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>: 256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-10 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6a069b3af02a1434e6b9275b89029ec9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int128 simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions.</li>
</ul>
The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gab576cebb34533ccb36cd7f7f084a5850"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions.</li>
</ul>
The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaaa73124337439afbfd129ee20ce223"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions.</li>
</ul>
The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gac1ec95ddc21caf8e8274b1778bc5ef08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int256 simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions.</li>
</ul>
The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gad063e853a0ec6e0c9f750f839e485373"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions.</li>
</ul>
The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga712121541c0a822b56216721fc5aa2da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions.</li>
</ul>
The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga37e406f0a6736ac6d8a83f5e8fb452fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors. </p>
<div class="fragment"><div class="line">    | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  |</div>
<div class="line">r = [ a1  a3  a5  a7  a9  a11 a13 a15 b1  b3  b5  b7  b9  b11 b13 b15 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gab7fd116ca26d0822ab7a40c60e392eb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors. </p>
<div class="fragment"><div class="line">    | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  |</div>
<div class="line">r = [ a1  a3  a5  a7  a9  a11 a13 a15 b1  b3  b5  b7  b9  b11 b13 b15 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1668b25227651bd339944b38d7a1faed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  6  7  |</div>
<div class="line">r = [ a1 a3 a5 a7 b1 b3 b5 b7 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae6cccd443cb9f3686007646af333bf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  6  7  |</div>
<div class="line">r = [ a1 a3 a5 a7 b1 b3 b5 b7 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga870855fdd1f5b9fb21b9b59e7bd39705"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a1 a3 b1 b3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gace28fd9f7a7da4ea1c2589bec72beac6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a1 a3 b1 b3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gadcae5bf49d4c7954309da09388f4727a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a1 b1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa582084a4b6f2537f5c0487fd0400999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a1 b1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c06035072bbd024745ea7a4da141f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a1 a3 b1 b3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30df036901ddc190ffd6523e37c20c21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a1 a3 b1 b3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga27c538ed0e293dce74c6aa9ea54ca59a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00012.html">float64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a1 b1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac14d916fc0f87bcc158d69d4bd13873"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::unzip_hi </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two <a class="el" href="a00012.html">float64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a1 b1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga779149f7266b4909070f61e405718498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors. </p>
<div class="fragment"><div class="line">    | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  |</div>
<div class="line">r = [ a0  a2  a4  a6  a8  a10 a12 a14 b0  b2  b4  b6  b8  b10 b12 b14 ]</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-8 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88cf3619fb96e5098c668112d9206623"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00022.html" title="Class representing 16x 8-bit signed integer vector.">int8x16</a> vectors. </p>
<div class="fragment"><div class="line">    | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  |</div>
<div class="line">r = [ a0  a2  a4  a6  a8  a10 a12 a14 b0  b2  b4  b6  b8  b10 b12 b14 ]</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-8 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4839bfa148d3adc320e4d3ab9a5400e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  6  7  |</div>
<div class="line">r = [ a0 a2 a4 a6 b0 b2 b4 b6 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4-8 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga771f80fe67d730dfa4049fd59754b2b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00016.html" title="Class representing 8x 16-bit signed integer vector.">int16x8</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  6  7  |</div>
<div class="line">r = [ a0 a2 a4 a6 b0 b2 b4 b6 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4-8 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec7d47730074b30dca6af16c7dcb09a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a0 a2 b0 b2 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bdf9f78cdebf59f616be2844c2ace56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00018.html" title="Class representing 4x 32-bit signed integer vector.">int32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a0 a2 b0 b2 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bb6af6db9912430d831cb830f210caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a0 b0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90cf9a94a89ef6ef60eaac781df28ccb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00020.html" title="Class representing 2x 64-bit signed integer vector.">int64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a0 b0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4956f59a712359d2b40a56ee700ff9a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a0 a2 b0 b2 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gafba35a84baccf72455c53f418e66a4ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00010.html" title="Class representing float32x4 vector.">float32x4</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a0 a2 b0 b2 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf205a50b2da4cc95fca63bb2fa68be0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00012.html">float64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a0 b0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b5a4a38b62a32ba9a738c08a49ab03a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::unzip_lo </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two <a class="el" href="a00012.html">float64x2</a> vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a0 b0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64860db308be1786a08a3a57d20b8dcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76f5a8dedcd70966cdbd06ec17f20b92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8384b7e8497054d962934e89803f825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gab596314d94e8bfcf2e172b1b9f607302"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga38b1f8733d36ba1073a7e0553342f4fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ae64382bc666752c3759148416377cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8882eee76298860268fa8af3f742e3f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7eed2f705da7875abe019792e51e717"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gab748b9e5dcb3eb79703a6b06ac8d8b04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf017f9f875186958691b99500b397dd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga414deb829db4fc078339d69473cd3bf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c81602b6990e266d3b267c3f5cac2bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::zip_hi </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a3442a5125f66e0e3c8633f896f693e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf084e5798e6470299811c19b2eb0d8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf950c12e66a5e457b3ab800f572f4c66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gafda5c78cf82e3932b4418801ffe73682"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gafac1f09b54bfaee90ee54b98c3ecb6de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae0c2db798e9b97669484ae7f67fffd6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae62ec3026fbe36a9697ac41577aec443"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa4c1261eff359a9ab7fb2411d39969be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab45e3176ae6661fd389890f02b0db3e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga92465d8750270b142d2b1f21e39d7c17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a792fb4e41c4db087db85d018bdbd2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="gab797f50f9a526802ec7c4c6f8e59d061"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::zip_lo </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 15 2013 19:30:36 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
