<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>libsimdpp: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="main">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">libsimdpp Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>libsimdpp is a header-only zero-overhead C++ wrapper around SIMD intrinsics.It supports multiple instruction sets via single interface. The same source code may be compiled for different instruction sets and linked to the same resulting binary. The library provides a convenient dynamic dispatch mechanism to select the fastest version of a function for the target processor.</p>
<p>To use the library, define one or more macros that specify the instruction set (architecture) of the target processor and then include <code>simdpp/simd.h</code>. The following instruction sets are supported:</p>
<ul>
<li><p class="startli"><code>NONE_NULL:</code> </p>
<p class="startli">The instructions are not vectorized and use standard C++. This instruction set is used if no SIMD instruction set is selected. (no macro defined).</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_SSE2:</code> </p>
<p class="startli">The x86/x86_64 SSE and SSE2 instruction sets are used.</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_SSE2</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_SSE3:</code> </p>
<p class="startli">The x86/x86_64 SSE3 instruction set is used. The SSE and SSE2 instruction set support is required implicitly (no need to define the macros for these instruction sets).</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_SSE3</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_SSSE3:</code> </p>
<p class="startli">The x86/x86_64 SSSE3 instruction set is used. The SSE, SSE2 and SSE3 instruction set support is required implicitly (no need to define the macros for these instruction sets).</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_SSSE3</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_SSE4.1</code>:</p>
<p class="startli">The x86/x86_64 SSE4.1 instruction set is used. The SSE, SSE2 and SSE3 instruction set support is required implicitly (no need to define the macros for these instruction sets).</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_SSE4_1</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_AVX:</code> </p>
<p class="startli">The x86/x86_64 AVX instruction set is used. The SSE, SSE2, SSE3 and SSSE3 instruction set support is required implicitly (no need to define the macros for these instruction sets).</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_AVX</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_AVX2:</code> </p>
<p class="startli">The x86/x86_64 AVX2 instruction set is used. The SSE, SSE2, SSE3, SSSE3 and AVX instruction set support is required implicitly (no need to define the macros for these instruction sets).</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_AVX2</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_FMA3:</code> </p>
<p class="startli">The Intel x86/x86_64 FMA3 instruction set is used. The SSE, SSE2, SSE3 instruction set support is required implicitly (no need to define the macros for these instruction sets). This instruction set must not be combined with X86_FMA4.</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_FMA3</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_FMA4:</code> </p>
<p class="startli">The AMD x86/x86_64 FMA4 instruction set is used. The SSE, SSE2, SSE3 instruction set support is required implicitly (no need to define the macros for these instruction sets). This instruction set must not be combined with X86_FMA3.</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_FMA4</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>X86_XOP:</code> </p>
<p class="startli">The AMD x86/x86_64 XOP instruction set is used. The SSE, SSE2, SSE3 instruction set support is required implicitly (no need to define the macros for these instruction sets).</p>
<p class="startli">Macro: <code>SIMDPP_ARCH_X86_XOP</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>ARM_NEON:</code> </p>
<p class="startli">The ARM NEON instruction set. The VFP co-processor is used for any floating-point functionality (NEON does not require the implementation to be IEEE-754 compliant, whereas VFP does).</p>
<p class="startli">Macro <code>SIMDPP_ARCH_ARM_NEON</code> </p>
</li>
</ul>
<ul>
<li><p class="startli"><code>ARM_NEON_FLT_SP:</code> </p>
<p class="startli">Performs 32-bit floating-point computations on the NEON vector unit. The NEON instruction set support is required implicitly (no need to define the macro for that instruction set).</p>
<p class="startli">Macro <code>SIMDPP_ARCH_ARM_NEON_FLT_SP</code>.</p>
</li>
</ul>
<ul>
<li><p class="startli"><code>POWER_ALTIVEC:</code> </p>
<p class="startli">The POWER Altivec instruction set. 64-bit floating point operations are not supported.</p>
<p class="startli">Macro <code>SIMDPP_ARCH_POWER_ALTIVEC</code>.</p>
</li>
</ul>
<h2>Instruction counts</h2>
<p>In this documentation all functions that map to more than one instruction are marked as such by listing the number of instructions that are used to implement a function. The instructions are counted as follows:</p>
<ul>
<li>Any register-register moves and copies that do not cross the processor domains are ignored;</li>
<li>Non-vector domain instructions are ignored except when they move data to or from memory or vector domain.</li>
<li>If the implementation of a function is dependent on template arguments (for example, element selector), then the instruction count is defined as a range with both lower and upper bounds</li>
<li>If the function loads or computes static data, then the instruction count is defined as a range. The lower count calculated as if the loads from memory or computation didn't happen (for example, if the function was used in a small loop and there were enough registers to cache the data). The upper count is calculated the other way round.</li>
</ul>
<p>If instruction count is not listed for specific architecture, then the function directly maps to one instruction. This rule does not apply to the following architectures:</p>
<p><code>X86_FMA3</code>, <code>X86_FMA4</code> and <code>X86_XOP</code>.</p>
<p>For these, if instruction count is not listed, the instruction counts should be interpreted as if the architecture is not supported.</p>
<p>Note, that instruction count is very, very imprecise way to measure performance. It is provided just as a quick way to estimate how well specific functionality maps to target architecture.</p>
<h2>Dynamic dispatch</h2>
<p>If the user wants to include several versions of the same code, compiled for different architectures sets into the same executable, then all such code <em>must</em> be put into <code>SIMDPP_ARCH_NAMESPACE</code> namespace. This macro evaluates to an identifier which is unique for each architecture.</p>
<p>In addition to the above, the source file must not define any of the architecture select macros; they must be supplied via the compiler options. The code for <code>NONE_NULL</code> architecture must be linked to the resulting executable.</p>
<p>To use dynamic dispatch mechanism, declare the function within an <code>SIMDPP_ARCH_NAMESPACE</code> and then use one of <code>SIMDPP_MAKE_DISPATCHER_***</code> macros.</p>
<h2>Dynamic dispatch example</h2>
<p>The following example demonstrates the simpliest usage of dynamic dispatch:</p>
<div class="fragment"><div class="line"><span class="comment">// test.h</span></div>
<div class="line"><span class="keywordtype">void</span> print_arch();</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test.cc</span></div>
<div class="line"><span class="preprocessor">#include &quot;test.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;simdpp/simd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>SIMDPP_ARCH_NAMESPACE {</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_arch()</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; static_cast&lt;unsigned&gt;(<a class="code" href="a00184.html#ga76a7e1d9682d0b80ae217d881ebd4b56" title="Returns the instruction set flags that will be required by the currently compiled code...">simdpp::this_compile_arch</a>()) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace SIMDPP_ARCH_NAMESPACE</span></div>
<div class="line"></div>
<div class="line">SIMDPP_MAKE_DISPATCHER_VOID0(print_arch);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// main.cc</span></div>
<div class="line"><span class="preprocessor">#include &quot;test.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    print_arch();</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#Makefile</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">CXXFLAGS=<span class="stringliteral">&quot;-std=c++11&quot;</span></div>
<div class="line"></div>
<div class="line">test: main.o test_sse2.o test_sse3.o test_sse4_1.o test_null.o</div>
<div class="line">    g++ $^ -lpthread -o test</div>
<div class="line"></div>
<div class="line">main.o: main.cc</div>
<div class="line">    g++ main.cc $(CXXFLAGS) -c -o main.o</div>
<div class="line"></div>
<div class="line"># inclusion of NONE_NULL is mandatory</div>
<div class="line">test_null.o: test.cc</div>
<div class="line">    g++ test.cc -c $(CXXFLAGS) -o test_sse2.o</div>
<div class="line"></div>
<div class="line">test_sse2.o: test.cc</div>
<div class="line">    g++ test.cc -c $(CXXFLAGS) -DSIMDPP_ARCH_X86_SSE2 -msse2 -o test_sse2.o</div>
<div class="line"></div>
<div class="line">test_sse3.o: test.cc</div>
<div class="line">    g++ test.cc -c $(CXXFLAGS) -DSIMDPP_ARCH_X86_SSE3 -msse3 -o test_sse3.o</div>
<div class="line"></div>
<div class="line">test_sse4_1.o: test.cc</div>
<div class="line">    g++ test.cc -c $(CXXFLAGS) -DSIMDPP_ARCH_X86_SSE4_1 -msse4.1 -o test_sse3.o</div>
</div><!-- fragment --><p>If compiled, the above example selects the "fastest" of SSE2, SSE3 or SSE4.1 instruction sets, whichever is available on the target processor and outputs an integer that identifiers that instruction set.</p>
<p>Note, that the object files must be linked directly to the executable. If static libraries are used, the linker may throw out static dispatcher registration code and break the mechanism. Do prevent this behavior, <code>-Wl</code>,&ndash;whole-archive or an equivalent flag must be used.</p>
<h2>CMake</h2>
<p>For CMake users, <code>cmake/SimdppMultiarch.cmake</code> contains several useful functions:</p>
<ul>
<li><code>simdpp_get_compilable_archs:</code> checks what architectures are supported by the compiler.</li>
<li><code>simdpp_get_runnable_archs:</code> checks what architectures are supported by both the compiler and the current processor.</li>
<li><code>simdpp_multiversion:</code> given a list of architectures (possibly generated by <code>simdpp_get_compilable_archs</code> or <code>simdpp_get_runnable_archs</code>), automatically configures compilation of additional objects. The user only needs to add the returned list of source files to <code>add_library</code> or <code>add_executable</code>.</li>
</ul>
<p>The above example may be build with <code>CMakeLists.txt</code> as simple as follows: </p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 2.8.0)</div>
<div class="line">project(test)</div>
<div class="line"></div>
<div class="line">include(SimdppMultiarch)</div>
<div class="line"></div>
<div class="line">simdpp_get_runnable_archs(RUNNABLE_ARCHS)</div>
<div class="line">simdpp_multiarch(GEN_ARCH_FILES test.cc ${RUNNABLE_ARCHS})</div>
<div class="line">add_executable(test main.cc ${GEN_ARCH_FILES})</div>
<div class="line">target_link_libraries(test pthread)</div>
<div class="line">set_target_properties(test PROPERTIES COMPILE_FLAGS <span class="stringliteral">&quot;-std=c++11&quot;</span>)</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 31 2013 04:08:52 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</div>
</body>
</html>
