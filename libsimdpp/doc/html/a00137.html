<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>libsimdpp: Operations: store a register to memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Operations: store a register to memory</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab56aed70158c9e35c32a1242c15b4250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gab56aed70158c9e35c32a1242c15b4250">simdpp::store</a> (void *p, int128 a)</td></tr>
<tr class="memdesc:gab56aed70158c9e35c32a1242c15b4250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer vector to an aligned memory location.  <a href="#gab56aed70158c9e35c32a1242c15b4250">More...</a><br/></td></tr>
<tr class="separator:gab56aed70158c9e35c32a1242c15b4250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24907e24c88727a6a3f9f0eb3f11a053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga24907e24c88727a6a3f9f0eb3f11a053">simdpp::store</a> (void *p, int256 a)</td></tr>
<tr class="separator:ga24907e24c88727a6a3f9f0eb3f11a053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c4df6d39ae182f846c714e6c4c4269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga85c4df6d39ae182f846c714e6c4c4269">simdpp::store</a> (float *p, float32x4 a)</td></tr>
<tr class="separator:ga85c4df6d39ae182f846c714e6c4c4269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e6276b96231bf70658ed6b8b1cf7cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga45e6276b96231bf70658ed6b8b1cf7cd">simdpp::store</a> (float *p, float32x8 a)</td></tr>
<tr class="separator:ga45e6276b96231bf70658ed6b8b1cf7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed91d5777830ef907ca4483b37d3c64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga3ed91d5777830ef907ca4483b37d3c64">simdpp::store</a> (double *p, float64x2 a)</td></tr>
<tr class="separator:ga3ed91d5777830ef907ca4483b37d3c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73f1afd82f676c7e4601c3b79db6db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gad73f1afd82f676c7e4601c3b79db6db0">simdpp::store</a> (double *p, float64x4 a)</td></tr>
<tr class="separator:gad73f1afd82f676c7e4601c3b79db6db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f83376fda75f41a6f611691333d249e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga6f83376fda75f41a6f611691333d249e">simdpp::store_u</a> (void *p, basic_int8x16 a)</td></tr>
<tr class="memdesc:ga6f83376fda75f41a6f611691333d249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#ga6f83376fda75f41a6f611691333d249e">More...</a><br/></td></tr>
<tr class="separator:ga6f83376fda75f41a6f611691333d249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653baf4db88cd1c6cd0f60ebe1e72c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga653baf4db88cd1c6cd0f60ebe1e72c61">simdpp::store_u</a> (void *p, basic_int8x32 a)</td></tr>
<tr class="memdesc:ga653baf4db88cd1c6cd0f60ebe1e72c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#ga653baf4db88cd1c6cd0f60ebe1e72c61">More...</a><br/></td></tr>
<tr class="separator:ga653baf4db88cd1c6cd0f60ebe1e72c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9a9d6250e11be63be7f82018d35f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaeb9a9d6250e11be63be7f82018d35f50">simdpp::store_u</a> (void *p, basic_int16x8 a)</td></tr>
<tr class="memdesc:gaeb9a9d6250e11be63be7f82018d35f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#gaeb9a9d6250e11be63be7f82018d35f50">More...</a><br/></td></tr>
<tr class="separator:gaeb9a9d6250e11be63be7f82018d35f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5354a5376340b35cc23e6a43f26baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gacb5354a5376340b35cc23e6a43f26baf">simdpp::store_u</a> (void *p, basic_int16x16 a)</td></tr>
<tr class="memdesc:gacb5354a5376340b35cc23e6a43f26baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#gacb5354a5376340b35cc23e6a43f26baf">More...</a><br/></td></tr>
<tr class="separator:gacb5354a5376340b35cc23e6a43f26baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5f817c6cd846a1fe5e4ac80ec6c679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga7e5f817c6cd846a1fe5e4ac80ec6c679">simdpp::store_u</a> (void *p, basic_int32x4 a)</td></tr>
<tr class="memdesc:ga7e5f817c6cd846a1fe5e4ac80ec6c679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#ga7e5f817c6cd846a1fe5e4ac80ec6c679">More...</a><br/></td></tr>
<tr class="separator:ga7e5f817c6cd846a1fe5e4ac80ec6c679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga009431c9a151f7139cd9b85100933525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga009431c9a151f7139cd9b85100933525">simdpp::store_u</a> (void *p, basic_int32x8 a)</td></tr>
<tr class="memdesc:ga009431c9a151f7139cd9b85100933525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#ga009431c9a151f7139cd9b85100933525">More...</a><br/></td></tr>
<tr class="separator:ga009431c9a151f7139cd9b85100933525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18e884fba2253780b4201ede07fc525f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga18e884fba2253780b4201ede07fc525f">simdpp::store_u</a> (void *p, basic_int64x2 a)</td></tr>
<tr class="memdesc:ga18e884fba2253780b4201ede07fc525f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#ga18e884fba2253780b4201ede07fc525f">More...</a><br/></td></tr>
<tr class="separator:ga18e884fba2253780b4201ede07fc525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef8f4683e8512797720fdf48cb0b876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gabef8f4683e8512797720fdf48cb0b876">simdpp::store_u</a> (void *p, basic_int64x4 a)</td></tr>
<tr class="memdesc:gabef8f4683e8512797720fdf48cb0b876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#gabef8f4683e8512797720fdf48cb0b876">More...</a><br/></td></tr>
<tr class="separator:gabef8f4683e8512797720fdf48cb0b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9aca40e06ebec6263ff3e2b55773970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gac9aca40e06ebec6263ff3e2b55773970">simdpp::store_u</a> (float *p, float32x4 a)</td></tr>
<tr class="memdesc:gac9aca40e06ebec6263ff3e2b55773970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#gac9aca40e06ebec6263ff3e2b55773970">More...</a><br/></td></tr>
<tr class="separator:gac9aca40e06ebec6263ff3e2b55773970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db7c3dcde034213d116cdbfe3266bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga8db7c3dcde034213d116cdbfe3266bd0">simdpp::store_u</a> (float *p, float32x8 a)</td></tr>
<tr class="memdesc:ga8db7c3dcde034213d116cdbfe3266bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#ga8db7c3dcde034213d116cdbfe3266bd0">More...</a><br/></td></tr>
<tr class="separator:ga8db7c3dcde034213d116cdbfe3266bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99a9f3edf78a80dc48185e5102d61e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gad99a9f3edf78a80dc48185e5102d61e2">simdpp::store_u</a> (double *p, float64x2 a)</td></tr>
<tr class="memdesc:gad99a9f3edf78a80dc48185e5102d61e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#gad99a9f3edf78a80dc48185e5102d61e2">More...</a><br/></td></tr>
<tr class="separator:gad99a9f3edf78a80dc48185e5102d61e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ebbde81b6008944bbcb56fc3ee3235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga74ebbde81b6008944bbcb56fc3ee3235">simdpp::store_u</a> (double *p, float64x4 a)</td></tr>
<tr class="memdesc:ga74ebbde81b6008944bbcb56fc3ee3235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location.  <a href="#ga74ebbde81b6008944bbcb56fc3ee3235">More...</a><br/></td></tr>
<tr class="separator:ga74ebbde81b6008944bbcb56fc3ee3235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2381b02d35678ec3e64a9c5f7c82c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gab2381b02d35678ec3e64a9c5f7c82c9f">simdpp::stream</a> (void *p, int128 a)</td></tr>
<tr class="memdesc:gab2381b02d35678ec3e64a9c5f7c82c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible.  <a href="#gab2381b02d35678ec3e64a9c5f7c82c9f">More...</a><br/></td></tr>
<tr class="separator:gab2381b02d35678ec3e64a9c5f7c82c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ec175b828e85e8bcb5e0e70190e622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaf0ec175b828e85e8bcb5e0e70190e622">simdpp::stream</a> (void *p, int256 a)</td></tr>
<tr class="memdesc:gaf0ec175b828e85e8bcb5e0e70190e622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible.  <a href="#gaf0ec175b828e85e8bcb5e0e70190e622">More...</a><br/></td></tr>
<tr class="separator:gaf0ec175b828e85e8bcb5e0e70190e622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96308a4e187bb870416ac594213e71c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga96308a4e187bb870416ac594213e71c3">simdpp::stream</a> (float *p, float32x4 a)</td></tr>
<tr class="memdesc:ga96308a4e187bb870416ac594213e71c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible.  <a href="#ga96308a4e187bb870416ac594213e71c3">More...</a><br/></td></tr>
<tr class="separator:ga96308a4e187bb870416ac594213e71c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b0fc5de18914b2286d911674d2c81c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gab8b0fc5de18914b2286d911674d2c81c">simdpp::stream</a> (float *p, float32x8 a)</td></tr>
<tr class="memdesc:gab8b0fc5de18914b2286d911674d2c81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible.  <a href="#gab8b0fc5de18914b2286d911674d2c81c">More...</a><br/></td></tr>
<tr class="separator:gab8b0fc5de18914b2286d911674d2c81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e0887f094db62a8b067607437a96e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga44e0887f094db62a8b067607437a96e1">simdpp::stream</a> (double *p, float64x2 a)</td></tr>
<tr class="memdesc:ga44e0887f094db62a8b067607437a96e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible.  <a href="#ga44e0887f094db62a8b067607437a96e1">More...</a><br/></td></tr>
<tr class="separator:ga44e0887f094db62a8b067607437a96e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cdd82a92fcfb9b55d41d2eca1a774c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaf3cdd82a92fcfb9b55d41d2eca1a774c">simdpp::stream</a> (double *p, float64x4 a)</td></tr>
<tr class="memdesc:gaf3cdd82a92fcfb9b55d41d2eca1a774c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible.  <a href="#gaf3cdd82a92fcfb9b55d41d2eca1a774c">More...</a><br/></td></tr>
<tr class="separator:gaf3cdd82a92fcfb9b55d41d2eca1a774c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7da16878714ea1f038ba0c52fe743b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga7da16878714ea1f038ba0c52fe743b9b">simdpp::store_first</a> (void *p, basic_int8x16 a, unsigned n)</td></tr>
<tr class="memdesc:ga7da16878714ea1f038ba0c52fe743b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga7da16878714ea1f038ba0c52fe743b9b">More...</a><br/></td></tr>
<tr class="separator:ga7da16878714ea1f038ba0c52fe743b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687fde38ed20c3981132235a71c12dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga687fde38ed20c3981132235a71c12dd9">simdpp::store_first</a> (void *p, basic_int8x32 a, unsigned n)</td></tr>
<tr class="memdesc:ga687fde38ed20c3981132235a71c12dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga687fde38ed20c3981132235a71c12dd9">More...</a><br/></td></tr>
<tr class="separator:ga687fde38ed20c3981132235a71c12dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf090bd989f7ac4912584a11eb9a7e6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaf090bd989f7ac4912584a11eb9a7e6ce">simdpp::store_first</a> (void *p, basic_int16x8 a, unsigned n)</td></tr>
<tr class="memdesc:gaf090bd989f7ac4912584a11eb9a7e6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gaf090bd989f7ac4912584a11eb9a7e6ce">More...</a><br/></td></tr>
<tr class="separator:gaf090bd989f7ac4912584a11eb9a7e6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c661b648631977f39d60a489d3ddeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaa7c661b648631977f39d60a489d3ddeb">simdpp::store_first</a> (void *p, basic_int16x16 a, unsigned n)</td></tr>
<tr class="memdesc:gaa7c661b648631977f39d60a489d3ddeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gaa7c661b648631977f39d60a489d3ddeb">More...</a><br/></td></tr>
<tr class="separator:gaa7c661b648631977f39d60a489d3ddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d613832ba9ddf1aad08c0ea36ab2d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga5d613832ba9ddf1aad08c0ea36ab2d34">simdpp::store_first</a> (void *p, basic_int32x4 a, unsigned n)</td></tr>
<tr class="memdesc:ga5d613832ba9ddf1aad08c0ea36ab2d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga5d613832ba9ddf1aad08c0ea36ab2d34">More...</a><br/></td></tr>
<tr class="separator:ga5d613832ba9ddf1aad08c0ea36ab2d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ace9620087e5414fcf3d459de2c6141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga4ace9620087e5414fcf3d459de2c6141">simdpp::store_first</a> (void *p, basic_int32x8 a, unsigned n)</td></tr>
<tr class="memdesc:ga4ace9620087e5414fcf3d459de2c6141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga4ace9620087e5414fcf3d459de2c6141">More...</a><br/></td></tr>
<tr class="separator:ga4ace9620087e5414fcf3d459de2c6141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd9a8e64970cfa6dc11f169b217ec19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga8fd9a8e64970cfa6dc11f169b217ec19">simdpp::store_first</a> (void *p, basic_int64x2 a, unsigned n)</td></tr>
<tr class="memdesc:ga8fd9a8e64970cfa6dc11f169b217ec19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga8fd9a8e64970cfa6dc11f169b217ec19">More...</a><br/></td></tr>
<tr class="separator:ga8fd9a8e64970cfa6dc11f169b217ec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c567dfd64e1f3ff63c98c58d13ee2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga13c567dfd64e1f3ff63c98c58d13ee2b">simdpp::store_first</a> (void *p, basic_int64x4 a, unsigned n)</td></tr>
<tr class="memdesc:ga13c567dfd64e1f3ff63c98c58d13ee2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga13c567dfd64e1f3ff63c98c58d13ee2b">More...</a><br/></td></tr>
<tr class="separator:ga13c567dfd64e1f3ff63c98c58d13ee2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5fd023f9e3c4ab14d7186b8f25541c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gacb5fd023f9e3c4ab14d7186b8f25541c">simdpp::store_first</a> (float *p, float32x4 a, unsigned n)</td></tr>
<tr class="memdesc:gacb5fd023f9e3c4ab14d7186b8f25541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gacb5fd023f9e3c4ab14d7186b8f25541c">More...</a><br/></td></tr>
<tr class="separator:gacb5fd023f9e3c4ab14d7186b8f25541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861ca339939a0e3a1bc8348da30927be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga861ca339939a0e3a1bc8348da30927be">simdpp::store_first</a> (float *p, float32x8 a, unsigned n)</td></tr>
<tr class="memdesc:ga861ca339939a0e3a1bc8348da30927be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga861ca339939a0e3a1bc8348da30927be">More...</a><br/></td></tr>
<tr class="separator:ga861ca339939a0e3a1bc8348da30927be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbcc188565db1a7ecbb314d05e679606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gabbcc188565db1a7ecbb314d05e679606">simdpp::store_first</a> (double *p, float64x2 a, unsigned n)</td></tr>
<tr class="memdesc:gabbcc188565db1a7ecbb314d05e679606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gabbcc188565db1a7ecbb314d05e679606">More...</a><br/></td></tr>
<tr class="separator:gabbcc188565db1a7ecbb314d05e679606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16740c3cc16ea0862ad1c503e13912cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga16740c3cc16ea0862ad1c503e13912cf">simdpp::store_first</a> (double *p, float64x4 a, unsigned n)</td></tr>
<tr class="memdesc:ga16740c3cc16ea0862ad1c503e13912cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga16740c3cc16ea0862ad1c503e13912cf">More...</a><br/></td></tr>
<tr class="separator:ga16740c3cc16ea0862ad1c503e13912cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471a709a8399394264c3d7c9eda9121f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga471a709a8399394264c3d7c9eda9121f">simdpp::store_last</a> (void *p, basic_int8x16 a, unsigned n)</td></tr>
<tr class="memdesc:ga471a709a8399394264c3d7c9eda9121f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga471a709a8399394264c3d7c9eda9121f">More...</a><br/></td></tr>
<tr class="separator:ga471a709a8399394264c3d7c9eda9121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10f025bce13eb7cb43a87fd375ceb64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaa10f025bce13eb7cb43a87fd375ceb64">simdpp::store_last</a> (void *p, basic_int8x32 a, unsigned n)</td></tr>
<tr class="memdesc:gaa10f025bce13eb7cb43a87fd375ceb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gaa10f025bce13eb7cb43a87fd375ceb64">More...</a><br/></td></tr>
<tr class="separator:gaa10f025bce13eb7cb43a87fd375ceb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb88e952301ae9debed3d56e9d8a5197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gafb88e952301ae9debed3d56e9d8a5197">simdpp::store_last</a> (void *p, basic_int16x8 a, unsigned n)</td></tr>
<tr class="memdesc:gafb88e952301ae9debed3d56e9d8a5197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gafb88e952301ae9debed3d56e9d8a5197">More...</a><br/></td></tr>
<tr class="separator:gafb88e952301ae9debed3d56e9d8a5197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed4efd6090038590602b158e9da9ea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaeed4efd6090038590602b158e9da9ea1">simdpp::store_last</a> (void *p, basic_int16x16 a, unsigned n)</td></tr>
<tr class="memdesc:gaeed4efd6090038590602b158e9da9ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gaeed4efd6090038590602b158e9da9ea1">More...</a><br/></td></tr>
<tr class="separator:gaeed4efd6090038590602b158e9da9ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0413e5a0331af643a161777217f5032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gae0413e5a0331af643a161777217f5032">simdpp::store_last</a> (void *p, basic_int32x4 a, unsigned n)</td></tr>
<tr class="memdesc:gae0413e5a0331af643a161777217f5032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gae0413e5a0331af643a161777217f5032">More...</a><br/></td></tr>
<tr class="separator:gae0413e5a0331af643a161777217f5032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0e2943da08854d58659c10cdb404f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga4b0e2943da08854d58659c10cdb404f9">simdpp::store_last</a> (void *p, basic_int32x8 a, unsigned n)</td></tr>
<tr class="memdesc:ga4b0e2943da08854d58659c10cdb404f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga4b0e2943da08854d58659c10cdb404f9">More...</a><br/></td></tr>
<tr class="separator:ga4b0e2943da08854d58659c10cdb404f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc91d8cd46b4f906e059869e6e848ac0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gadc91d8cd46b4f906e059869e6e848ac0">simdpp::store_last</a> (void *p, basic_int64x2 a, unsigned n)</td></tr>
<tr class="memdesc:gadc91d8cd46b4f906e059869e6e848ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gadc91d8cd46b4f906e059869e6e848ac0">More...</a><br/></td></tr>
<tr class="separator:gadc91d8cd46b4f906e059869e6e848ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76352b64641b7d7352caaed76282ff9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga76352b64641b7d7352caaed76282ff9f">simdpp::store_last</a> (void *p, basic_int64x4 a, unsigned n)</td></tr>
<tr class="memdesc:ga76352b64641b7d7352caaed76282ff9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga76352b64641b7d7352caaed76282ff9f">More...</a><br/></td></tr>
<tr class="separator:ga76352b64641b7d7352caaed76282ff9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f57898cfa8a2780cb25a8f1d5b11c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga88f57898cfa8a2780cb25a8f1d5b11c8">simdpp::store_last</a> (float *p, float32x4 a, unsigned n)</td></tr>
<tr class="memdesc:ga88f57898cfa8a2780cb25a8f1d5b11c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga88f57898cfa8a2780cb25a8f1d5b11c8">More...</a><br/></td></tr>
<tr class="separator:ga88f57898cfa8a2780cb25a8f1d5b11c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6c1503e1c383edbd836700b6e52a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga4b6c1503e1c383edbd836700b6e52a73">simdpp::store_last</a> (float *p, float32x8 a, unsigned n)</td></tr>
<tr class="memdesc:ga4b6c1503e1c383edbd836700b6e52a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga4b6c1503e1c383edbd836700b6e52a73">More...</a><br/></td></tr>
<tr class="separator:ga4b6c1503e1c383edbd836700b6e52a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a78eb260b9021f40ea139a7abd9cc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga44a78eb260b9021f40ea139a7abd9cc7">simdpp::store_last</a> (double *p, float64x2 a, unsigned n)</td></tr>
<tr class="memdesc:ga44a78eb260b9021f40ea139a7abd9cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#ga44a78eb260b9021f40ea139a7abd9cc7">More...</a><br/></td></tr>
<tr class="separator:ga44a78eb260b9021f40ea139a7abd9cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51a572173edb2f94e1c039bc2a09e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaa51a572173edb2f94e1c039bc2a09e5a">simdpp::store_last</a> (double *p, float64x4 a, unsigned n)</td></tr>
<tr class="memdesc:gaa51a572173edb2f94e1c039bc2a09e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#gaa51a572173edb2f94e1c039bc2a09e5a">More...</a><br/></td></tr>
<tr class="separator:gaa51a572173edb2f94e1c039bc2a09e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad25464f0d66d761d9801b00dfc00b7a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gad25464f0d66d761d9801b00dfc00b7a4">simdpp::store_packed2</a> (void *p, basic_int8x16 a, basic_int8x16 b)</td></tr>
<tr class="memdesc:gad25464f0d66d761d9801b00dfc00b7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 8-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gad25464f0d66d761d9801b00dfc00b7a4">More...</a><br/></td></tr>
<tr class="separator:gad25464f0d66d761d9801b00dfc00b7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c7e76661c61a02238383ac3498c752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga71c7e76661c61a02238383ac3498c752">simdpp::store_packed2</a> (void *p, basic_int8x32 a, basic_int8x32 b)</td></tr>
<tr class="memdesc:ga71c7e76661c61a02238383ac3498c752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 8-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga71c7e76661c61a02238383ac3498c752">More...</a><br/></td></tr>
<tr class="separator:ga71c7e76661c61a02238383ac3498c752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d1f29b4fed3fa33a77c586c9a34cc06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga6d1f29b4fed3fa33a77c586c9a34cc06">simdpp::store_packed2</a> (void *p, basic_int16x8 a, basic_int16x8 b)</td></tr>
<tr class="memdesc:ga6d1f29b4fed3fa33a77c586c9a34cc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 16-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga6d1f29b4fed3fa33a77c586c9a34cc06">More...</a><br/></td></tr>
<tr class="separator:ga6d1f29b4fed3fa33a77c586c9a34cc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9732d607e7a5f14135a921315fd0803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gac9732d607e7a5f14135a921315fd0803">simdpp::store_packed2</a> (void *p, basic_int16x16 a, basic_int16x16 b)</td></tr>
<tr class="memdesc:gac9732d607e7a5f14135a921315fd0803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 16-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gac9732d607e7a5f14135a921315fd0803">More...</a><br/></td></tr>
<tr class="separator:gac9732d607e7a5f14135a921315fd0803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2addbc3553d7db43baea31a613bc2c46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga2addbc3553d7db43baea31a613bc2c46">simdpp::store_packed2</a> (void *p, basic_int32x4 a, basic_int32x4 b)</td></tr>
<tr class="memdesc:ga2addbc3553d7db43baea31a613bc2c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga2addbc3553d7db43baea31a613bc2c46">More...</a><br/></td></tr>
<tr class="separator:ga2addbc3553d7db43baea31a613bc2c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e684be202c43a38ec61ae740902e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga41e684be202c43a38ec61ae740902e4b">simdpp::store_packed2</a> (void *p, basic_int32x8 a, basic_int32x8 b)</td></tr>
<tr class="memdesc:ga41e684be202c43a38ec61ae740902e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga41e684be202c43a38ec61ae740902e4b">More...</a><br/></td></tr>
<tr class="separator:ga41e684be202c43a38ec61ae740902e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54dbef4f20fe57cedd263fe2ac8e7b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga54dbef4f20fe57cedd263fe2ac8e7b95">simdpp::store_packed2</a> (void *p, basic_int64x2 a, basic_int64x2 b)</td></tr>
<tr class="memdesc:ga54dbef4f20fe57cedd263fe2ac8e7b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga54dbef4f20fe57cedd263fe2ac8e7b95">More...</a><br/></td></tr>
<tr class="separator:ga54dbef4f20fe57cedd263fe2ac8e7b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806b323a94ffe51c1b5d7c9f2868c96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga806b323a94ffe51c1b5d7c9f2868c96e">simdpp::store_packed2</a> (void *p, basic_int64x4 a, basic_int64x4 b)</td></tr>
<tr class="memdesc:ga806b323a94ffe51c1b5d7c9f2868c96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga806b323a94ffe51c1b5d7c9f2868c96e">More...</a><br/></td></tr>
<tr class="separator:ga806b323a94ffe51c1b5d7c9f2868c96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a8fc80bc6190e18a65897fd84f3649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gae1a8fc80bc6190e18a65897fd84f3649">simdpp::store_packed2</a> (float *p, float32x4 a, float32x4 b)</td></tr>
<tr class="memdesc:gae1a8fc80bc6190e18a65897fd84f3649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gae1a8fc80bc6190e18a65897fd84f3649">More...</a><br/></td></tr>
<tr class="separator:gae1a8fc80bc6190e18a65897fd84f3649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90937783d90a7e8f8999d03b79e3707d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga90937783d90a7e8f8999d03b79e3707d">simdpp::store_packed2</a> (float *p, float32x8 a, float32x8 b)</td></tr>
<tr class="memdesc:ga90937783d90a7e8f8999d03b79e3707d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga90937783d90a7e8f8999d03b79e3707d">More...</a><br/></td></tr>
<tr class="separator:ga90937783d90a7e8f8999d03b79e3707d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f950087bff09f76c50d87d8d4e3863b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga2f950087bff09f76c50d87d8d4e3863b">simdpp::store_packed2</a> (double *p, float64x2 a, float64x2 b)</td></tr>
<tr class="memdesc:ga2f950087bff09f76c50d87d8d4e3863b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga2f950087bff09f76c50d87d8d4e3863b">More...</a><br/></td></tr>
<tr class="separator:ga2f950087bff09f76c50d87d8d4e3863b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga820ae5c25594b019d3b96fd48f02f3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga820ae5c25594b019d3b96fd48f02f3f8">simdpp::store_packed2</a> (double *p, float64x4 a, float64x4 b)</td></tr>
<tr class="memdesc:ga820ae5c25594b019d3b96fd48f02f3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga820ae5c25594b019d3b96fd48f02f3f8">More...</a><br/></td></tr>
<tr class="separator:ga820ae5c25594b019d3b96fd48f02f3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91407254d24fa0f76d0ee656a22b826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaf91407254d24fa0f76d0ee656a22b826">simdpp::store_packed3</a> (void *p, basic_int8x16 a, basic_int8x16 b, basic_int8x16 c)</td></tr>
<tr class="memdesc:gaf91407254d24fa0f76d0ee656a22b826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 8-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gaf91407254d24fa0f76d0ee656a22b826">More...</a><br/></td></tr>
<tr class="separator:gaf91407254d24fa0f76d0ee656a22b826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2113d8cfab4e47d4bb2815dc47a554a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaa2113d8cfab4e47d4bb2815dc47a554a">simdpp::store_packed3</a> (void *p, basic_int8x32 a, basic_int8x32 b, basic_int8x32 c)</td></tr>
<tr class="memdesc:gaa2113d8cfab4e47d4bb2815dc47a554a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 8-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gaa2113d8cfab4e47d4bb2815dc47a554a">More...</a><br/></td></tr>
<tr class="separator:gaa2113d8cfab4e47d4bb2815dc47a554a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae66f42ce7efc158bbe46eb49726ed0a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gae66f42ce7efc158bbe46eb49726ed0a8">simdpp::store_packed3</a> (void *p, basic_int16x8 a, basic_int16x8 b, basic_int16x8 c)</td></tr>
<tr class="memdesc:gae66f42ce7efc158bbe46eb49726ed0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 16-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gae66f42ce7efc158bbe46eb49726ed0a8">More...</a><br/></td></tr>
<tr class="separator:gae66f42ce7efc158bbe46eb49726ed0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4392971a6c1451303e56038d2619458c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga4392971a6c1451303e56038d2619458c">simdpp::store_packed3</a> (void *p, basic_int16x16 a, basic_int16x16 b, basic_int16x16 c)</td></tr>
<tr class="memdesc:ga4392971a6c1451303e56038d2619458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 16-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga4392971a6c1451303e56038d2619458c">More...</a><br/></td></tr>
<tr class="separator:ga4392971a6c1451303e56038d2619458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e9faf2ab6f3c82396365bf20458941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga95e9faf2ab6f3c82396365bf20458941">simdpp::store_packed3</a> (void *p, basic_int32x4 a, basic_int32x4 b, basic_int32x4 c)</td></tr>
<tr class="memdesc:ga95e9faf2ab6f3c82396365bf20458941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga95e9faf2ab6f3c82396365bf20458941">More...</a><br/></td></tr>
<tr class="separator:ga95e9faf2ab6f3c82396365bf20458941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b817710d9e5564a8934ddcfce1477ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga2b817710d9e5564a8934ddcfce1477ea">simdpp::store_packed3</a> (void *p, basic_int32x8 a, basic_int32x8 b, basic_int32x8 c)</td></tr>
<tr class="memdesc:ga2b817710d9e5564a8934ddcfce1477ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga2b817710d9e5564a8934ddcfce1477ea">More...</a><br/></td></tr>
<tr class="separator:ga2b817710d9e5564a8934ddcfce1477ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754bd9119ece20094eb590ae841f4926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga754bd9119ece20094eb590ae841f4926">simdpp::store_packed3</a> (void *p, basic_int64x2 a, basic_int64x2 b, basic_int64x2 c)</td></tr>
<tr class="memdesc:ga754bd9119ece20094eb590ae841f4926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga754bd9119ece20094eb590ae841f4926">More...</a><br/></td></tr>
<tr class="separator:ga754bd9119ece20094eb590ae841f4926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac31d61dcbd7d232e4f4b7327661e13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaac31d61dcbd7d232e4f4b7327661e13b">simdpp::store_packed3</a> (void *p, basic_int64x4 a, basic_int64x4 b, basic_int64x4 c)</td></tr>
<tr class="memdesc:gaac31d61dcbd7d232e4f4b7327661e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gaac31d61dcbd7d232e4f4b7327661e13b">More...</a><br/></td></tr>
<tr class="separator:gaac31d61dcbd7d232e4f4b7327661e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3463e307a49c283a48f79a829627075f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga3463e307a49c283a48f79a829627075f">simdpp::store_packed3</a> (float *p, float32x4 a, float32x4 b, float32x4 c)</td></tr>
<tr class="memdesc:ga3463e307a49c283a48f79a829627075f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga3463e307a49c283a48f79a829627075f">More...</a><br/></td></tr>
<tr class="separator:ga3463e307a49c283a48f79a829627075f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49474f8d8a89030379761c8d5b232b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaa49474f8d8a89030379761c8d5b232b8">simdpp::store_packed3</a> (float *p, float32x8 a, float32x8 b, float32x8 c)</td></tr>
<tr class="memdesc:gaa49474f8d8a89030379761c8d5b232b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gaa49474f8d8a89030379761c8d5b232b8">More...</a><br/></td></tr>
<tr class="separator:gaa49474f8d8a89030379761c8d5b232b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599ccf152f49ae9888afc7d46c11f3a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga599ccf152f49ae9888afc7d46c11f3a0">simdpp::store_packed3</a> (double *p, float64x2 a, float64x2 b, float64x2 c)</td></tr>
<tr class="memdesc:ga599ccf152f49ae9888afc7d46c11f3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga599ccf152f49ae9888afc7d46c11f3a0">More...</a><br/></td></tr>
<tr class="separator:ga599ccf152f49ae9888afc7d46c11f3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1afa6008e9f292c530845c47e00bb6e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga1afa6008e9f292c530845c47e00bb6e4">simdpp::store_packed3</a> (double *p, float64x4 a, float64x4 b, float64x4 c)</td></tr>
<tr class="memdesc:ga1afa6008e9f292c530845c47e00bb6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga1afa6008e9f292c530845c47e00bb6e4">More...</a><br/></td></tr>
<tr class="separator:ga1afa6008e9f292c530845c47e00bb6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61acd803b8998cb9e3dd8b4a9ce21737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga61acd803b8998cb9e3dd8b4a9ce21737">simdpp::store_packed4</a> (void *p, basic_int8x16 a, basic_int8x16 b, basic_int8x16 c, basic_int8x16 d)</td></tr>
<tr class="memdesc:ga61acd803b8998cb9e3dd8b4a9ce21737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 8-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga61acd803b8998cb9e3dd8b4a9ce21737">More...</a><br/></td></tr>
<tr class="separator:ga61acd803b8998cb9e3dd8b4a9ce21737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fbd22d1fde9a20fc6131747544c29af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga8fbd22d1fde9a20fc6131747544c29af">simdpp::store_packed4</a> (void *p, basic_int8x32 a, basic_int8x32 b, basic_int8x32 c, basic_int8x32 d)</td></tr>
<tr class="memdesc:ga8fbd22d1fde9a20fc6131747544c29af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 8-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga8fbd22d1fde9a20fc6131747544c29af">More...</a><br/></td></tr>
<tr class="separator:ga8fbd22d1fde9a20fc6131747544c29af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfca20def5afeff84f677264682205c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gabfca20def5afeff84f677264682205c1">simdpp::store_packed4</a> (void *p, basic_int16x8 a, basic_int16x8 b, basic_int16x8 c, basic_int16x8 d)</td></tr>
<tr class="memdesc:gabfca20def5afeff84f677264682205c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 16-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gabfca20def5afeff84f677264682205c1">More...</a><br/></td></tr>
<tr class="separator:gabfca20def5afeff84f677264682205c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c094ca64dfa830adadcac0e12609030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga3c094ca64dfa830adadcac0e12609030">simdpp::store_packed4</a> (void *p, basic_int16x16 a, basic_int16x16 b, basic_int16x16 c, basic_int16x16 d)</td></tr>
<tr class="memdesc:ga3c094ca64dfa830adadcac0e12609030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 16-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga3c094ca64dfa830adadcac0e12609030">More...</a><br/></td></tr>
<tr class="separator:ga3c094ca64dfa830adadcac0e12609030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b78ffc02d9b28f5dc677b57c345dba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga8b78ffc02d9b28f5dc677b57c345dba4">simdpp::store_packed4</a> (void *p, basic_int32x4 a, basic_int32x4 b, basic_int32x4 c, basic_int32x4 d)</td></tr>
<tr class="memdesc:ga8b78ffc02d9b28f5dc677b57c345dba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga8b78ffc02d9b28f5dc677b57c345dba4">More...</a><br/></td></tr>
<tr class="separator:ga8b78ffc02d9b28f5dc677b57c345dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a51c08b9e82f93961a0ab6c85788b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#gaf6a51c08b9e82f93961a0ab6c85788b8">simdpp::store_packed4</a> (void *p, basic_int32x8 a, basic_int32x8 b, basic_int32x8 c, basic_int32x8 d)</td></tr>
<tr class="memdesc:gaf6a51c08b9e82f93961a0ab6c85788b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#gaf6a51c08b9e82f93961a0ab6c85788b8">More...</a><br/></td></tr>
<tr class="separator:gaf6a51c08b9e82f93961a0ab6c85788b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99838ee1dc6b210fa11e3e493922d798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga99838ee1dc6b210fa11e3e493922d798">simdpp::store_packed4</a> (void *p, basic_int64x2 a, basic_int64x2 b, basic_int64x2 c, basic_int64x2 d)</td></tr>
<tr class="memdesc:ga99838ee1dc6b210fa11e3e493922d798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga99838ee1dc6b210fa11e3e493922d798">More...</a><br/></td></tr>
<tr class="separator:ga99838ee1dc6b210fa11e3e493922d798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7c3d23715f0b97102925aa02ff7547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga7e7c3d23715f0b97102925aa02ff7547">simdpp::store_packed4</a> (void *p, basic_int64x4 a, basic_int64x4 b, basic_int64x4 c, basic_int64x4 d)</td></tr>
<tr class="memdesc:ga7e7c3d23715f0b97102925aa02ff7547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga7e7c3d23715f0b97102925aa02ff7547">More...</a><br/></td></tr>
<tr class="separator:ga7e7c3d23715f0b97102925aa02ff7547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48ba7f509c99a98df11f948a704ea5e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga48ba7f509c99a98df11f948a704ea5e8">simdpp::store_packed4</a> (float *p, float32x4 a, float32x4 b, float32x4 c, float32x4 d)</td></tr>
<tr class="memdesc:ga48ba7f509c99a98df11f948a704ea5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga48ba7f509c99a98df11f948a704ea5e8">More...</a><br/></td></tr>
<tr class="separator:ga48ba7f509c99a98df11f948a704ea5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146934ed2119745944289e4f3b55f681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga146934ed2119745944289e4f3b55f681">simdpp::store_packed4</a> (float *p, float32x8 a, float32x8 b, float32x8 c, float32x8 d)</td></tr>
<tr class="memdesc:ga146934ed2119745944289e4f3b55f681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 32-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga146934ed2119745944289e4f3b55f681">More...</a><br/></td></tr>
<tr class="separator:ga146934ed2119745944289e4f3b55f681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841c712688136b6e5b07f1d728b31c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga841c712688136b6e5b07f1d728b31c6d">simdpp::store_packed4</a> (double *p, float64x2 a, float64x2 b, float64x2 c, float64x2 d)</td></tr>
<tr class="memdesc:ga841c712688136b6e5b07f1d728b31c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga841c712688136b6e5b07f1d728b31c6d">More...</a><br/></td></tr>
<tr class="separator:ga841c712688136b6e5b07f1d728b31c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080e83d436d86bf80d871f4a8f161992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html#ga080e83d436d86bf80d871f4a8f161992">simdpp::store_packed4</a> (double *p, float64x4 a, float64x4 b, float64x4 c, float64x4 d)</td></tr>
<tr class="memdesc:ga080e83d436d86bf80d871f4a8f161992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves 64-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#ga080e83d436d86bf80d871f4a8f161992">More...</a><br/></td></tr>
<tr class="separator:ga080e83d436d86bf80d871f4a8f161992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab56aed70158c9e35c32a1242c15b4250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer vector to an aligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga24907e24c88727a6a3f9f0eb3f11a053"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga85c4df6d39ae182f846c714e6c4c4269"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga45e6276b96231bf70658ed6b8b1cf7cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3ed91d5777830ef907ca4483b37d3c64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad73f1afd82f676c7e4601c3b79db6db0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7da16878714ea1f038ba0c52fe743b9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga687fde38ed20c3981132235a71c12dd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf090bd989f7ac4912584a11eb9a7e6ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7c661b648631977f39d60a489d3ddeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d613832ba9ddf1aad08c0ea36ab2d34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ace9620087e5414fcf3d459de2c6141"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fd9a8e64970cfa6dc11f169b217ec19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13c567dfd64e1f3ff63c98c58d13ee2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb5fd023f9e3c4ab14d7186b8f25541c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga861ca339939a0e3a1bc8348da30927be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbcc188565db1a7ecbb314d05e679606"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16740c3cc16ea0862ad1c503e13912cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p) = a0</div>
<div class="line">*(p+1) = a1</div>
<div class="line">...</div>
<div class="line">*(p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga471a709a8399394264c3d7c9eda9121f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa10f025bce13eb7cb43a87fd375ceb64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb88e952301ae9debed3d56e9d8a5197"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeed4efd6090038590602b158e9da9ea1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0413e5a0331af643a161777217f5032"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b0e2943da08854d58659c10cdb404f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc91d8cd46b4f906e059869e6e848ac0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76352b64641b7d7352caaed76282ff9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88f57898cfa8a2780cb25a8f1d5b11c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b6c1503e1c383edbd836700b6e52a73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44a78eb260b9021f40ea139a7abd9cc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa51a572173edb2f94e1c039bc2a09e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<div class="fragment"><div class="line">*(p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line">*(p+N-2) = a{N-2}</div>
<div class="line">*(p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gad25464f0d66d761d9801b00dfc00b7a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 8-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+30) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+31) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+62) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+63) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga71c7e76661c61a02238383ac3498c752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 8-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+30) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+31) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+62) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+63) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d1f29b4fed3fa33a77c586c9a34cc06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 16-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+30) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+31) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gac9732d607e7a5f14135a921315fd0803"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 16-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+30) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+31) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2addbc3553d7db43baea31a613bc2c46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), *(p+6) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), *(p+7) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41e684be202c43a38ec61ae740902e4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), *(p+6) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), *(p+7) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54dbef4f20fe57cedd263fe2ac8e7b95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2) ] = a</div>
<div class="line">[ *(p+1), *(p+3) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga806b323a94ffe51c1b5d7c9f2868c96e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2) ] = a</div>
<div class="line">[ *(p+1), *(p+3) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1a8fc80bc6190e18a65897fd84f3649"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+6) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+7) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90937783d90a7e8f8999d03b79e3707d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+6) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+7) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f950087bff09f76c50d87d8d4e3863b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2) ] = a</div>
<div class="line">[ *(p+1), *(p+3) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga820ae5c25594b019d3b96fd48f02f3f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit floating-point values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2) ] = a</div>
<div class="line">[ *(p+1), *(p+3) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), *(p+14) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), *(p+15) ] = b</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes </dd></dl>

</div>
</div>
<a class="anchor" id="gaf91407254d24fa0f76d0ee656a22b826"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 8-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+45) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+46) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+47) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+93) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+94) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+95) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2113d8cfab4e47d4bb2815dc47a554a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 8-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+45) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+46) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+47) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+93) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+94) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+95) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gae66f42ce7efc158bbe46eb49726ed0a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 16-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+21) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+22) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+23) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+45) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+46) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+47) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4392971a6c1451303e56038d2619458c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 16-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+21) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+22) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+23) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+45) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+46) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+47) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95e9faf2ab6f3c82396365bf20458941"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+21) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+22) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+23) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b817710d9e5564a8934ddcfce1477ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+21) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+22) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+23) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga754bd9119ece20094eb590ae841f4926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3) ] = a</div>
<div class="line">[ *(p+1), *(p+4) ] = b</div>
<div class="line">[ *(p+2), *(p+5) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac31d61dcbd7d232e4f4b7327661e13b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3) ] = a</div>
<div class="line">[ *(p+1), *(p+4) ] = b</div>
<div class="line">[ *(p+2), *(p+5) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3463e307a49c283a48f79a829627075f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+21) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+22) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+23) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa49474f8d8a89030379761c8d5b232b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+21) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+22) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+23) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga599ccf152f49ae9888afc7d46c11f3a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<p>Loads 64-bit floating point values packed in triplets, de-interleaves them and stores the result into three vectors.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3) ] = a</div>
<div class="line">[ *(p+1), *(p+4) ] = b</div>
<div class="line">[ *(p+2), *(p+5) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1afa6008e9f292c530845c47e00bb6e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit floating-point values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<p>Loads 64-bit floating point values packed in triplets, de-interleaves them and stores the result into three vectors.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3) ] = a</div>
<div class="line">[ *(p+1), *(p+4) ] = b</div>
<div class="line">[ *(p+2), *(p+5) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), *(p+9)  ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), *(p+10) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), *(p+11) ] = c</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61acd803b8998cb9e3dd8b4a9ce21737"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 8-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+60) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+61) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+62) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+63) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+124) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+125) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+126) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+127) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fbd22d1fde9a20fc6131747544c29af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 8-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+60) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+61) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+62) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+63) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+124) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+125) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+126) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+127) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gabfca20def5afeff84f677264682205c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 16-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+28) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+29) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+30) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+31) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+60) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+61) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+62) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+63) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c094ca64dfa830adadcac0e12609030"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 16-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+28) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+29) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+30) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+31) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+60) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+61) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+62) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+63) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b78ffc02d9b28f5dc677b57c345dba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+28) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+29) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+30) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+31) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6a51c08b9e82f93961a0ab6c85788b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+28) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+29) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+30) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+31) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="ga99838ee1dc6b210fa11e3e493922d798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4) ] = a</div>
<div class="line">[ *(p+1), *(p+5) ] = b</div>
<div class="line">[ *(p+2), *(p+6) ] = c</div>
<div class="line">[ *(p+3), *(p+7) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e7c3d23715f0b97102925aa02ff7547"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4) ] = a</div>
<div class="line">[ *(p+1), *(p+5) ] = b</div>
<div class="line">[ *(p+2), *(p+6) ] = c</div>
<div class="line">[ *(p+3), *(p+7) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="ga48ba7f509c99a98df11f948a704ea5e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+28) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+29) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+30) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+31) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="ga146934ed2119745944289e4f3b55f681"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 32-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+28) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+29) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+30) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+31) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="ga841c712688136b6e5b07f1d728b31c6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4) ] = a</div>
<div class="line">[ *(p+1), *(p+5) ] = b</div>
<div class="line">[ *(p+2), *(p+6) ] = c</div>
<div class="line">[ *(p+3), *(p+7) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="ga080e83d436d86bf80d871f4a8f161992"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves 64-bit floating-point values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4) ] = a</div>
<div class="line">[ *(p+1), *(p+5) ] = b</div>
<div class="line">[ *(p+2), *(p+6) ] = c</div>
<div class="line">[ *(p+3), *(p+7) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  *(p+12) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  *(p+13) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), *(p+14) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), *(p+15) ] = d</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes.  </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f83376fda75f41a6f611691333d249e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga653baf4db88cd1c6cd0f60ebe1e72c61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gaeb9a9d6250e11be63be7f82018d35f50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gacb5354a5376340b35cc23e6a43f26baf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga7e5f817c6cd846a1fe5e4ac80ec6c679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga009431c9a151f7139cd9b85100933525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga18e884fba2253780b4201ede07fc525f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gabef8f4683e8512797720fdf48cb0b876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gac9aca40e06ebec6263ff3e2b55773970"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga8db7c3dcde034213d116cdbfe3266bd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gad99a9f3edf78a80dc48185e5102d61e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga74ebbde81b6008944bbcb56fc3ee3235"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_u </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit float vector to an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gab2381b02d35678ec3e64a9c5f7c82c9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::stream </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int128&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf0ec175b828e85e8bcb5e0e70190e622"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::stream </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int256&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga96308a4e187bb870416ac594213e71c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::stream </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="gab8b0fc5de18914b2286d911674d2c81c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::stream </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga44e0887f094db62a8b067607437a96e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::stream </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf3cdd82a92fcfb9b55d41d2eca1a774c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::stream </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">*(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 15 2013 21:06:32 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
