<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>libsimdpp: Operations: load from memory to register</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="main">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Operations: load from memory to register</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga03be39688c5e0ebb8d10f8e672bc9de9"><td class="memItemLeft" align="right" valign="top">int128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga03be39688c5e0ebb8d10f8e672bc9de9">simdpp::load</a> (int128 &amp;a, const void *p)</td></tr>
<tr class="memdesc:ga03be39688c5e0ebb8d10f8e672bc9de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an aligned memory location.  <a href="#ga03be39688c5e0ebb8d10f8e672bc9de9">More...</a><br/></td></tr>
<tr class="separator:ga03be39688c5e0ebb8d10f8e672bc9de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426e9be67559cb2153c17f5edbbe5c8e"><td class="memItemLeft" align="right" valign="top">int256&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga426e9be67559cb2153c17f5edbbe5c8e">simdpp::load</a> (int256 &amp;a, const void *p)</td></tr>
<tr class="separator:ga426e9be67559cb2153c17f5edbbe5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b22884cc51f81b1faa326659efe5e1d"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga7b22884cc51f81b1faa326659efe5e1d">simdpp::load</a> (float32x4 &amp;a, const float *p)</td></tr>
<tr class="separator:ga7b22884cc51f81b1faa326659efe5e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7fb00eae1b3b4a0661c3587270bb8ea"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#gaf7fb00eae1b3b4a0661c3587270bb8ea">simdpp::load</a> (float32x8 &amp;a, const float *p)</td></tr>
<tr class="separator:gaf7fb00eae1b3b4a0661c3587270bb8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ac5b961c2da9871022d515ade4c88c6"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga2ac5b961c2da9871022d515ade4c88c6">simdpp::load</a> (float64x2 &amp;a, const double *p)</td></tr>
<tr class="separator:ga2ac5b961c2da9871022d515ade4c88c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e9e844c6debd344f47183b37850b1f"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#gaf1e9e844c6debd344f47183b37850b1f">simdpp::load</a> (float64x4 &amp;a, const double *p)</td></tr>
<tr class="separator:gaf1e9e844c6debd344f47183b37850b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab348d355cc67cccc1c15a56d6c5e576"><td class="memItemLeft" align="right" valign="top">basic_int8x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#gaab348d355cc67cccc1c15a56d6c5e576">simdpp::load_u</a> (basic_int8x16 &amp;a, const void *p)</td></tr>
<tr class="memdesc:gaab348d355cc67cccc1c15a56d6c5e576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#gaab348d355cc67cccc1c15a56d6c5e576">More...</a><br/></td></tr>
<tr class="separator:gaab348d355cc67cccc1c15a56d6c5e576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a95af1a40f4ca965a0801fd0cbe36ed"><td class="memItemLeft" align="right" valign="top">basic_int16x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga7a95af1a40f4ca965a0801fd0cbe36ed">simdpp::load_u</a> (basic_int16x8 &amp;a, const void *p)</td></tr>
<tr class="memdesc:ga7a95af1a40f4ca965a0801fd0cbe36ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga7a95af1a40f4ca965a0801fd0cbe36ed">More...</a><br/></td></tr>
<tr class="separator:ga7a95af1a40f4ca965a0801fd0cbe36ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a626f3403d34757790c5a039ab2d9d3"><td class="memItemLeft" align="right" valign="top">basic_int32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga0a626f3403d34757790c5a039ab2d9d3">simdpp::load_u</a> (basic_int32x4 &amp;a, const void *p)</td></tr>
<tr class="memdesc:ga0a626f3403d34757790c5a039ab2d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga0a626f3403d34757790c5a039ab2d9d3">More...</a><br/></td></tr>
<tr class="separator:ga0a626f3403d34757790c5a039ab2d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d532ea37b95794ef966dfd0c007ec2"><td class="memItemLeft" align="right" valign="top">basic_int64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#gab8d532ea37b95794ef966dfd0c007ec2">simdpp::load_u</a> (basic_int64x2 &amp;a, const void *p)</td></tr>
<tr class="memdesc:gab8d532ea37b95794ef966dfd0c007ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#gab8d532ea37b95794ef966dfd0c007ec2">More...</a><br/></td></tr>
<tr class="separator:gab8d532ea37b95794ef966dfd0c007ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966ab5b7e334444ef866e969c1ff8178"><td class="memItemLeft" align="right" valign="top">float32x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga966ab5b7e334444ef866e969c1ff8178">simdpp::load_u</a> (float32x4 &amp;a, const float *p)</td></tr>
<tr class="memdesc:ga966ab5b7e334444ef866e969c1ff8178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga966ab5b7e334444ef866e969c1ff8178">More...</a><br/></td></tr>
<tr class="separator:ga966ab5b7e334444ef866e969c1ff8178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5da7397af8de0956cbe00924940eb1"><td class="memItemLeft" align="right" valign="top">float64x2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga5e5da7397af8de0956cbe00924940eb1">simdpp::load_u</a> (float64x2 &amp;a, const double *p)</td></tr>
<tr class="memdesc:ga5e5da7397af8de0956cbe00924940eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga5e5da7397af8de0956cbe00924940eb1">More...</a><br/></td></tr>
<tr class="separator:ga5e5da7397af8de0956cbe00924940eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4365b724e9d5cb2fa994113de69293"><td class="memItemLeft" align="right" valign="top">basic_int8x32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga6a4365b724e9d5cb2fa994113de69293">simdpp::load_u</a> (basic_int8x32 &amp;a, const void *p)</td></tr>
<tr class="memdesc:ga6a4365b724e9d5cb2fa994113de69293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga6a4365b724e9d5cb2fa994113de69293">More...</a><br/></td></tr>
<tr class="separator:ga6a4365b724e9d5cb2fa994113de69293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903cec570bf6b3d068b87b88d3148820"><td class="memItemLeft" align="right" valign="top">basic_int16x16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga903cec570bf6b3d068b87b88d3148820">simdpp::load_u</a> (basic_int16x16 &amp;a, const void *p)</td></tr>
<tr class="memdesc:ga903cec570bf6b3d068b87b88d3148820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga903cec570bf6b3d068b87b88d3148820">More...</a><br/></td></tr>
<tr class="separator:ga903cec570bf6b3d068b87b88d3148820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cfdda5496ea32c36ae97ee3eae2617"><td class="memItemLeft" align="right" valign="top">basic_int32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga00cfdda5496ea32c36ae97ee3eae2617">simdpp::load_u</a> (basic_int32x8 &amp;a, const void *p)</td></tr>
<tr class="memdesc:ga00cfdda5496ea32c36ae97ee3eae2617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga00cfdda5496ea32c36ae97ee3eae2617">More...</a><br/></td></tr>
<tr class="separator:ga00cfdda5496ea32c36ae97ee3eae2617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf60cd4354c42b5cbc547beb071dfd87"><td class="memItemLeft" align="right" valign="top">basic_int64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#gadf60cd4354c42b5cbc547beb071dfd87">simdpp::load_u</a> (basic_int64x4 &amp;a, const void *p)</td></tr>
<tr class="memdesc:gadf60cd4354c42b5cbc547beb071dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#gadf60cd4354c42b5cbc547beb071dfd87">More...</a><br/></td></tr>
<tr class="separator:gadf60cd4354c42b5cbc547beb071dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8374e854487d8bb849912b27e0d54ba6"><td class="memItemLeft" align="right" valign="top">float32x8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga8374e854487d8bb849912b27e0d54ba6">simdpp::load_u</a> (float32x8 &amp;a, const float *p)</td></tr>
<tr class="memdesc:ga8374e854487d8bb849912b27e0d54ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga8374e854487d8bb849912b27e0d54ba6">More...</a><br/></td></tr>
<tr class="separator:ga8374e854487d8bb849912b27e0d54ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337c1a4e3102382d9b722b86b5e3c890"><td class="memItemLeft" align="right" valign="top">float64x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga337c1a4e3102382d9b722b86b5e3c890">simdpp::load_u</a> (float64x4 &amp;a, const double *p)</td></tr>
<tr class="memdesc:ga337c1a4e3102382d9b722b86b5e3c890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#ga337c1a4e3102382d9b722b86b5e3c890">More...</a><br/></td></tr>
<tr class="separator:ga337c1a4e3102382d9b722b86b5e3c890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a7fcf57d89d617388eae5887543530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga51a7fcf57d89d617388eae5887543530">simdpp::load_packed2</a> (basic_int8x16 &amp;a, basic_int8x16 &amp;b, const void *p)</td></tr>
<tr class="memdesc:ga51a7fcf57d89d617388eae5887543530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 8-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#ga51a7fcf57d89d617388eae5887543530">More...</a><br/></td></tr>
<tr class="separator:ga51a7fcf57d89d617388eae5887543530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7969b0735a32b2d03d9b54a762af47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga2b7969b0735a32b2d03d9b54a762af47">simdpp::load_packed2</a> (basic_int8x32 &amp;a, basic_int8x32 &amp;b, const void *p)</td></tr>
<tr class="memdesc:ga2b7969b0735a32b2d03d9b54a762af47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 8-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#ga2b7969b0735a32b2d03d9b54a762af47">More...</a><br/></td></tr>
<tr class="separator:ga2b7969b0735a32b2d03d9b54a762af47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae61099f431ee838d287ba32d03aa8e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#gae61099f431ee838d287ba32d03aa8e06">simdpp::load_packed2</a> (basic_int16x8 &amp;a, basic_int16x8 &amp;b, const void *p)</td></tr>
<tr class="memdesc:gae61099f431ee838d287ba32d03aa8e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 16-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#gae61099f431ee838d287ba32d03aa8e06">More...</a><br/></td></tr>
<tr class="separator:gae61099f431ee838d287ba32d03aa8e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9780ee4f8fdb9557dea30190b616e5bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga9780ee4f8fdb9557dea30190b616e5bb">simdpp::load_packed2</a> (basic_int16x16 &amp;a, basic_int16x16 &amp;b, const void *p)</td></tr>
<tr class="memdesc:ga9780ee4f8fdb9557dea30190b616e5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 16-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#ga9780ee4f8fdb9557dea30190b616e5bb">More...</a><br/></td></tr>
<tr class="separator:ga9780ee4f8fdb9557dea30190b616e5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9f5731f9e4186592eaff8acc1089ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga1b9f5731f9e4186592eaff8acc1089ea">simdpp::load_packed2</a> (basic_int32x4 &amp;a, basic_int32x4 &amp;b, const void *p)</td></tr>
<tr class="memdesc:ga1b9f5731f9e4186592eaff8acc1089ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 32-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#ga1b9f5731f9e4186592eaff8acc1089ea">More...</a><br/></td></tr>
<tr class="separator:ga1b9f5731f9e4186592eaff8acc1089ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca019355df2ef6110db0d81289fab75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga9ca019355df2ef6110db0d81289fab75">simdpp::load_packed2</a> (basic_int32x8 &amp;a, basic_int32x8 &amp;b, const void *p)</td></tr>
<tr class="memdesc:ga9ca019355df2ef6110db0d81289fab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 32-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#ga9ca019355df2ef6110db0d81289fab75">More...</a><br/></td></tr>
<tr class="separator:ga9ca019355df2ef6110db0d81289fab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ebaf3cce5caf223f613959e256eba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga27ebaf3cce5caf223f613959e256eba7">simdpp::load_packed2</a> (basic_int64x2 &amp;a, basic_int64x2 &amp;b, const void *p)</td></tr>
<tr class="memdesc:ga27ebaf3cce5caf223f613959e256eba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 64-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#ga27ebaf3cce5caf223f613959e256eba7">More...</a><br/></td></tr>
<tr class="separator:ga27ebaf3cce5caf223f613959e256eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga357a78543ec6d94653ab371ce7ed5ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#ga357a78543ec6d94653ab371ce7ed5ed1">simdpp::load_packed2</a> (basic_int64x4 &amp;a, basic_int64x4 &amp;b, const void *p)</td></tr>
<tr class="memdesc:ga357a78543ec6d94653ab371ce7ed5ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads 64-bit values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#ga357a78543ec6d94653ab371ce7ed5ed1">More...</a><br/></td></tr>
<tr class="separator:ga357a78543ec6d94653ab371ce7ed5ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga03be39688c5e0ebb8d10f8e672bc9de9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int128 simdpp::load </td>
          <td>(</td>
          <td class="paramtype">int128 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an aligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga426e9be67559cb2153c17f5edbbe5c8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int256 simdpp::load </td>
          <td>(</td>
          <td class="paramtype">int256 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7b22884cc51f81b1faa326659efe5e1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::load </td>
          <td>(</td>
          <td class="paramtype">float32x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf7fb00eae1b3b4a0661c3587270bb8ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::load </td>
          <td>(</td>
          <td class="paramtype">float32x8 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2ac5b961c2da9871022d515ade4c88c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::load </td>
          <td>(</td>
          <td class="paramtype">float64x2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf1e9e844c6debd344f47183b37850b1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::load </td>
          <td>(</td>
          <td class="paramtype">float64x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga51a7fcf57d89d617388eae5887543530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x16 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 8-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+30) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+31) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+62) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+63) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b7969b0735a32b2d03d9b54a762af47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int8x32 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 8-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+30) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+31) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+62) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+63) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gae61099f431ee838d287ba32d03aa8e06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x8 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 16-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+14) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+15) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+30) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+31) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9780ee4f8fdb9557dea30190b616e5bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int16x16 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 16-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+14) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+15) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+30) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+31) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b9f5731f9e4186592eaff8acc1089ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x4 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 32-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), *(p+6) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), *(p+7) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+14) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+15) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ca019355df2ef6110db0d81289fab75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int32x8 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 32-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), *(p+6) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), *(p+7) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+14) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+15) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga27ebaf3cce5caf223f613959e256eba7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 64-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2) ]</div>
<div class="line">b = [ *(p+1), *(p+3) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), *(p+14) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), *(p+15) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga357a78543ec6d94653ab371ce7ed5ed1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_int64x4 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads 64-bit values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2) ]</div>
<div class="line">b = [ *(p+1), *(p+3) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 16 bytes.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), *(p+14) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), *(p+15) ]</div>
</div><!-- fragment --> <em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab348d355cc67cccc1c15a56d6c5e576"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x16 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int8x16 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga7a95af1a40f4ca965a0801fd0cbe36ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x8 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga0a626f3403d34757790c5a039ab2d9d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x4 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int32x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gab8d532ea37b95794ef966dfd0c007ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x2 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int64x2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga966ab5b7e334444ef866e969c1ff8178"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">float32x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga5e5da7397af8de0956cbe00924940eb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x2 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">float64x2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga6a4365b724e9d5cb2fa994113de69293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int8x32 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int8x32 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga903cec570bf6b3d068b87b88d3148820"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int16x16 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga00cfdda5496ea32c36ae97ee3eae2617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int32x8 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int32x8 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="gadf60cd4354c42b5cbc547beb071dfd87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basic_int64x4 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">basic_int64x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga8374e854487d8bb849912b27e0d54ba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x8 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">float32x8 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="ga337c1a4e3102382d9b722b86b5e3c890"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float64x4 simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">float64x4 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 17 2013 03:50:36 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</div>
</body>
</html>
