<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>libsimdpp: expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="main">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">expressions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>&#160;&#160;&#160;&#160;This is internal documentation</p>
<p>This file documents the expression types returned by various functions in the library.</p>
<p>In a perfect world an expression would be composed using the argument types without any conversions. That is, for example, the prototype of <code>add</code> function would look something like this:</p>
<p>template&lt;unsigned N, class V1, class V2&gt; typename get_expr2_nomask&lt;V1, V2, expr_add&lt;V1, V2&gt;&gt;::type add(const any_int8&lt;N,V1&gt;&amp;, const any_int8&lt;N,V2&gt;&amp;);</p>
<p>Unfortunately, this function returns different type for each combinations of V1 and V2. Given that V1 and V2 each may one of <code>int8</code>, <code>uint8</code> and <code>mask_int8</code>, we will need to implement 9 different cases in the expression evaluator when ideally only one case should be needed as the implementation is the same in each case. It's obvious that this approach is not sustainable if we want to take advantage of any micro-optimizations made possible by expresion templates.</p>
<p>The solution that is employed throughout the library is to convert V1 and V2 to a reduced set of vector/expression type combinations when building the expression tree. Then in the expression evaluator we only need to match that reduced set of vector/expression types. Most of the time that set only needs to be as large as there are different type combinations we want different behavious for. For example, in the <code>add</code> case we can convert both V1 and V2 to <code>uint8</code> without losing usable information, whereas in the case of <code>blend</code> we need 18 cases.</p>
<p>The following list documents the types that may be returned by different functions. Only functions that return non-empty expression are documented.</p>
<p>bit_and, bit_andnot:</p>
<ul>
<li><code>expr_bit_{and,andnot}&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>uint8, uint8</li>
<li>uint8, mask_int8</li>
<li>mask_int8, mask_int8</li>
<li>uint16, uint16</li>
<li>uint16, mask_int16</li>
<li>mask_int16, mask_int16</li>
<li>uint32, uint32</li>
<li>uint32, mask_int32</li>
<li>mask_int32, mask_int32</li>
<li>uint64, uint64</li>
<li>uint64, mask_int64</li>
<li>mask_int64, mask_int64</li>
<li>float32, float32</li>
<li>float32, mask_float32</li>
<li>mask_float32, mask_float32</li>
<li>float64, float64</li>
<li>float64, mask_float64</li>
<li>mask_float64, mask_float64</li>
</ul>
</li>
</ul>
<p>bit_or:</p>
<ul>
<li><code>expr_bit_or&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>mask_int8, mask_int8</li>
<li>uint8, uint8</li>
<li>mask_int16, mask_int16</li>
<li>uint16, uint16</li>
<li>mask_int32, mask_int32</li>
<li>uint32, uint32</li>
<li>mask_int64, mask_int64</li>
<li>uint64, uint64</li>
<li>mask_float32, mask_float32</li>
<li>float32, float32</li>
<li>mask_float64, mask_float64</li>
<li>float64, float64</li>
</ul>
</li>
</ul>
<p>bit_xor (TODO, not implemented yet) bit_not (TODO, not implemented yet)</p>
<p>blend</p>
<ul>
<li><code>expr_blend&lt;V1,V2,V3&gt;</code>, where V1,V2,V3 is one of:<ul>
<li>mask_int8, mask_int8, mask_int8</li>
<li>uint8, uint8, uint8</li>
<li>uint8, uint8, mask_int8</li>
<li>mask_int16, mask_int16, mask_int16</li>
<li>uint16, uint16, uint16</li>
<li>uint16, uint16, mask_uint16</li>
<li>mask_int32, mask_int32, mask_int32</li>
<li>mask_float32, mask_float32, mask_float32</li>
<li>uint32, uint32, uint32</li>
<li>uint32, uint32, mask_int32</li>
<li>float32, float32, float32</li>
<li>float32, float32, mask_float32</li>
<li>mask_int64, mask_int64, mask_int64</li>
<li>mask_float64, mask_float64, mask_float64</li>
<li>uint64, uint64, uint64</li>
<li>uint64, uint64, mask_int64</li>
<li>float64, float64, float64</li>
<li>float64, float64, mask_float64</li>
</ul>
</li>
</ul>
<p>abs</p>
<ul>
<li><code>expr_abs&lt;V1&gt;</code>, where V1 is one of:<ul>
<li>int8</li>
<li>int16</li>
<li>int32</li>
<li>int64</li>
<li>float32</li>
<li>float64</li>
</ul>
</li>
</ul>
<p>add</p>
<ul>
<li><code>expr_add&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>uint8, uint8</li>
<li>uint16, uint16</li>
<li>uint32, uint32</li>
<li>uint64, uint64</li>
<li>float32, float32</li>
<li>float64, float64</li>
</ul>
</li>
</ul>
<p>add_sat</p>
<ul>
<li><code>expr_add_sat&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>uint8, uint8</li>
<li>int8, int8</li>
<li>uint16, uint16</li>
<li>int16, int16</li>
</ul>
</li>
</ul>
<p>fmadd</p>
<ul>
<li><code>expr_fmadd&lt;V1,V2,V3&gt;</code>, where V1,V2,V3 is one of:<ul>
<li>float32, float32, float32</li>
<li>float64, float64, float64</li>
</ul>
</li>
</ul>
<p>fmsub</p>
<ul>
<li><code>expr_fmsub&lt;V1,V2,V3&gt;</code>, where V1,V2,V3 is one of:<ul>
<li>float32, float32, float32</li>
<li>float64, float64, float64</li>
</ul>
</li>
</ul>
<p>mul</p>
<ul>
<li><code>expr_mul&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>float32, float32</li>
<li>float64, float64</li>
</ul>
</li>
</ul>
<p>mull</p>
<ul>
<li><code>expr_mull&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>uint16, uint16</li>
<li>int16, int16</li>
<li>uint32, uint32</li>
<li>int32, int32</li>
</ul>
</li>
</ul>
<p>mul_lo</p>
<ul>
<li><code>expr_mul_lo&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>uint16, uint16</li>
<li>uint32, uint32</li>
</ul>
</li>
</ul>
<p>mul_hi</p>
<ul>
<li><code>expr_mul_hi&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>int16, int16</li>
<li>uint16, uint16</li>
</ul>
</li>
</ul>
<p>neg</p>
<ul>
<li><code>expr_neg&lt;V1&gt;</code>, where V1 is one of:<ul>
<li>int8</li>
<li>int16</li>
<li>int32</li>
<li>int64</li>
<li>float32</li>
<li>float64</li>
</ul>
</li>
</ul>
<p>sub</p>
<ul>
<li><code>expr_sub&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>uint8, uint8</li>
<li>uint16, uint16</li>
<li>uint32, uint32</li>
<li>uint64, uint64</li>
<li>float32, float32</li>
<li>float64, float64</li>
</ul>
</li>
</ul>
<p>sub_sat</p>
<ul>
<li><code>expr_sub_sat&lt;V1,V2&gt;</code>, where V1,V2 is one of:<ul>
<li>uint8, uint8</li>
<li>int8, int8</li>
<li>uint16, uint16</li>
<li>int16, int16 </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 8 2014 03:14:34 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</div>
</body>
</html>
