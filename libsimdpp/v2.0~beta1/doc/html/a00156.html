<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>libsimdpp: simdpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="main">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">simdpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00410"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00410.html">altivec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00414"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00414.html">neon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00415"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00415.html">sse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator that allocates memory with stricter alignment requirements than the defaults.  <a href="a00032.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">expr_bit_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">expr_bit_andnot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">expr_bit_not</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">expr_bit_or</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">expr_bit_xor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">expr_blend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">expr_splat2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">expr_splat4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">expr_splat8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">expr_splat16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">expr_vec_construct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">expr_vec_load_splat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">expr_vec_set_splat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">expr_vec_make_const</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">expr_vec_load</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">expr_vec_load_u</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">expr_add</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">expr_add_sat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">expr_sub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">expr_sub_sat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">expr_abs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">expr_neg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">expr_mul</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">expr_mul_lo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">expr_mul_hi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">expr_mull</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">expr_fmadd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">expr_fmsub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">expr_imm_shift_l</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">expr_imm_shift_r</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">any_vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents any vector that has <em>B</em> bytes of data.  <a href="a00018.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">any_vec8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">any_vec16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">any_vec32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">any_vec64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">any_float32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">any_float64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">any_int8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">any_int16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">any_int32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">any_int64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">float32&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a <em><a class="el" href="a00020.html">float32</a></em> vector of arbitrary length.  <a href="a00065.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">mask_float32&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a mask for 32-bit floating-point vector of arbitrary length.  <a href="a00107.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">float32&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing float32x4 vector.  <a href="a00063.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">mask_float32&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 4x 32-bit floating-point vector.  <a href="a00105.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">float32&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing float32x8 vector.  <a href="a00064.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">mask_float32&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 4x 32-bit floating-point vector.  <a href="a00106.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">float64&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a <em><a class="el" href="a00021.html">float64</a></em> vector of arbitrary length.  <a href="a00068.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">mask_float64&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 2x 64-bit floating point vector.  <a href="a00110.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">float64&lt; 2, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">mask_float64&lt; 2, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 2x 64-bit floating point vector.  <a href="a00108.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">float64&lt; 4, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">mask_float64&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 2x 64-bit floating point vector.  <a href="a00109.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">float32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">mask_float32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">float64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">mask_float64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">int8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">uint8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">mask_int8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">int16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">uint16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">mask_int16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">int32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">uint32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">mask_int32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">int64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">uint64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">mask_int64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">int16&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an signed <em><a class="el" href="a00022.html">int16</a></em> vector of arbitrary length.  <a href="a00071.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">uint16&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an unsigned <em><a class="el" href="a00022.html">int16</a></em> vector of arbitrary length.  <a href="a00126.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">mask_int16&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a mask for 16-bit integer vector of arbitrary length.  <a href="a00113.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">int16&lt; 16, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 16x 16-bit signed integer vector.  <a href="a00069.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">uint16&lt; 16, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 16x 16-bit unsigned integer vector.  <a href="a00124.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">mask_int16&lt; 16, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 8x 16-bit integer vector.  <a href="a00111.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">int16&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 8x 16-bit signed integer vector.  <a href="a00070.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">uint16&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 8x 16-bit unsigned integer vector.  <a href="a00125.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">mask_int16&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 8x 16-bit integer vector.  <a href="a00112.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">int32&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an signed <em><a class="el" href="a00024.html">int64</a></em> vector of arbitrary length.  <a href="a00074.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">uint32&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an unsigned <em><a class="el" href="a00023.html">int32</a></em> vector of arbitrary length.  <a href="a00130.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">mask_int32&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a mask for 32-bit integer vector of arbitrary length.  <a href="a00116.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">int32&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 4x 32-bit signed integer vector.  <a href="a00072.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">uint32&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 4x 32-bit unsigned integer vector.  <a href="a00128.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">mask_int32&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 4x 32-bit integer vector.  <a href="a00114.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">int32&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 8x 32-bit signed integer vector.  <a href="a00073.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">uint32&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 8x 32-bit unsigned integer vector.  <a href="a00129.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">mask_int32&lt; 8, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 4x 32-bit integer vector.  <a href="a00115.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">int64&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an signed <em><a class="el" href="a00024.html">int64</a></em> vector of arbitrary length.  <a href="a00077.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">uint64&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an unsigned <em><a class="el" href="a00024.html">int64</a></em> vector of arbitrary length.  <a href="a00134.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">mask_int64&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a mask for 64-bit integer vector of arbitrary length.  <a href="a00119.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">int64&lt; 2, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 2x 64-bit signed integer vector.  <a href="a00075.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">uint64&lt; 2, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 2x 64-bit unsigned integer vector.  <a href="a00132.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">mask_int64&lt; 2, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 2x 64-bit integer vector.  <a href="a00117.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">int64&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 4x 64-bit signed integer vector.  <a href="a00076.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">uint64&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 4x 64-bit unsigned integer vector.  <a href="a00133.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">mask_int64&lt; 4, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 4x 64-bit integer vector.  <a href="a00118.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">int8&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an signed <em><a class="el" href="a00025.html">int8</a></em> vector of arbitrary length.  <a href="a00080.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">uint8&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an unsigned <em><a class="el" href="a00025.html">int8</a></em> vector of arbitrary length.  <a href="a00138.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">mask_int8&lt; N, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a mask for 8-bit integer vector of arbitrary length.  <a href="a00122.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">int8&lt; 16, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 16x 8-bit signed integer vector.  <a href="a00078.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">uint8&lt; 16, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 16x 8-bit unsigned integer vector.  <a href="a00136.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">mask_int8&lt; 16, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 16x 8-bit integer vector.  <a href="a00120.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">int8&lt; 32, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 32x 8-bit signed integer vector.  <a href="a00079.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">uint8&lt; 32, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing 32x 8-bit unsigned integer vector.  <a href="a00137.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">mask_int8&lt; 32, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing possibly optimized mask data for 16x 8-bit integer vector.  <a href="a00121.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">is_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows detection whether specific type is a simdpp vector.  <a href="a00088.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">is_vector&lt; float32&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">is_vector&lt; float64&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">is_vector&lt; int8&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">is_vector&lt; int16&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">is_vector&lt; int32&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">is_vector&lt; int64&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">is_vector&lt; uint8&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">is_vector&lt; uint16&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">is_vector&lt; uint32&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">is_vector&lt; uint64&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">is_vector&lt; mask_int8&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">is_vector&lt; mask_int16&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">is_vector&lt; mask_int32&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">is_vector&lt; mask_int64&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">is_vector&lt; mask_float32&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">is_vector&lt; mask_float64&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">is_mask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows detection whether specific type is a simdpp mask.  <a href="a00081.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">is_mask&lt; mask_int8&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">is_mask&lt; mask_int16&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">is_mask&lt; mask_int32&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">is_mask&lt; mask_int64&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">is_mask&lt; mask_float32&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">is_mask&lt; mask_float64&lt; N, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga57def3fe13811aa13957a7c36bdcd02d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#ga57def3fe13811aa13957a7c36bdcd02d">GetArchCb</a> = std::function&lt; <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a>()&gt;</td></tr>
<tr class="separator:ga57def3fe13811aa13957a7c36bdcd02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2892535dd751dc65998ffb71e1aaeb8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> = <a class="el" href="a00020.html">float32</a>&lt; 4 &gt;</td></tr>
<tr class="separator:ab2892535dd751dc65998ffb71e1aaeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf873a9926daeeb1ca3a4d94aa0beb15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> = <a class="el" href="a00020.html">float32</a>&lt; 8 &gt;</td></tr>
<tr class="separator:adf873a9926daeeb1ca3a4d94aa0beb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623fb0bc7684000397d1210d7a7f55ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a623fb0bc7684000397d1210d7a7f55ef">mask_float32x4</a> = <a class="el" href="a00026.html">mask_float32</a>&lt; 4 &gt;</td></tr>
<tr class="separator:a623fb0bc7684000397d1210d7a7f55ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9b76b6b6f66f996f6097e693c139a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a6d9b76b6b6f66f996f6097e693c139a9">mask_float32x8</a> = <a class="el" href="a00026.html">mask_float32</a>&lt; 8 &gt;</td></tr>
<tr class="separator:a6d9b76b6b6f66f996f6097e693c139a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcdb04bee0301a502678b15b613cdc2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a> = <a class="el" href="a00021.html">float64</a>&lt; 2 &gt;</td></tr>
<tr class="separator:abdcdb04bee0301a502678b15b613cdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6da1e3ea4a68551086bddb9c0f54f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> = <a class="el" href="a00021.html">float64</a>&lt; 4 &gt;</td></tr>
<tr class="separator:a5c6da1e3ea4a68551086bddb9c0f54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de241f18e59796c7e25255458997c56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a7de241f18e59796c7e25255458997c56">mask_float64x2</a> = <a class="el" href="a00027.html">mask_float64</a>&lt; 2 &gt;</td></tr>
<tr class="separator:a7de241f18e59796c7e25255458997c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae538ea7c8001934e9d4d048a2894274c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ae538ea7c8001934e9d4d048a2894274c">mask_float64x4</a> = <a class="el" href="a00027.html">mask_float64</a>&lt; 4 &gt;</td></tr>
<tr class="separator:ae538ea7c8001934e9d4d048a2894274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bf64e6f29bfddf2a8c9036c8755132"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> = <a class="el" href="a00025.html">int8</a>&lt; 16 &gt;</td></tr>
<tr class="separator:a04bf64e6f29bfddf2a8c9036c8755132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2056b5479d97aa816fa946eb925fca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> = <a class="el" href="a00025.html">int8</a>&lt; 32 &gt;</td></tr>
<tr class="separator:a7b2056b5479d97aa816fa946eb925fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f89eaaf7f8fcd3a69ed31e17a1846d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> = <a class="el" href="a00135.html">uint8</a>&lt; 16 &gt;</td></tr>
<tr class="separator:a4f89eaaf7f8fcd3a69ed31e17a1846d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cc2e646e03b2e3f7b97394d1863140"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> = <a class="el" href="a00135.html">uint8</a>&lt; 32 &gt;</td></tr>
<tr class="separator:ad7cc2e646e03b2e3f7b97394d1863140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed4ceaf3feaf7e671f5c00326214562"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a3ed4ceaf3feaf7e671f5c00326214562">mask_int8x16</a> = <a class="el" href="a00031.html">mask_int8</a>&lt; 16 &gt;</td></tr>
<tr class="separator:a3ed4ceaf3feaf7e671f5c00326214562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374a871711d189080d701faa471f6472"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a374a871711d189080d701faa471f6472">mask_int8x32</a> = <a class="el" href="a00031.html">mask_int8</a>&lt; 32 &gt;</td></tr>
<tr class="separator:a374a871711d189080d701faa471f6472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2e24bda9b4fc2e661f92f428d66338"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> = <a class="el" href="a00022.html">int16</a>&lt; 8 &gt;</td></tr>
<tr class="separator:a3b2e24bda9b4fc2e661f92f428d66338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873c12cd4e0429754b8ec03d501221d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> = <a class="el" href="a00022.html">int16</a>&lt; 16 &gt;</td></tr>
<tr class="separator:a873c12cd4e0429754b8ec03d501221d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a21291847f6b893d9b965695fdb939"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> = <a class="el" href="a00123.html">uint16</a>&lt; 8 &gt;</td></tr>
<tr class="separator:a12a21291847f6b893d9b965695fdb939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f51af32fa2f6caf3538118beb1beeb1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> = <a class="el" href="a00123.html">uint16</a>&lt; 16 &gt;</td></tr>
<tr class="separator:a6f51af32fa2f6caf3538118beb1beeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcb15d216074f5e91dc6139ec8a2d3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a2dcb15d216074f5e91dc6139ec8a2d3b">mask_int16x8</a> = <a class="el" href="a00028.html">mask_int16</a>&lt; 8 &gt;</td></tr>
<tr class="separator:a2dcb15d216074f5e91dc6139ec8a2d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c93f6b1edd3291a9f12fc6426f0f18b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a0c93f6b1edd3291a9f12fc6426f0f18b">mask_int16x16</a> = <a class="el" href="a00028.html">mask_int16</a>&lt; 16 &gt;</td></tr>
<tr class="separator:a0c93f6b1edd3291a9f12fc6426f0f18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58023c756757d023687e5daa41f3be4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> = <a class="el" href="a00023.html">int32</a>&lt; 4 &gt;</td></tr>
<tr class="separator:ad58023c756757d023687e5daa41f3be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c0263ee6d69f8fe2891c69359440ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> = <a class="el" href="a00023.html">int32</a>&lt; 8 &gt;</td></tr>
<tr class="separator:ae3c0263ee6d69f8fe2891c69359440ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20dd929c7688955c0420f9ad159df0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> = <a class="el" href="a00127.html">uint32</a>&lt; 4 &gt;</td></tr>
<tr class="separator:ac20dd929c7688955c0420f9ad159df0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19715f058184b65e0250d37e82d7204d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> = <a class="el" href="a00127.html">uint32</a>&lt; 8 &gt;</td></tr>
<tr class="separator:a19715f058184b65e0250d37e82d7204d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc414746dc4bd8956bd8285b8cb4221"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a3fc414746dc4bd8956bd8285b8cb4221">mask_int32x4</a> = <a class="el" href="a00029.html">mask_int32</a>&lt; 4 &gt;</td></tr>
<tr class="separator:a3fc414746dc4bd8956bd8285b8cb4221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07afbc5eed207d25d4ab52ae0e5e8d0f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a07afbc5eed207d25d4ab52ae0e5e8d0f">mask_int32x8</a> = <a class="el" href="a00029.html">mask_int32</a>&lt; 8 &gt;</td></tr>
<tr class="separator:a07afbc5eed207d25d4ab52ae0e5e8d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fea5c7167ea63298fe297c499d9814"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a44fea5c7167ea63298fe297c499d9814">int64x2</a> = <a class="el" href="a00024.html">int64</a>&lt; 2 &gt;</td></tr>
<tr class="separator:a44fea5c7167ea63298fe297c499d9814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da9597a0403650325e7b0df8893d6a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a8da9597a0403650325e7b0df8893d6a3">int64x4</a> = <a class="el" href="a00024.html">int64</a>&lt; 4 &gt;</td></tr>
<tr class="separator:a8da9597a0403650325e7b0df8893d6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fa6bce9edc39f1e33381101cb60296"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a> = <a class="el" href="a00131.html">uint64</a>&lt; 2 &gt;</td></tr>
<tr class="separator:a88fa6bce9edc39f1e33381101cb60296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6695b8dbe92c54e1fc4844174b4623ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a> = <a class="el" href="a00131.html">uint64</a>&lt; 4 &gt;</td></tr>
<tr class="separator:a6695b8dbe92c54e1fc4844174b4623ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe369fb0f0f3a6c93fbedd06ad6c426"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#abbe369fb0f0f3a6c93fbedd06ad6c426">mask_int64x2</a> = <a class="el" href="a00030.html">mask_int64</a>&lt; 2 &gt;</td></tr>
<tr class="separator:abbe369fb0f0f3a6c93fbedd06ad6c426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4fab13b2225dbbb5f5f6ed58995203"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aff4fab13b2225dbbb5f5f6ed58995203">mask_int64x4</a> = <a class="el" href="a00030.html">mask_int64</a>&lt; 4 &gt;</td></tr>
<tr class="separator:aff4fab13b2225dbbb5f5f6ed58995203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5876ca85abbab40fa7ed12e91546f774"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a5876ca85abbab40fa7ed12e91546f774">float32v</a> = <a class="el" href="a00020.html">float32</a>&lt; SIMDPP_FAST_FLOAT32_SIZE &gt;</td></tr>
<tr class="separator:a5876ca85abbab40fa7ed12e91546f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae434b87dace1c712306c8817176df849"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ae434b87dace1c712306c8817176df849">mask_float32v</a> = <a class="el" href="a00026.html">mask_float32</a>&lt; SIMDPP_FAST_FLOAT32_SIZE &gt;</td></tr>
<tr class="separator:ae434b87dace1c712306c8817176df849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7a460b6530460c48ccd3997c83a220"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a0d7a460b6530460c48ccd3997c83a220">float64v</a> = <a class="el" href="a00021.html">float64</a>&lt; SIMDPP_FAST_FLOAT64_SIZE &gt;</td></tr>
<tr class="separator:a0d7a460b6530460c48ccd3997c83a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2441ca0ef219e14741d5b8f1570ea1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a5e2441ca0ef219e14741d5b8f1570ea1">mask_float64v</a> = <a class="el" href="a00027.html">mask_float64</a>&lt; SIMDPP_FAST_FLOAT64_SIZE &gt;</td></tr>
<tr class="separator:a5e2441ca0ef219e14741d5b8f1570ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802cec15d01221d578bb508369310129"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a802cec15d01221d578bb508369310129">int8v</a> = <a class="el" href="a00025.html">int8</a>&lt; SIMDPP_FAST_INT8_SIZE &gt;</td></tr>
<tr class="separator:a802cec15d01221d578bb508369310129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be0fb2aa42c9b52d37cc53373f7fac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a68be0fb2aa42c9b52d37cc53373f7fac">uint8v</a> = <a class="el" href="a00135.html">uint8</a>&lt; SIMDPP_FAST_INT8_SIZE &gt;</td></tr>
<tr class="separator:a68be0fb2aa42c9b52d37cc53373f7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ce6192aea042064558f2c756d66520"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ad1ce6192aea042064558f2c756d66520">mask_int8v</a> = <a class="el" href="a00031.html">mask_int8</a>&lt; SIMDPP_FAST_INT8_SIZE &gt;</td></tr>
<tr class="separator:ad1ce6192aea042064558f2c756d66520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab051b76cb6f5d602d27c750be7e3235f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ab051b76cb6f5d602d27c750be7e3235f">int16v</a> = <a class="el" href="a00022.html">int16</a>&lt; SIMDPP_FAST_INT16_SIZE &gt;</td></tr>
<tr class="separator:ab051b76cb6f5d602d27c750be7e3235f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1141a320bfb7f8e5e12c179342fc4763"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a1141a320bfb7f8e5e12c179342fc4763">uint16v</a> = <a class="el" href="a00123.html">uint16</a>&lt; SIMDPP_FAST_INT16_SIZE &gt;</td></tr>
<tr class="separator:a1141a320bfb7f8e5e12c179342fc4763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82044d10f10df4cc0948c380ac1e5357"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a82044d10f10df4cc0948c380ac1e5357">mask_int16v</a> = <a class="el" href="a00028.html">mask_int16</a>&lt; SIMDPP_FAST_INT16_SIZE &gt;</td></tr>
<tr class="separator:a82044d10f10df4cc0948c380ac1e5357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7764655e6a399e09809cf0ca25f05242"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a7764655e6a399e09809cf0ca25f05242">int32v</a> = <a class="el" href="a00023.html">int32</a>&lt; SIMDPP_FAST_INT32_SIZE &gt;</td></tr>
<tr class="separator:a7764655e6a399e09809cf0ca25f05242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d1ba44382f8277c8235ce6078b5f35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a43d1ba44382f8277c8235ce6078b5f35">uint32v</a> = <a class="el" href="a00127.html">uint32</a>&lt; SIMDPP_FAST_INT32_SIZE &gt;</td></tr>
<tr class="separator:a43d1ba44382f8277c8235ce6078b5f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0e9fa85319c0156a7f47af8bb7b332"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a9d0e9fa85319c0156a7f47af8bb7b332">mask_int32v</a> = <a class="el" href="a00029.html">mask_int32</a>&lt; SIMDPP_FAST_INT32_SIZE &gt;</td></tr>
<tr class="separator:a9d0e9fa85319c0156a7f47af8bb7b332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dde11bc7f9e1954f61e03d6aa6fba2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a94dde11bc7f9e1954f61e03d6aa6fba2">int64v</a> = <a class="el" href="a00024.html">int64</a>&lt; SIMDPP_FAST_INT64_SIZE &gt;</td></tr>
<tr class="separator:a94dde11bc7f9e1954f61e03d6aa6fba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8acafb8d0431e8620d8bf19c093be2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a1e8acafb8d0431e8620d8bf19c093be2">uint64v</a> = <a class="el" href="a00131.html">uint64</a>&lt; SIMDPP_FAST_INT64_SIZE &gt;</td></tr>
<tr class="separator:a1e8acafb8d0431e8620d8bf19c093be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3c5b1ca432d8a5b3fb9074722f514c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a0d3c5b1ca432d8a5b3fb9074722f514c">mask_int64v</a> = <a class="el" href="a00030.html">mask_int64</a>&lt; SIMDPP_FAST_INT64_SIZE &gt;</td></tr>
<tr class="separator:a0d3c5b1ca432d8a5b3fb9074722f514c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b6de057707f9e2587a3d6b0820a35a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a84b6de057707f9e2587a3d6b0820a35a">mask_float32v2</a> = <a class="el" href="a00026.html">mask_float32</a>&lt; SIMDPP_FAST_FLOAT32_SIZE *2 &gt;</td></tr>
<tr class="separator:a84b6de057707f9e2587a3d6b0820a35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b2df7b6d1dffbabce1cfdfb09c278"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a699b2df7b6d1dffbabce1cfdfb09c278">float64v2</a> = <a class="el" href="a00021.html">float64</a>&lt; SIMDPP_FAST_FLOAT64_SIZE *2 &gt;</td></tr>
<tr class="separator:a699b2df7b6d1dffbabce1cfdfb09c278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d4788951be0805bdd72be20ae948a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a54d4788951be0805bdd72be20ae948a0">mask_float64v2</a> = <a class="el" href="a00027.html">mask_float64</a>&lt; SIMDPP_FAST_FLOAT64_SIZE *2 &gt;</td></tr>
<tr class="separator:a54d4788951be0805bdd72be20ae948a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a66fa73d2ef1bcd3ca07be763da07c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a7a66fa73d2ef1bcd3ca07be763da07c5">int8v2</a> = <a class="el" href="a00025.html">int8</a>&lt; SIMDPP_FAST_INT8_SIZE *2 &gt;</td></tr>
<tr class="separator:a7a66fa73d2ef1bcd3ca07be763da07c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fc3277aec19119b9fb01063e809f7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ad1fc3277aec19119b9fb01063e809f7b">uint8v2</a> = <a class="el" href="a00135.html">uint8</a>&lt; SIMDPP_FAST_INT8_SIZE *2 &gt;</td></tr>
<tr class="separator:ad1fc3277aec19119b9fb01063e809f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1243f1cfe0bb3a56bf30db37b80633"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a2b1243f1cfe0bb3a56bf30db37b80633">mask_int8v2</a> = <a class="el" href="a00031.html">mask_int8</a>&lt; SIMDPP_FAST_INT8_SIZE *2 &gt;</td></tr>
<tr class="separator:a2b1243f1cfe0bb3a56bf30db37b80633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b962cd8ac9d6ed8c2ba56ee3fd26610"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a9b962cd8ac9d6ed8c2ba56ee3fd26610">int16v2</a> = <a class="el" href="a00022.html">int16</a>&lt; SIMDPP_FAST_INT16_SIZE *2 &gt;</td></tr>
<tr class="separator:a9b962cd8ac9d6ed8c2ba56ee3fd26610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f595b7686a2519428f8e8792b10d71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a04f595b7686a2519428f8e8792b10d71">uint16v2</a> = <a class="el" href="a00123.html">uint16</a>&lt; SIMDPP_FAST_INT16_SIZE *2 &gt;</td></tr>
<tr class="separator:a04f595b7686a2519428f8e8792b10d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab104cf04a97174f5d47e87a7624a946a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ab104cf04a97174f5d47e87a7624a946a">mask_int16v2</a> = <a class="el" href="a00028.html">mask_int16</a>&lt; SIMDPP_FAST_INT16_SIZE *2 &gt;</td></tr>
<tr class="separator:ab104cf04a97174f5d47e87a7624a946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa579219029d2146bcc6fe2773b1ee2da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aa579219029d2146bcc6fe2773b1ee2da">int32v2</a> = <a class="el" href="a00023.html">int32</a>&lt; SIMDPP_FAST_INT32_SIZE *2 &gt;</td></tr>
<tr class="separator:aa579219029d2146bcc6fe2773b1ee2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819225bbc006f5f405182e6932d6f38c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a819225bbc006f5f405182e6932d6f38c">uint32v2</a> = <a class="el" href="a00127.html">uint32</a>&lt; SIMDPP_FAST_INT32_SIZE *2 &gt;</td></tr>
<tr class="separator:a819225bbc006f5f405182e6932d6f38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f19d048c80311f47be485ccae9854c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a3f19d048c80311f47be485ccae9854c5">mask_int32v2</a> = <a class="el" href="a00029.html">mask_int32</a>&lt; SIMDPP_FAST_INT32_SIZE *2 &gt;</td></tr>
<tr class="separator:a3f19d048c80311f47be485ccae9854c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa351656d6b414873ca95c47d3000d06c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aa351656d6b414873ca95c47d3000d06c">int64v2</a> = <a class="el" href="a00024.html">int64</a>&lt; SIMDPP_FAST_INT64_SIZE *2 &gt;</td></tr>
<tr class="separator:aa351656d6b414873ca95c47d3000d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7bccb6051a3548a7ff956c34c3b05b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a3e7bccb6051a3548a7ff956c34c3b05b">uint64v2</a> = <a class="el" href="a00131.html">uint64</a>&lt; SIMDPP_FAST_INT64_SIZE *2 &gt;</td></tr>
<tr class="separator:a3e7bccb6051a3548a7ff956c34c3b05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdad7b73b52b91867310b79102c22e7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#abdad7b73b52b91867310b79102c22e7d">mask_int64v2</a> = <a class="el" href="a00030.html">mask_int64</a>&lt; SIMDPP_FAST_INT64_SIZE *2 &gt;</td></tr>
<tr class="separator:abdad7b73b52b91867310b79102c22e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf470566815d9760d834f02f3d09126"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aadf470566815d9760d834f02f3d09126">float32v4</a> = <a class="el" href="a00020.html">float32</a>&lt; SIMDPP_FAST_FLOAT32_SIZE *4 &gt;</td></tr>
<tr class="separator:aadf470566815d9760d834f02f3d09126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcafd1349e6e6bee86fee131528ed7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#afcafd1349e6e6bee86fee131528ed7f7">mask_float32v4</a> = <a class="el" href="a00026.html">mask_float32</a>&lt; SIMDPP_FAST_FLOAT32_SIZE *4 &gt;</td></tr>
<tr class="separator:afcafd1349e6e6bee86fee131528ed7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb7e167c35b997a9885a2addb654ccc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a9eb7e167c35b997a9885a2addb654ccc">float64v4</a> = <a class="el" href="a00021.html">float64</a>&lt; SIMDPP_FAST_FLOAT64_SIZE *4 &gt;</td></tr>
<tr class="separator:a9eb7e167c35b997a9885a2addb654ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa400af09a7e4eb2786e1c4b12b1ed54f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aa400af09a7e4eb2786e1c4b12b1ed54f">mask_float64v4</a> = <a class="el" href="a00027.html">mask_float64</a>&lt; SIMDPP_FAST_FLOAT64_SIZE *4 &gt;</td></tr>
<tr class="separator:aa400af09a7e4eb2786e1c4b12b1ed54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3c15b1eab5f199e10f0dbd6d4ae01a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aba3c15b1eab5f199e10f0dbd6d4ae01a">int8v4</a> = <a class="el" href="a00025.html">int8</a>&lt; SIMDPP_FAST_INT8_SIZE *4 &gt;</td></tr>
<tr class="separator:aba3c15b1eab5f199e10f0dbd6d4ae01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fb5ce979e25831856d8bf576760224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a40fb5ce979e25831856d8bf576760224">uint8v4</a> = <a class="el" href="a00135.html">uint8</a>&lt; SIMDPP_FAST_INT8_SIZE *4 &gt;</td></tr>
<tr class="separator:a40fb5ce979e25831856d8bf576760224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0085b660f958a0ecbf2d57567d7b0ff2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a0085b660f958a0ecbf2d57567d7b0ff2">mask_int8v4</a> = <a class="el" href="a00031.html">mask_int8</a>&lt; SIMDPP_FAST_INT8_SIZE *4 &gt;</td></tr>
<tr class="separator:a0085b660f958a0ecbf2d57567d7b0ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc716bce6a3697384fbaff6ab124e0bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#abc716bce6a3697384fbaff6ab124e0bf">int16v4</a> = <a class="el" href="a00022.html">int16</a>&lt; SIMDPP_FAST_INT16_SIZE *4 &gt;</td></tr>
<tr class="separator:abc716bce6a3697384fbaff6ab124e0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e83c21b0f77210dd3a0f31759ec4c67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a2e83c21b0f77210dd3a0f31759ec4c67">uint16v4</a> = <a class="el" href="a00123.html">uint16</a>&lt; SIMDPP_FAST_INT16_SIZE *4 &gt;</td></tr>
<tr class="separator:a2e83c21b0f77210dd3a0f31759ec4c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31112136cdc7f9f5fbd568fee66fa850"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a31112136cdc7f9f5fbd568fee66fa850">mask_int16v4</a> = <a class="el" href="a00028.html">mask_int16</a>&lt; SIMDPP_FAST_INT16_SIZE *4 &gt;</td></tr>
<tr class="separator:a31112136cdc7f9f5fbd568fee66fa850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa507ad3ff49bf66e369038d1286836f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aa507ad3ff49bf66e369038d1286836f5">int32v4</a> = <a class="el" href="a00023.html">int32</a>&lt; SIMDPP_FAST_INT32_SIZE *4 &gt;</td></tr>
<tr class="separator:aa507ad3ff49bf66e369038d1286836f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25b44826cfc85f09fdd955d530a44aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#af25b44826cfc85f09fdd955d530a44aa">uint32v4</a> = <a class="el" href="a00127.html">uint32</a>&lt; SIMDPP_FAST_INT32_SIZE *4 &gt;</td></tr>
<tr class="separator:af25b44826cfc85f09fdd955d530a44aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6b9886ed86d1792d7f1c39b7c599c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a68d6b9886ed86d1792d7f1c39b7c599c">mask_int32v4</a> = <a class="el" href="a00029.html">mask_int32</a>&lt; SIMDPP_FAST_INT32_SIZE *4 &gt;</td></tr>
<tr class="separator:a68d6b9886ed86d1792d7f1c39b7c599c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72098c16c63296a58f29a975c48b0dd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#af72098c16c63296a58f29a975c48b0dd">int64v4</a> = <a class="el" href="a00024.html">int64</a>&lt; SIMDPP_FAST_INT64_SIZE *4 &gt;</td></tr>
<tr class="separator:af72098c16c63296a58f29a975c48b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e5db862943b8d6c9e8a0ada4b11af9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ab3e5db862943b8d6c9e8a0ada4b11af9">uint64v4</a> = <a class="el" href="a00131.html">uint64</a>&lt; SIMDPP_FAST_INT64_SIZE *4 &gt;</td></tr>
<tr class="separator:ab3e5db862943b8d6c9e8a0ada4b11af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320de5f43b0605c2e39ad5523bcc8795"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a320de5f43b0605c2e39ad5523bcc8795">mask_int64v4</a> = <a class="el" href="a00030.html">mask_int64</a>&lt; SIMDPP_FAST_INT64_SIZE *4 &gt;</td></tr>
<tr class="separator:a320de5f43b0605c2e39ad5523bcc8795"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5335c7b7726de1a63a10b2975ad430b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> : std::uint32_t { <br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a91defaee20407d9afa24e2b5951fe050">Arch::NONE_NULL</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a48e87236b81a910d46ff095785afe7c3">Arch::X86_SSE2</a> = 1 &lt;&lt; 1, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a09233b5f84bf85d570cc1a4c7ad4bbbb">Arch::X86_SSE3</a> = 1 &lt;&lt; 2, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4aa483f7f07c159237d38b5af95f789f9a">Arch::X86_SSSE3</a> = 1 &lt;&lt; 3, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4af34beef8886ae794211e8d006ca9f72f">Arch::X86_SSE4_1</a> = 1 &lt;&lt; 4, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a24578c6cc675738b84b96b1c9566e323">Arch::X86_AVX</a> = 1 &lt;&lt; 5, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a1b9441aadd778146e022fba537de7ff7">Arch::X86_AVX2</a> = 1 &lt;&lt; 6, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4ac09fd8a313f5717c27a2f206e6015d8a">Arch::X86_FMA3</a> = 1 &lt;&lt; 7, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a5bbd96dc57c820f97117dce149cdf1c7">Arch::X86_FMA4</a> = 1 &lt;&lt; 8, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4ae598422e84c76a8fc7ecd205ff0739b3">Arch::X86_XOP</a> = 1 &lt;&lt; 9, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a368ac0bda5a399d5046dbb1c746ad22d">Arch::ARM_NEON</a> = 1 &lt;&lt; 0, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4a420f5a04e2c0cf9a62ad9561cd738be7">Arch::ARM_NEON_FLT_SP</a> = 1 &lt;&lt; 1, 
<br/>
&#160;&#160;<a class="el" href="a00420.html#gga5335c7b7726de1a63a10b2975ad430b4ac71a60f037c999416e4fb812e227b8b6">Arch::POWER_ALTIVEC</a> = 1 &lt;&lt; 0
<br/>
 }</td></tr>
<tr class="memdesc:ga5335c7b7726de1a63a10b2975ad430b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies supported instruction set.  <a href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">More...</a><br/></td></tr>
<tr class="separator:ga5335c7b7726de1a63a10b2975ad430b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga70e8935aacb11aca38543fb04c8b7e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga70e8935aacb11aca38543fb04c8b7e6d">transpose2</a> (<a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a0, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a1)</td></tr>
<tr class="memdesc:ga70e8935aacb11aca38543fb04c8b7e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes four 2x2 16-bit matrices within two int16x8 vectors.  <a href="a00417.html#ga70e8935aacb11aca38543fb04c8b7e6d">More...</a><br/></td></tr>
<tr class="separator:ga70e8935aacb11aca38543fb04c8b7e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae313988174bfeaa378a22542be53d352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gae313988174bfeaa378a22542be53d352">transpose2</a> (<a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a0, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a1)</td></tr>
<tr class="separator:gae313988174bfeaa378a22542be53d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeec4095c328a20e7ba9b05ea22df792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gaeeec4095c328a20e7ba9b05ea22df792">transpose2</a> (<a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a0, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a1)</td></tr>
<tr class="separator:gaeeec4095c328a20e7ba9b05ea22df792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13dfaf749010bfdcdb6c91618de87d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga13dfaf749010bfdcdb6c91618de87d6b">transpose2</a> (<a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a0, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a1)</td></tr>
<tr class="separator:ga13dfaf749010bfdcdb6c91618de87d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d294796f2ecda646bb33da6fabf191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gac0d294796f2ecda646bb33da6fabf191">transpose8</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a0, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a1, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a2, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a3, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a4, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a5, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a6, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a7)</td></tr>
<tr class="memdesc:gac0d294796f2ecda646bb33da6fabf191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 8x8 8-bit matrices within eight int8x16 vectors.  <a href="a00417.html#gac0d294796f2ecda646bb33da6fabf191">More...</a><br/></td></tr>
<tr class="separator:gac0d294796f2ecda646bb33da6fabf191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1227cb9ac8b340b48d28a2826d0573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga3d1227cb9ac8b340b48d28a2826d0573">transpose8</a> (<a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a0, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a1, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a2, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a3, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a4, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a5, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a6, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a7)</td></tr>
<tr class="separator:ga3d1227cb9ac8b340b48d28a2826d0573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97cf05409b2cb30e3fac0f725ecd5a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gaa97cf05409b2cb30e3fac0f725ecd5a4">transpose8</a> (<a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a0, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a1, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a2, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a3, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a4, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a5, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a6, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a7)</td></tr>
<tr class="separator:gaa97cf05409b2cb30e3fac0f725ecd5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffbcc38e033032fee83fb8c464cdbae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga5ffbcc38e033032fee83fb8c464cdbae">transpose8</a> (<a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a0, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a1, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a2, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a3, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a4, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a5, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a6, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a7)</td></tr>
<tr class="separator:ga5ffbcc38e033032fee83fb8c464cdbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9c828143157bf361752e069be179fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aff9c828143157bf361752e069be179fc">transpose8</a> (<a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a0, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a1, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a2, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a3, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a4, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a5, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a6, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a7)</td></tr>
<tr class="memdesc:aff9c828143157bf361752e069be179fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 8x8 16-bit matrix within eight int16x8 vectors.  <a href="#aff9c828143157bf361752e069be179fc">More...</a><br/></td></tr>
<tr class="separator:aff9c828143157bf361752e069be179fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac292e7c75739b96e30a3c956130126be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ac292e7c75739b96e30a3c956130126be">transpose8</a> (<a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a0, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a1, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a2, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a3, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a4, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a5, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a6, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a7)</td></tr>
<tr class="separator:ac292e7c75739b96e30a3c956130126be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb9870d5f0e174f81895e188e22c57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a8fb9870d5f0e174f81895e188e22c57b">transpose8</a> (<a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a0, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a1, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a2, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a3, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a4, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a5, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a6, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a7)</td></tr>
<tr class="separator:a8fb9870d5f0e174f81895e188e22c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a64f7d3163b10dab73fa2212d1961be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a5a64f7d3163b10dab73fa2212d1961be">transpose8</a> (<a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a0, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a1, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a2, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a3, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a4, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a5, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a6, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a7)</td></tr>
<tr class="separator:a5a64f7d3163b10dab73fa2212d1961be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac101484a86a30cd5ffed52d6e0072b2f"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ac101484a86a30cd5ffed52d6e0072b2f"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac101484a86a30cd5ffed52d6e0072b2f">align16</a> (const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V1 &gt; &amp;lower, const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V2 &gt; &amp;upper)</td></tr>
<tr class="memdesc:ac101484a86a30cd5ffed52d6e0072b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a int8x16 vector from two concatenated int8x16 vectors.  <a href="#ac101484a86a30cd5ffed52d6e0072b2f">More...</a><br/></td></tr>
<tr class="separator:ac101484a86a30cd5ffed52d6e0072b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d43daa93ab922a0c862d72bc04d950c"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a7d43daa93ab922a0c862d72bc04d950c"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7d43daa93ab922a0c862d72bc04d950c">align8</a> (const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V1 &gt; &amp;lower, const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V2 &gt; &amp;upper)</td></tr>
<tr class="memdesc:a7d43daa93ab922a0c862d72bc04d950c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a int16x8 vector from two concatenated int16x8 vectors.  <a href="#a7d43daa93ab922a0c862d72bc04d950c">More...</a><br/></td></tr>
<tr class="separator:a7d43daa93ab922a0c862d72bc04d950c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a47f9bf99ad41a3ffb7c6f65d17273"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad6a47f9bf99ad41a3ffb7c6f65d17273"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad6a47f9bf99ad41a3ffb7c6f65d17273">align4</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V1 &gt; &amp;lower, const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V2 &gt; &amp;upper)</td></tr>
<tr class="memdesc:ad6a47f9bf99ad41a3ffb7c6f65d17273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a int32x4 vector from two concatenated int32x4 vectors.  <a href="#ad6a47f9bf99ad41a3ffb7c6f65d17273">More...</a><br/></td></tr>
<tr class="separator:ad6a47f9bf99ad41a3ffb7c6f65d17273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a446eb3a7437a1c6826443d57b157de"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a2a446eb3a7437a1c6826443d57b157de"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a2a446eb3a7437a1c6826443d57b157de">align2</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V1 &gt; &amp;lower, const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V2 &gt; &amp;upper)</td></tr>
<tr class="memdesc:a2a446eb3a7437a1c6826443d57b157de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a int64x2 vector from two concatenated int64x2 vectors.  <a href="#a2a446eb3a7437a1c6826443d57b157de">More...</a><br/></td></tr>
<tr class="separator:a2a446eb3a7437a1c6826443d57b157de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb44bd8cadf25b2dd23d91a30aae5bd2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:afb44bd8cadf25b2dd23d91a30aae5bd2"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2&lt; V1, V2, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#afb44bd8cadf25b2dd23d91a30aae5bd2">bit_xor</a> (const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:afb44bd8cadf25b2dd23d91a30aae5bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise XOR of integer or floating-point vectors.  <a href="#afb44bd8cadf25b2dd23d91a30aae5bd2">More...</a><br/></td></tr>
<tr class="separator:afb44bd8cadf25b2dd23d91a30aae5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4777439013f74748cafbd0a6ae41c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00418.html#ga8d4777439013f74748cafbd0a6ae41c1">prefetch_read</a> (const void *ptr)</td></tr>
<tr class="memdesc:ga8d4777439013f74748cafbd0a6ae41c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetches data to the lowest level cache for reading.  <a href="a00418.html#ga8d4777439013f74748cafbd0a6ae41c1">More...</a><br/></td></tr>
<tr class="separator:ga8d4777439013f74748cafbd0a6ae41c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga180aef2d12f78afca2d6bdbbaaaa4828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00418.html#ga180aef2d12f78afca2d6bdbbaaaa4828">prefetch_write</a> (const void *ptr)</td></tr>
<tr class="memdesc:ga180aef2d12f78afca2d6bdbbaaaa4828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetches data to the lowest level cache for writing.  <a href="a00418.html#ga180aef2d12f78afca2d6bdbbaaaa4828">More...</a><br/></td></tr>
<tr class="separator:ga180aef2d12f78afca2d6bdbbaaaa4828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148f57260a9ff1588cf574adfa8e38be"><td class="memTemplParams" colspan="2">template&lt;class R , class T &gt; </td></tr>
<tr class="memitem:a148f57260a9ff1588cf574adfa8e38be"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a148f57260a9ff1588cf574adfa8e38be">bit_cast</a> (T t)</td></tr>
<tr class="memdesc:a148f57260a9ff1588cf574adfa8e38be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts between unrelated types.  <a href="#a148f57260a9ff1588cf574adfa8e38be">More...</a><br/></td></tr>
<tr class="separator:a148f57260a9ff1588cf574adfa8e38be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8227ff67e3d1c3bde0818e7583ec7391"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a8227ff67e3d1c3bde0818e7583ec7391"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00031.html">mask_int8</a>&lt; N, <a class="el" href="a00031.html">mask_int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8227ff67e3d1c3bde0818e7583ec7391">cmp_eq</a> (const <a class="el" href="a00013.html">any_int8</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00013.html">any_int8</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a8227ff67e3d1c3bde0818e7583ec7391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares 8-bit values for equality.  <a href="#a8227ff67e3d1c3bde0818e7583ec7391">More...</a><br/></td></tr>
<tr class="separator:a8227ff67e3d1c3bde0818e7583ec7391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27e9979e0e71e9c082ec7f305417b8b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ac27e9979e0e71e9c082ec7f305417b8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00028.html">mask_int16</a>&lt; N, <a class="el" href="a00028.html">mask_int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac27e9979e0e71e9c082ec7f305417b8b">cmp_eq</a> (const <a class="el" href="a00010.html">any_int16</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00010.html">any_int16</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ac27e9979e0e71e9c082ec7f305417b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares 16-bit values for equality.  <a href="#ac27e9979e0e71e9c082ec7f305417b8b">More...</a><br/></td></tr>
<tr class="separator:ac27e9979e0e71e9c082ec7f305417b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9224d4af1aa9f4765a4089e60416b0c1"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a9224d4af1aa9f4765a4089e60416b0c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00029.html">mask_int32</a>&lt; N, <a class="el" href="a00029.html">mask_int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9224d4af1aa9f4765a4089e60416b0c1">cmp_eq</a> (const <a class="el" href="a00011.html">any_int32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00011.html">any_int32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a9224d4af1aa9f4765a4089e60416b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two int32x4 vectors for equality.  <a href="#a9224d4af1aa9f4765a4089e60416b0c1">More...</a><br/></td></tr>
<tr class="separator:a9224d4af1aa9f4765a4089e60416b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0dec4d9b83a104898edfa87f974271"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a5b0dec4d9b83a104898edfa87f974271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00030.html">mask_int64</a>&lt; N, <a class="el" href="a00030.html">mask_int64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5b0dec4d9b83a104898edfa87f974271">cmp_eq</a> (const <a class="el" href="a00012.html">any_int64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00012.html">any_int64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a5b0dec4d9b83a104898edfa87f974271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two int64x2 vectors for equality.  <a href="#a5b0dec4d9b83a104898edfa87f974271">More...</a><br/></td></tr>
<tr class="separator:a5b0dec4d9b83a104898edfa87f974271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e67cb83257b34f02e9ab3fdd58651b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a34e67cb83257b34f02e9ab3fdd58651b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a34e67cb83257b34f02e9ab3fdd58651b">cmp_eq</a> (const <a class="el" href="a00008.html">any_float32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00008.html">any_float32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a34e67cb83257b34f02e9ab3fdd58651b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float32x4 vectors for equality.  <a href="#a34e67cb83257b34f02e9ab3fdd58651b">More...</a><br/></td></tr>
<tr class="separator:a34e67cb83257b34f02e9ab3fdd58651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad270ec959a78609539d55b272a066e28"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad270ec959a78609539d55b272a066e28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad270ec959a78609539d55b272a066e28">cmp_eq</a> (const <a class="el" href="a00009.html">any_float64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00009.html">any_float64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ad270ec959a78609539d55b272a066e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float64x2 vectors for equality.  <a href="#ad270ec959a78609539d55b272a066e28">More...</a><br/></td></tr>
<tr class="separator:ad270ec959a78609539d55b272a066e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfa48fca71e706030682df171264e49"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a9cfa48fca71e706030682df171264e49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9cfa48fca71e706030682df171264e49">cmp_ge</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a9cfa48fca71e706030682df171264e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float64x2 vectors for greater-than.  <a href="#a9cfa48fca71e706030682df171264e49">More...</a><br/></td></tr>
<tr class="separator:a9cfa48fca71e706030682df171264e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76a41b250183c6fa347cce18308fa58"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ac76a41b250183c6fa347cce18308fa58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00031.html">mask_int8</a>&lt; N, <a class="el" href="a00031.html">mask_int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac76a41b250183c6fa347cce18308fa58">cmp_gt</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ac76a41b250183c6fa347cce18308fa58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two signed int16x8 vectors for greater-than.  <a href="#ac76a41b250183c6fa347cce18308fa58">More...</a><br/></td></tr>
<tr class="separator:ac76a41b250183c6fa347cce18308fa58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2cfd381578cd1bde6ba07dfae376cf"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a9e2cfd381578cd1bde6ba07dfae376cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00031.html">mask_int8</a>&lt; N, <a class="el" href="a00031.html">mask_int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9e2cfd381578cd1bde6ba07dfae376cf">cmp_gt</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a9e2cfd381578cd1bde6ba07dfae376cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two unsigned int16x8 vectors for greater-than.  <a href="#a9e2cfd381578cd1bde6ba07dfae376cf">More...</a><br/></td></tr>
<tr class="separator:a9e2cfd381578cd1bde6ba07dfae376cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ebc182233c5115c22953496fbb0e99"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a27ebc182233c5115c22953496fbb0e99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00028.html">mask_int16</a>&lt; N, <a class="el" href="a00028.html">mask_int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a27ebc182233c5115c22953496fbb0e99">cmp_gt</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a27ebc182233c5115c22953496fbb0e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two signed int16x8 vectors for greater-than.  <a href="#a27ebc182233c5115c22953496fbb0e99">More...</a><br/></td></tr>
<tr class="separator:a27ebc182233c5115c22953496fbb0e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d19cb0bd2dbaeae57a91a76e79845"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a938d19cb0bd2dbaeae57a91a76e79845"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00028.html">mask_int16</a>&lt; N, <a class="el" href="a00028.html">mask_int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a938d19cb0bd2dbaeae57a91a76e79845">cmp_gt</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a938d19cb0bd2dbaeae57a91a76e79845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two unsigned int16x8 vectors for greater-than.  <a href="#a938d19cb0bd2dbaeae57a91a76e79845">More...</a><br/></td></tr>
<tr class="separator:a938d19cb0bd2dbaeae57a91a76e79845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c4699da18a3863d07b0a61f90900d2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a52c4699da18a3863d07b0a61f90900d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00031.html">mask_int8</a>&lt; N, <a class="el" href="a00031.html">mask_int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a52c4699da18a3863d07b0a61f90900d2">cmp_neq</a> (const <a class="el" href="a00013.html">any_int8</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00013.html">any_int8</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a52c4699da18a3863d07b0a61f90900d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two int8x16 vectors for inequality.  <a href="#a52c4699da18a3863d07b0a61f90900d2">More...</a><br/></td></tr>
<tr class="separator:a52c4699da18a3863d07b0a61f90900d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b3924c9f05016fbb931995b9c1786a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:aa4b3924c9f05016fbb931995b9c1786a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00028.html">mask_int16</a>&lt; N, <a class="el" href="a00028.html">mask_int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa4b3924c9f05016fbb931995b9c1786a">cmp_neq</a> (const <a class="el" href="a00010.html">any_int16</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00010.html">any_int16</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aa4b3924c9f05016fbb931995b9c1786a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two int16x8 vectors for inequality.  <a href="#aa4b3924c9f05016fbb931995b9c1786a">More...</a><br/></td></tr>
<tr class="separator:aa4b3924c9f05016fbb931995b9c1786a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266ec768c16b373414ff96f3d983dad5"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a266ec768c16b373414ff96f3d983dad5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00029.html">mask_int32</a>&lt; N, <a class="el" href="a00029.html">mask_int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a266ec768c16b373414ff96f3d983dad5">cmp_neq</a> (const <a class="el" href="a00011.html">any_int32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00011.html">any_int32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a266ec768c16b373414ff96f3d983dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two int32x4 vectors for inequality.  <a href="#a266ec768c16b373414ff96f3d983dad5">More...</a><br/></td></tr>
<tr class="separator:a266ec768c16b373414ff96f3d983dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04156653405d32f8f6d598bb0040498"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad04156653405d32f8f6d598bb0040498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00030.html">mask_int64</a>&lt; N, <a class="el" href="a00030.html">mask_int64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad04156653405d32f8f6d598bb0040498">cmp_neq</a> (const <a class="el" href="a00012.html">any_int64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00012.html">any_int64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ad04156653405d32f8f6d598bb0040498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two int64x2 vectors for inequality.  <a href="#ad04156653405d32f8f6d598bb0040498">More...</a><br/></td></tr>
<tr class="separator:ad04156653405d32f8f6d598bb0040498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c4dd9026f0e88772dcc07e19aa7227"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad8c4dd9026f0e88772dcc07e19aa7227"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad8c4dd9026f0e88772dcc07e19aa7227">cmp_neq</a> (const <a class="el" href="a00008.html">any_float32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00008.html">any_float32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ad8c4dd9026f0e88772dcc07e19aa7227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float32x4 vectors for inequality.  <a href="#ad8c4dd9026f0e88772dcc07e19aa7227">More...</a><br/></td></tr>
<tr class="separator:ad8c4dd9026f0e88772dcc07e19aa7227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e524875159826db31506ec6d90747fb"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a8e524875159826db31506ec6d90747fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8e524875159826db31506ec6d90747fb">cmp_neq</a> (const <a class="el" href="a00009.html">any_float64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00009.html">any_float64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a8e524875159826db31506ec6d90747fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float64x2 vectors for inequality.  <a href="#a8e524875159826db31506ec6d90747fb">More...</a><br/></td></tr>
<tr class="separator:a8e524875159826db31506ec6d90747fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28e8cfc78e167b5e0342634767ad6f8"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ad28e8cfc78e167b5e0342634767ad6f8"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad28e8cfc78e167b5e0342634767ad6f8">extract</a> (<a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> a)</td></tr>
<tr class="memdesc:ad28e8cfc78e167b5e0342634767ad6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from float32x4 vector.  <a href="#ad28e8cfc78e167b5e0342634767ad6f8">More...</a><br/></td></tr>
<tr class="separator:ad28e8cfc78e167b5e0342634767ad6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97264bf14196dca72e4439fca3bbe12f"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:a97264bf14196dca72e4439fca3bbe12f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a97264bf14196dca72e4439fca3bbe12f">extract</a> (<a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a> a)</td></tr>
<tr class="memdesc:a97264bf14196dca72e4439fca3bbe12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from float64x2 vector.  <a href="#a97264bf14196dca72e4439fca3bbe12f">More...</a><br/></td></tr>
<tr class="separator:a97264bf14196dca72e4439fca3bbe12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad6a75f035db9c8d631af13ce3e17c4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a3ad6a75f035db9c8d631af13ce3e17c4">extract_bits_any</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a)</td></tr>
<tr class="memdesc:a3ad6a75f035db9c8d631af13ce3e17c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a bit from each byte of each element of a int8x16 vector.  <a href="#a3ad6a75f035db9c8d631af13ce3e17c4">More...</a><br/></td></tr>
<tr class="separator:a3ad6a75f035db9c8d631af13ce3e17c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdb081735e8de53da5a3f713d9d72dc"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:a5cdb081735e8de53da5a3f713d9d72dc"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5cdb081735e8de53da5a3f713d9d72dc">extract_bits</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a)</td></tr>
<tr class="memdesc:a5cdb081735e8de53da5a3f713d9d72dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts specific bit from each byte of each element of a int8x16 vector.  <a href="#a5cdb081735e8de53da5a3f713d9d72dc">More...</a><br/></td></tr>
<tr class="separator:a5cdb081735e8de53da5a3f713d9d72dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d9986b34dbc68becf9758add0d35a2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a41d9986b34dbc68becf9758add0d35a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00034.html">expr_abs</a>&lt; <a class="el" href="a00020.html">float32</a><br class="typebreak"/>
&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2">abs</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a41d9986b34dbc68becf9758add0d35a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes absolute value of floating point values.  <a href="#a41d9986b34dbc68becf9758add0d35a2">More...</a><br/></td></tr>
<tr class="separator:a41d9986b34dbc68becf9758add0d35a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15992441248b52212c33f893ba8bc7bf"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a15992441248b52212c33f893ba8bc7bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00034.html">expr_abs</a>&lt; <a class="el" href="a00021.html">float64</a><br class="typebreak"/>
&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a15992441248b52212c33f893ba8bc7bf">abs</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a15992441248b52212c33f893ba8bc7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes absolute value of floating point values.  <a href="#a15992441248b52212c33f893ba8bc7bf">More...</a><br/></td></tr>
<tr class="separator:a15992441248b52212c33f893ba8bc7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41841a925565233350d53362752a34c6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a41841a925565233350d53362752a34c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00035.html">expr_add</a>&lt; <a class="el" href="a00020.html">float32</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a41841a925565233350d53362752a34c6">add</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a41841a925565233350d53362752a34c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the values of two vectors.  <a href="#a41841a925565233350d53362752a34c6">More...</a><br/></td></tr>
<tr class="separator:a41841a925565233350d53362752a34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25090f42331539d545277c754747e472"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a25090f42331539d545277c754747e472"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00035.html">expr_add</a>&lt; <a class="el" href="a00021.html">float64</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a25090f42331539d545277c754747e472">add</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a25090f42331539d545277c754747e472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the values of two vectors.  <a href="#a25090f42331539d545277c754747e472">More...</a><br/></td></tr>
<tr class="separator:a25090f42331539d545277c754747e472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc2460cf6237f33f17372acac09f51e"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:aafc2460cf6237f33f17372acac09f51e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aafc2460cf6237f33f17372acac09f51e">ceil</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:aafc2460cf6237f33f17372acac09f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the values a vector towards positive infinity.  <a href="#aafc2460cf6237f33f17372acac09f51e">More...</a><br/></td></tr>
<tr class="separator:aafc2460cf6237f33f17372acac09f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d79efa77ce2122851dfaf19f4042ec3"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a7d79efa77ce2122851dfaf19f4042ec3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7d79efa77ce2122851dfaf19f4042ec3">div</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a7d79efa77ce2122851dfaf19f4042ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the values of two vectors.  <a href="#a7d79efa77ce2122851dfaf19f4042ec3">More...</a><br/></td></tr>
<tr class="separator:a7d79efa77ce2122851dfaf19f4042ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefa6a78bbd66dfa881e6c6f6c5f9a5c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:afefa6a78bbd66dfa881e6c6f6c5f9a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00021.html">float64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#afefa6a78bbd66dfa881e6c6f6c5f9a5c">div</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:afefa6a78bbd66dfa881e6c6f6c5f9a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the values of two vectors.  <a href="#afefa6a78bbd66dfa881e6c6f6c5f9a5c">More...</a><br/></td></tr>
<tr class="separator:afefa6a78bbd66dfa881e6c6f6c5f9a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e6f8d875b59375b2a198c4e4652f65"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ac1e6f8d875b59375b2a198c4e4652f65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac1e6f8d875b59375b2a198c4e4652f65">floor</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ac1e6f8d875b59375b2a198c4e4652f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the values of a vector towards negative infinity.  <a href="#ac1e6f8d875b59375b2a198c4e4652f65">More...</a><br/></td></tr>
<tr class="separator:ac1e6f8d875b59375b2a198c4e4652f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fea06d72d5938df37cc4b5a1bd8994"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ac1fea06d72d5938df37cc4b5a1bd8994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994">isnan</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ac1fea06d72d5938df37cc4b5a1bd8994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether elements in <em>a</em> are IEEE754 NaN.  <a href="#ac1fea06d72d5938df37cc4b5a1bd8994">More...</a><br/></td></tr>
<tr class="separator:ac1fea06d72d5938df37cc4b5a1bd8994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db1158dfd39324487fffb381dc2fd3b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a5db1158dfd39324487fffb381dc2fd3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5db1158dfd39324487fffb381dc2fd3b">isnan</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a5db1158dfd39324487fffb381dc2fd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether elements in <em>a</em> are IEEE754 NaN.  <a href="#a5db1158dfd39324487fffb381dc2fd3b">More...</a><br/></td></tr>
<tr class="separator:a5db1158dfd39324487fffb381dc2fd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc55930679fb559b7ca93019b64a29"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:adcfc55930679fb559b7ca93019b64a29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#adcfc55930679fb559b7ca93019b64a29">isnan2</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:adcfc55930679fb559b7ca93019b64a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether corresponding elements in either <em>a</em> or <em>b</em> are IEEE754 NaN.  <a href="#adcfc55930679fb559b7ca93019b64a29">More...</a><br/></td></tr>
<tr class="separator:adcfc55930679fb559b7ca93019b64a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd7f80eb0e6c9520031d587a00ecd7d"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a5dd7f80eb0e6c9520031d587a00ecd7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5dd7f80eb0e6c9520031d587a00ecd7d">isnan2</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a5dd7f80eb0e6c9520031d587a00ecd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether corresponding elements in either <em>a</em> or <em>b</em> are IEEE754 NaN.  <a href="#a5dd7f80eb0e6c9520031d587a00ecd7d">More...</a><br/></td></tr>
<tr class="separator:a5dd7f80eb0e6c9520031d587a00ecd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa59db112d340032eba1ebf5ded06e2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a7aa59db112d340032eba1ebf5ded06e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2">max</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a7aa59db112d340032eba1ebf5ded06e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maxima of the values of two vectors.  <a href="#a7aa59db112d340032eba1ebf5ded06e2">More...</a><br/></td></tr>
<tr class="separator:a7aa59db112d340032eba1ebf5ded06e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba3a107f8b0b3181030f9891219a259"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a4ba3a107f8b0b3181030f9891219a259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259">min</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a4ba3a107f8b0b3181030f9891219a259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum of the values in two vectors.  <a href="#a4ba3a107f8b0b3181030f9891219a259">More...</a><br/></td></tr>
<tr class="separator:a4ba3a107f8b0b3181030f9891219a259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eee066c94d6510f314c6538bc597d49"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a3eee066c94d6510f314c6538bc597d49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00021.html">float64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a3eee066c94d6510f314c6538bc597d49">min</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a3eee066c94d6510f314c6538bc597d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minima of the values in two vectors.  <a href="#a3eee066c94d6510f314c6538bc597d49">More...</a><br/></td></tr>
<tr class="separator:a3eee066c94d6510f314c6538bc597d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c3eacf9886d5e5d369b8ef4ab82294"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a20c3eacf9886d5e5d369b8ef4ab82294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00047.html">expr_mul</a>&lt; <a class="el" href="a00020.html">float32</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a20c3eacf9886d5e5d369b8ef4ab82294">mul</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a20c3eacf9886d5e5d369b8ef4ab82294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the values of two vectors.  <a href="#a20c3eacf9886d5e5d369b8ef4ab82294">More...</a><br/></td></tr>
<tr class="separator:a20c3eacf9886d5e5d369b8ef4ab82294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676d2c7f4c1f58a9eb2e9d17421367c8"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a676d2c7f4c1f58a9eb2e9d17421367c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00047.html">expr_mul</a>&lt; <a class="el" href="a00021.html">float64</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a676d2c7f4c1f58a9eb2e9d17421367c8">mul</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a676d2c7f4c1f58a9eb2e9d17421367c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the values of two vectors.  <a href="#a676d2c7f4c1f58a9eb2e9d17421367c8">More...</a><br/></td></tr>
<tr class="separator:a676d2c7f4c1f58a9eb2e9d17421367c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99872876f61e9352d814dc1d9980a15c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a99872876f61e9352d814dc1d9980a15c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00051.html">expr_neg</a>&lt; <a class="el" href="a00020.html">float32</a><br class="typebreak"/>
&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a99872876f61e9352d814dc1d9980a15c">neg</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a99872876f61e9352d814dc1d9980a15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates the values of a float32x4 vector.  <a href="#a99872876f61e9352d814dc1d9980a15c">More...</a><br/></td></tr>
<tr class="separator:a99872876f61e9352d814dc1d9980a15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae539d567bbaa90164cdca58dfc59de0e"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ae539d567bbaa90164cdca58dfc59de0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00051.html">expr_neg</a>&lt; <a class="el" href="a00021.html">float64</a><br class="typebreak"/>
&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ae539d567bbaa90164cdca58dfc59de0e">neg</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ae539d567bbaa90164cdca58dfc59de0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates the values of a vector.  <a href="#ae539d567bbaa90164cdca58dfc59de0e">More...</a><br/></td></tr>
<tr class="separator:ae539d567bbaa90164cdca58dfc59de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d52060accdfc70b3d1a413faae3f4e6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a1d52060accdfc70b3d1a413faae3f4e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1d52060accdfc70b3d1a413faae3f4e6">rcp_e</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a1d52060accdfc70b3d1a413faae3f4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes approximate reciprocal.  <a href="#a1d52060accdfc70b3d1a413faae3f4e6">More...</a><br/></td></tr>
<tr class="separator:a1d52060accdfc70b3d1a413faae3f4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841f5f032d89fe22b20ab3929f2e315f"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a841f5f032d89fe22b20ab3929f2e315f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a841f5f032d89fe22b20ab3929f2e315f">rcp_rh</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a841f5f032d89fe22b20ab3929f2e315f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes one Newton-Rhapson iterations for reciprocal.  <a href="#a841f5f032d89fe22b20ab3929f2e315f">More...</a><br/></td></tr>
<tr class="separator:a841f5f032d89fe22b20ab3929f2e315f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af606974cd7c2e7b489665af171c757a2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:af606974cd7c2e7b489665af171c757a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af606974cd7c2e7b489665af171c757a2">rsqrt_e</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:af606974cd7c2e7b489665af171c757a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes approximate reciprocal square root.  <a href="#af606974cd7c2e7b489665af171c757a2">More...</a><br/></td></tr>
<tr class="separator:af606974cd7c2e7b489665af171c757a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5484877996923c12dcbbfb8d5440353c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a5484877996923c12dcbbfb8d5440353c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5484877996923c12dcbbfb8d5440353c">rsqrt_rh</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a5484877996923c12dcbbfb8d5440353c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes one Newton-Rhapson iteration for inverse of square root.  <a href="#a5484877996923c12dcbbfb8d5440353c">More...</a><br/></td></tr>
<tr class="separator:a5484877996923c12dcbbfb8d5440353c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bd925b02334c203f5052089d7caacc"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ad6bd925b02334c203f5052089d7caacc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad6bd925b02334c203f5052089d7caacc">sign</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ad6bd925b02334c203f5052089d7caacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts sign bits from the values in float32x4 vector.  <a href="#ad6bd925b02334c203f5052089d7caacc">More...</a><br/></td></tr>
<tr class="separator:ad6bd925b02334c203f5052089d7caacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7181ea06b84354524ae84509575a60a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:aa7181ea06b84354524ae84509575a60a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00021.html">float64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa7181ea06b84354524ae84509575a60a">sign</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:aa7181ea06b84354524ae84509575a60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts sigh bit from the values in float64x2 vector.  <a href="#aa7181ea06b84354524ae84509575a60a">More...</a><br/></td></tr>
<tr class="separator:aa7181ea06b84354524ae84509575a60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5197ff42cca41e903165e77262b662"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 &gt; </td></tr>
<tr class="memitem:acc5197ff42cca41e903165e77262b662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#acc5197ff42cca41e903165e77262b662">sqrt</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a)</td></tr>
<tr class="memdesc:acc5197ff42cca41e903165e77262b662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes square root.  <a href="#acc5197ff42cca41e903165e77262b662">More...</a><br/></td></tr>
<tr class="separator:acc5197ff42cca41e903165e77262b662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52555d4a71e3df3b755d2de54ff33ab1"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 &gt; </td></tr>
<tr class="memitem:a52555d4a71e3df3b755d2de54ff33ab1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00021.html">float64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a52555d4a71e3df3b755d2de54ff33ab1">sqrt</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a)</td></tr>
<tr class="memdesc:a52555d4a71e3df3b755d2de54ff33ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes square root.  <a href="#a52555d4a71e3df3b755d2de54ff33ab1">More...</a><br/></td></tr>
<tr class="separator:a52555d4a71e3df3b755d2de54ff33ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661b7fbbfce252cc3d7d12c18a11b45c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a661b7fbbfce252cc3d7d12c18a11b45c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00056.html">expr_sub</a>&lt; <a class="el" href="a00020.html">float32</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a661b7fbbfce252cc3d7d12c18a11b45c">sub</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a661b7fbbfce252cc3d7d12c18a11b45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts the values of two vectors.  <a href="#a661b7fbbfce252cc3d7d12c18a11b45c">More...</a><br/></td></tr>
<tr class="separator:a661b7fbbfce252cc3d7d12c18a11b45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0994a9fa406d277e8cb46701173ebcf"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ad0994a9fa406d277e8cb46701173ebcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00056.html">expr_sub</a>&lt; <a class="el" href="a00021.html">float64</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad0994a9fa406d277e8cb46701173ebcf">sub</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ad0994a9fa406d277e8cb46701173ebcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the values of two vectors.  <a href="#ad0994a9fa406d277e8cb46701173ebcf">More...</a><br/></td></tr>
<tr class="separator:ad0994a9fa406d277e8cb46701173ebcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3a347efa588f683aaba41da8b8973e"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a9e3a347efa588f683aaba41da8b8973e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9e3a347efa588f683aaba41da8b8973e">trunc</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a9e3a347efa588f683aaba41da8b8973e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the values of a vector towards zero.  <a href="#a9e3a347efa588f683aaba41da8b8973e">More...</a><br/></td></tr>
<tr class="separator:a9e3a347efa588f683aaba41da8b8973e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501311c3a1979838d8253a74d92c2a0b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a501311c3a1979838d8253a74d92c2a0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00034.html">expr_abs</a>&lt; <a class="el" href="a00025.html">int8</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a501311c3a1979838d8253a74d92c2a0b">abs</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a501311c3a1979838d8253a74d92c2a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes absolute value of 8-bit integer values.  <a href="#a501311c3a1979838d8253a74d92c2a0b">More...</a><br/></td></tr>
<tr class="separator:a501311c3a1979838d8253a74d92c2a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361f99bb30f53ca402f9fd966587f4d0"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a361f99bb30f53ca402f9fd966587f4d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00034.html">expr_abs</a>&lt; <a class="el" href="a00022.html">int16</a>&lt; N, <br class="typebreak"/>
E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a361f99bb30f53ca402f9fd966587f4d0">abs</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a361f99bb30f53ca402f9fd966587f4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes absolute value of 16-bit integer values.  <a href="#a361f99bb30f53ca402f9fd966587f4d0">More...</a><br/></td></tr>
<tr class="separator:a361f99bb30f53ca402f9fd966587f4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727525242b4c33c21b24eb0ade861f22"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a727525242b4c33c21b24eb0ade861f22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00034.html">expr_abs</a>&lt; <a class="el" href="a00023.html">int32</a>&lt; N, <br class="typebreak"/>
E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a727525242b4c33c21b24eb0ade861f22">abs</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a727525242b4c33c21b24eb0ade861f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes absolute value of 32-bit integer values.  <a href="#a727525242b4c33c21b24eb0ade861f22">More...</a><br/></td></tr>
<tr class="separator:a727525242b4c33c21b24eb0ade861f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf1e6f9fe1ce165bf96111211919623"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a6bf1e6f9fe1ce165bf96111211919623"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00034.html">expr_abs</a>&lt; <a class="el" href="a00024.html">int64</a>&lt; N, <br class="typebreak"/>
E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a6bf1e6f9fe1ce165bf96111211919623">abs</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a6bf1e6f9fe1ce165bf96111211919623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes absolute value of 64-bit integer values.  <a href="#a6bf1e6f9fe1ce165bf96111211919623">More...</a><br/></td></tr>
<tr class="separator:a6bf1e6f9fe1ce165bf96111211919623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e3115c5acdf0a1a5dc5b0c5ecc2131"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a24e3115c5acdf0a1a5dc5b0c5ecc2131"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00035.html">expr_add</a>&lt; <a class="el" href="a00135.html">uint8</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00135.html">uint8</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a24e3115c5acdf0a1a5dc5b0c5ecc2131">add</a> (const <a class="el" href="a00013.html">any_int8</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00013.html">any_int8</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a24e3115c5acdf0a1a5dc5b0c5ecc2131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 8-bit integer values.  <a href="#a24e3115c5acdf0a1a5dc5b0c5ecc2131">More...</a><br/></td></tr>
<tr class="separator:a24e3115c5acdf0a1a5dc5b0c5ecc2131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41df05d747fdd4ebe0e2ce8667eb4014"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a41df05d747fdd4ebe0e2ce8667eb4014"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00035.html">expr_add</a>&lt; <a class="el" href="a00123.html">uint16</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00123.html">uint16</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a41df05d747fdd4ebe0e2ce8667eb4014">add</a> (const <a class="el" href="a00010.html">any_int16</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00010.html">any_int16</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a41df05d747fdd4ebe0e2ce8667eb4014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 16-bit integer values.  <a href="#a41df05d747fdd4ebe0e2ce8667eb4014">More...</a><br/></td></tr>
<tr class="separator:a41df05d747fdd4ebe0e2ce8667eb4014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d55bf201f41ad2a9cf7203578f22538"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a1d55bf201f41ad2a9cf7203578f22538"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00035.html">expr_add</a>&lt; <a class="el" href="a00127.html">uint32</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00127.html">uint32</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1d55bf201f41ad2a9cf7203578f22538">add</a> (const <a class="el" href="a00011.html">any_int32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00011.html">any_int32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a1d55bf201f41ad2a9cf7203578f22538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 32-bit integer values.  <a href="#a1d55bf201f41ad2a9cf7203578f22538">More...</a><br/></td></tr>
<tr class="separator:a1d55bf201f41ad2a9cf7203578f22538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a0be1b9746648028eaa35ee624345"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a3f1a0be1b9746648028eaa35ee624345"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00035.html">expr_add</a>&lt; <a class="el" href="a00131.html">uint64</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00131.html">uint64</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a3f1a0be1b9746648028eaa35ee624345">add</a> (const <a class="el" href="a00012.html">any_int64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00012.html">any_int64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a3f1a0be1b9746648028eaa35ee624345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 64-bit integer values.  <a href="#a3f1a0be1b9746648028eaa35ee624345">More...</a><br/></td></tr>
<tr class="separator:a3f1a0be1b9746648028eaa35ee624345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8338a491d46a2258657f9b412d8bd5a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ad8338a491d46a2258657f9b412d8bd5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00036.html">expr_add_sat</a>&lt; <a class="el" href="a00025.html">int8</a>&lt; N, <br class="typebreak"/>
E1 &gt;, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad8338a491d46a2258657f9b412d8bd5a">add_sat</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ad8338a491d46a2258657f9b412d8bd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds and saturates signed 8-bit integer values.  <a href="#ad8338a491d46a2258657f9b412d8bd5a">More...</a><br/></td></tr>
<tr class="separator:ad8338a491d46a2258657f9b412d8bd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d5d493566064116841cac49ba8dc4a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a83d5d493566064116841cac49ba8dc4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00036.html">expr_add_sat</a>&lt; <a class="el" href="a00022.html">int16</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a83d5d493566064116841cac49ba8dc4a">add_sat</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a83d5d493566064116841cac49ba8dc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds and saturates signed 16-bit integer values.  <a href="#a83d5d493566064116841cac49ba8dc4a">More...</a><br/></td></tr>
<tr class="separator:a83d5d493566064116841cac49ba8dc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2436051cb2206ac077aa4c5ab96752"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a6c2436051cb2206ac077aa4c5ab96752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00036.html">expr_add_sat</a>&lt; <a class="el" href="a00135.html">uint8</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a6c2436051cb2206ac077aa4c5ab96752">add_sat</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a6c2436051cb2206ac077aa4c5ab96752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds and saturates unsigned 8-bit integer values.  <a href="#a6c2436051cb2206ac077aa4c5ab96752">More...</a><br/></td></tr>
<tr class="separator:a6c2436051cb2206ac077aa4c5ab96752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faa602ab50b10d40b5b52092c800e75"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a5faa602ab50b10d40b5b52092c800e75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00036.html">expr_add_sat</a><br class="typebreak"/>
&lt; <a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt;, <a class="el" href="a00123.html">uint16</a>&lt; N, <br class="typebreak"/>
E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5faa602ab50b10d40b5b52092c800e75">add_sat</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a5faa602ab50b10d40b5b52092c800e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds and saturates unsigned 16-bit integer values.  <a href="#a5faa602ab50b10d40b5b52092c800e75">More...</a><br/></td></tr>
<tr class="separator:a5faa602ab50b10d40b5b52092c800e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927476604c6376171af163fb63f4d431"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a927476604c6376171af163fb63f4d431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a927476604c6376171af163fb63f4d431">avg</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a927476604c6376171af163fb63f4d431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes rounded average of the unsigned 8-bit values.  <a href="#a927476604c6376171af163fb63f4d431">More...</a><br/></td></tr>
<tr class="separator:a927476604c6376171af163fb63f4d431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ab590d418e1b2da8b4859f16fad10b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a55ab590d418e1b2da8b4859f16fad10b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a55ab590d418e1b2da8b4859f16fad10b">avg</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a55ab590d418e1b2da8b4859f16fad10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes rounded average of signed 8-bit values.  <a href="#a55ab590d418e1b2da8b4859f16fad10b">More...</a><br/></td></tr>
<tr class="separator:a55ab590d418e1b2da8b4859f16fad10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf69200e18bf0efde43d673b53aa68f3"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:adf69200e18bf0efde43d673b53aa68f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#adf69200e18bf0efde43d673b53aa68f3">avg</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:adf69200e18bf0efde43d673b53aa68f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes rounded average of unsigned 16-bit values.  <a href="#adf69200e18bf0efde43d673b53aa68f3">More...</a><br/></td></tr>
<tr class="separator:adf69200e18bf0efde43d673b53aa68f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928f2f40587aee9860fb2b2f9a2af322"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a928f2f40587aee9860fb2b2f9a2af322"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a928f2f40587aee9860fb2b2f9a2af322">avg</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a928f2f40587aee9860fb2b2f9a2af322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes rounded average of signed 16-bit values.  <a href="#a928f2f40587aee9860fb2b2f9a2af322">More...</a><br/></td></tr>
<tr class="separator:a928f2f40587aee9860fb2b2f9a2af322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7755045244614af942343cd5cb87697b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a7755045244614af942343cd5cb87697b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7755045244614af942343cd5cb87697b">avg</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a7755045244614af942343cd5cb87697b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes rounded average of unsigned 32-bit values.  <a href="#a7755045244614af942343cd5cb87697b">More...</a><br/></td></tr>
<tr class="separator:a7755045244614af942343cd5cb87697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a731a765a019f13408829326c72990b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a3a731a765a019f13408829326c72990b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a3a731a765a019f13408829326c72990b">avg</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a3a731a765a019f13408829326c72990b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes rounded average of signed 32-bit values.  <a href="#a3a731a765a019f13408829326c72990b">More...</a><br/></td></tr>
<tr class="separator:a3a731a765a019f13408829326c72990b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34e1af18c1513f406b8acb05e82ccbb"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ad34e1af18c1513f406b8acb05e82ccbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad34e1af18c1513f406b8acb05e82ccbb">avg_trunc</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ad34e1af18c1513f406b8acb05e82ccbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes truncated average of the unsigned 8-bit values.  <a href="#ad34e1af18c1513f406b8acb05e82ccbb">More...</a><br/></td></tr>
<tr class="separator:ad34e1af18c1513f406b8acb05e82ccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac5518b77e7d14eedec9b628d9f9940"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a4ac5518b77e7d14eedec9b628d9f9940"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4ac5518b77e7d14eedec9b628d9f9940">avg_trunc</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a4ac5518b77e7d14eedec9b628d9f9940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes truncated average of signed 8-bit values.  <a href="#a4ac5518b77e7d14eedec9b628d9f9940">More...</a><br/></td></tr>
<tr class="separator:a4ac5518b77e7d14eedec9b628d9f9940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad116f56fdf371c7939dc3408a582be85"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ad116f56fdf371c7939dc3408a582be85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad116f56fdf371c7939dc3408a582be85">avg_trunc</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ad116f56fdf371c7939dc3408a582be85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes truncated average of unsigned 16-bit values.  <a href="#ad116f56fdf371c7939dc3408a582be85">More...</a><br/></td></tr>
<tr class="separator:ad116f56fdf371c7939dc3408a582be85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d028214036fd5bebad3a82517fe0bdb"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a9d028214036fd5bebad3a82517fe0bdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9d028214036fd5bebad3a82517fe0bdb">avg_trunc</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a9d028214036fd5bebad3a82517fe0bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes truncated average of signed 16-bit values.  <a href="#a9d028214036fd5bebad3a82517fe0bdb">More...</a><br/></td></tr>
<tr class="separator:a9d028214036fd5bebad3a82517fe0bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5474b56675e4fd7c1f0601972bc40e24"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a5474b56675e4fd7c1f0601972bc40e24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5474b56675e4fd7c1f0601972bc40e24">avg_trunc</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a5474b56675e4fd7c1f0601972bc40e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes truncated average of unsigned 32-bit values.  <a href="#a5474b56675e4fd7c1f0601972bc40e24">More...</a><br/></td></tr>
<tr class="separator:a5474b56675e4fd7c1f0601972bc40e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed7ef03e2b5793ffab2f69d96ed9312"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a2ed7ef03e2b5793ffab2f69d96ed9312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a2ed7ef03e2b5793ffab2f69d96ed9312">avg_trunc</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a2ed7ef03e2b5793ffab2f69d96ed9312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes truncated average of signed 32-bit values.  <a href="#a2ed7ef03e2b5793ffab2f69d96ed9312">More...</a><br/></td></tr>
<tr class="separator:a2ed7ef03e2b5793ffab2f69d96ed9312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0761c4077c8fe889f664e2ddc48080b6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a0761c4077c8fe889f664e2ddc48080b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a0761c4077c8fe889f664e2ddc48080b6">max</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a0761c4077c8fe889f664e2ddc48080b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maximum of the signed 8-bit values.  <a href="#a0761c4077c8fe889f664e2ddc48080b6">More...</a><br/></td></tr>
<tr class="separator:a0761c4077c8fe889f664e2ddc48080b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0bc204d48fdf680e1479c8309791b8"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a5b0bc204d48fdf680e1479c8309791b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5b0bc204d48fdf680e1479c8309791b8">max</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a5b0bc204d48fdf680e1479c8309791b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maximum of the unsigned 8-bit values.  <a href="#a5b0bc204d48fdf680e1479c8309791b8">More...</a><br/></td></tr>
<tr class="separator:a5b0bc204d48fdf680e1479c8309791b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05c527df4d10c893a0d470a79f750a7"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ac05c527df4d10c893a0d470a79f750a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac05c527df4d10c893a0d470a79f750a7">max</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ac05c527df4d10c893a0d470a79f750a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maximum of the signed 16-bit values.  <a href="#ac05c527df4d10c893a0d470a79f750a7">More...</a><br/></td></tr>
<tr class="separator:ac05c527df4d10c893a0d470a79f750a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407a9edc4850386e66d60a540e02770c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a407a9edc4850386e66d60a540e02770c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a407a9edc4850386e66d60a540e02770c">max</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a407a9edc4850386e66d60a540e02770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maximum of the unsigned 16-bit values.  <a href="#a407a9edc4850386e66d60a540e02770c">More...</a><br/></td></tr>
<tr class="separator:a407a9edc4850386e66d60a540e02770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1020392e00b5eee61b0f6f943680622"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ad1020392e00b5eee61b0f6f943680622"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad1020392e00b5eee61b0f6f943680622">max</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ad1020392e00b5eee61b0f6f943680622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maximum of the signed 32-bit values.  <a href="#ad1020392e00b5eee61b0f6f943680622">More...</a><br/></td></tr>
<tr class="separator:ad1020392e00b5eee61b0f6f943680622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bd56064b366f6161440bb2e98debcf"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ad0bd56064b366f6161440bb2e98debcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad0bd56064b366f6161440bb2e98debcf">max</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ad0bd56064b366f6161440bb2e98debcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maximum of the unsigned 32-bit values.  <a href="#ad0bd56064b366f6161440bb2e98debcf">More...</a><br/></td></tr>
<tr class="separator:ad0bd56064b366f6161440bb2e98debcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a365a1ffd95d0d8e34fe5d1ffa3ac19"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a5a365a1ffd95d0d8e34fe5d1ffa3ac19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5a365a1ffd95d0d8e34fe5d1ffa3ac19">min</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a5a365a1ffd95d0d8e34fe5d1ffa3ac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum of signed 8-bit values.  <a href="#a5a365a1ffd95d0d8e34fe5d1ffa3ac19">More...</a><br/></td></tr>
<tr class="separator:a5a365a1ffd95d0d8e34fe5d1ffa3ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0648202e8e0451ddb45447816d5108e0"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a0648202e8e0451ddb45447816d5108e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a0648202e8e0451ddb45447816d5108e0">min</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a0648202e8e0451ddb45447816d5108e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum of the unsigned 8-bit values.  <a href="#a0648202e8e0451ddb45447816d5108e0">More...</a><br/></td></tr>
<tr class="separator:a0648202e8e0451ddb45447816d5108e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b90b4fc2d4210d9bebf41317693bd60"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a2b90b4fc2d4210d9bebf41317693bd60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a2b90b4fc2d4210d9bebf41317693bd60">min</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a2b90b4fc2d4210d9bebf41317693bd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum of the signed 16-bit values.  <a href="#a2b90b4fc2d4210d9bebf41317693bd60">More...</a><br/></td></tr>
<tr class="separator:a2b90b4fc2d4210d9bebf41317693bd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ca381a9cd41a9a6d2b51c8f0e9b58f"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a91ca381a9cd41a9a6d2b51c8f0e9b58f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a91ca381a9cd41a9a6d2b51c8f0e9b58f">min</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a91ca381a9cd41a9a6d2b51c8f0e9b58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum of the unsigned 16-bit values.  <a href="#a91ca381a9cd41a9a6d2b51c8f0e9b58f">More...</a><br/></td></tr>
<tr class="separator:a91ca381a9cd41a9a6d2b51c8f0e9b58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed48804fb936cb1431a1051cb44d75ab"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:aed48804fb936cb1431a1051cb44d75ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aed48804fb936cb1431a1051cb44d75ab">min</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:aed48804fb936cb1431a1051cb44d75ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum of the signed 32-bit values.  <a href="#aed48804fb936cb1431a1051cb44d75ab">More...</a><br/></td></tr>
<tr class="separator:aed48804fb936cb1431a1051cb44d75ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435cd4d9b25c380060ecdba3dab2839c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a435cd4d9b25c380060ecdba3dab2839c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a435cd4d9b25c380060ecdba3dab2839c">min</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a435cd4d9b25c380060ecdba3dab2839c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum of the unsigned 32-bit values.  <a href="#a435cd4d9b25c380060ecdba3dab2839c">More...</a><br/></td></tr>
<tr class="separator:a435cd4d9b25c380060ecdba3dab2839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9ac150759822bb2390eea905fcf859"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:aab9ac150759822bb2390eea905fcf859"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00049.html">expr_mul_lo</a>&lt; <a class="el" href="a00123.html">uint16</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00123.html">uint16</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aab9ac150759822bb2390eea905fcf859">mul_lo</a> (const <a class="el" href="a00010.html">any_int16</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00010.html">any_int16</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aab9ac150759822bb2390eea905fcf859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies 16-bit values and returns the lower part of the multiplication.  <a href="#aab9ac150759822bb2390eea905fcf859">More...</a><br/></td></tr>
<tr class="separator:aab9ac150759822bb2390eea905fcf859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff262e172a5834bcc35ac990bbf5e1"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ae0ff262e172a5834bcc35ac990bbf5e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00048.html">expr_mul_hi</a>&lt; <a class="el" href="a00022.html">int16</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ae0ff262e172a5834bcc35ac990bbf5e1">mul_hi</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ae0ff262e172a5834bcc35ac990bbf5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit values and returns the higher half of the result.  <a href="#ae0ff262e172a5834bcc35ac990bbf5e1">More...</a><br/></td></tr>
<tr class="separator:ae0ff262e172a5834bcc35ac990bbf5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc3b6b14d4eab3a0e095ac82fc85e61"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a6bc3b6b14d4eab3a0e095ac82fc85e61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00048.html">expr_mul_hi</a>&lt; <a class="el" href="a00123.html">uint16</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a6bc3b6b14d4eab3a0e095ac82fc85e61">mul_hi</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a6bc3b6b14d4eab3a0e095ac82fc85e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies unsigned 16-bit values and returns the higher half of the result.  <a href="#a6bc3b6b14d4eab3a0e095ac82fc85e61">More...</a><br/></td></tr>
<tr class="separator:a6bc3b6b14d4eab3a0e095ac82fc85e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec3aa7a9f48ca8d24d57be3447c54c9"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:aeec3aa7a9f48ca8d24d57be3447c54c9"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00049.html">expr_mul_lo</a>&lt; <a class="el" href="a00127.html">uint32</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00127.html">uint32</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aeec3aa7a9f48ca8d24d57be3447c54c9">mul_lo</a> (const <a class="el" href="a00011.html">any_int32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00011.html">any_int32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aeec3aa7a9f48ca8d24d57be3447c54c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies 32-bit values and returns the lower half of the result.  <a href="#aeec3aa7a9f48ca8d24d57be3447c54c9">More...</a><br/></td></tr>
<tr class="separator:aeec3aa7a9f48ca8d24d57be3447c54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88283884c72955203f292750acc8815"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ad88283884c72955203f292750acc8815"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00051.html">expr_neg</a>&lt; <a class="el" href="a00025.html">int8</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad88283884c72955203f292750acc8815">neg</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ad88283884c72955203f292750acc8815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates signed 8-bit values.  <a href="#ad88283884c72955203f292750acc8815">More...</a><br/></td></tr>
<tr class="separator:ad88283884c72955203f292750acc8815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62ed3b801192dbf45db14c3d6300dc8"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:af62ed3b801192dbf45db14c3d6300dc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00051.html">expr_neg</a>&lt; <a class="el" href="a00022.html">int16</a>&lt; N, <br class="typebreak"/>
E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af62ed3b801192dbf45db14c3d6300dc8">neg</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:af62ed3b801192dbf45db14c3d6300dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates signed 16-bit values.  <a href="#af62ed3b801192dbf45db14c3d6300dc8">More...</a><br/></td></tr>
<tr class="separator:af62ed3b801192dbf45db14c3d6300dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66a8bedf5a336936507a0618bb254e6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ad66a8bedf5a336936507a0618bb254e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00051.html">expr_neg</a>&lt; <a class="el" href="a00023.html">int32</a>&lt; N, <br class="typebreak"/>
E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad66a8bedf5a336936507a0618bb254e6">neg</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ad66a8bedf5a336936507a0618bb254e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates signed 32-bit values.  <a href="#ad66a8bedf5a336936507a0618bb254e6">More...</a><br/></td></tr>
<tr class="separator:ad66a8bedf5a336936507a0618bb254e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03619c8be5e6b5667765b43b6fbfd106"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a03619c8be5e6b5667765b43b6fbfd106"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00051.html">expr_neg</a>&lt; <a class="el" href="a00024.html">int64</a>&lt; N, <br class="typebreak"/>
E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a03619c8be5e6b5667765b43b6fbfd106">neg</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a03619c8be5e6b5667765b43b6fbfd106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates signed 64-bit values.  <a href="#a03619c8be5e6b5667765b43b6fbfd106">More...</a><br/></td></tr>
<tr class="separator:a03619c8be5e6b5667765b43b6fbfd106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3815103f7b6c5319cf00676785cb8c4b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a3815103f7b6c5319cf00676785cb8c4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a3815103f7b6c5319cf00676785cb8c4b">shift_r</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a3815103f7b6c5319cf00676785cb8c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 8-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#a3815103f7b6c5319cf00676785cb8c4b">More...</a><br/></td></tr>
<tr class="separator:a3815103f7b6c5319cf00676785cb8c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef11196954334c758c3eb1ca30217ba2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:aef11196954334c758c3eb1ca30217ba2"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00056.html">expr_sub</a>&lt; <a class="el" href="a00135.html">uint8</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00135.html">uint8</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aef11196954334c758c3eb1ca30217ba2">sub</a> (const <a class="el" href="a00013.html">any_int8</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00013.html">any_int8</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aef11196954334c758c3eb1ca30217ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 8-bit integer values.  <a href="#aef11196954334c758c3eb1ca30217ba2">More...</a><br/></td></tr>
<tr class="separator:aef11196954334c758c3eb1ca30217ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e51b1fe2b6f952f6c3aafd7da49187e"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a1e51b1fe2b6f952f6c3aafd7da49187e"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00056.html">expr_sub</a>&lt; <a class="el" href="a00123.html">uint16</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00123.html">uint16</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1e51b1fe2b6f952f6c3aafd7da49187e">sub</a> (const <a class="el" href="a00010.html">any_int16</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00010.html">any_int16</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a1e51b1fe2b6f952f6c3aafd7da49187e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 16-bit integer values.  <a href="#a1e51b1fe2b6f952f6c3aafd7da49187e">More...</a><br/></td></tr>
<tr class="separator:a1e51b1fe2b6f952f6c3aafd7da49187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18c68c697f1e216cfbf240de0811402"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:aa18c68c697f1e216cfbf240de0811402"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00056.html">expr_sub</a>&lt; <a class="el" href="a00127.html">uint32</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00127.html">uint32</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa18c68c697f1e216cfbf240de0811402">sub</a> (const <a class="el" href="a00011.html">any_int32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00011.html">any_int32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aa18c68c697f1e216cfbf240de0811402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 32-bit integer values.  <a href="#aa18c68c697f1e216cfbf240de0811402">More...</a><br/></td></tr>
<tr class="separator:aa18c68c697f1e216cfbf240de0811402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8cdb5972da2368a4780317b5faaa6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a6ad8cdb5972da2368a4780317b5faaa6"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, <a class="el" href="a00056.html">expr_sub</a>&lt; <a class="el" href="a00131.html">uint64</a>&lt; N, <br class="typebreak"/>
typename V1::expr_type &gt;<br class="typebreak"/>
, <a class="el" href="a00131.html">uint64</a>&lt; N, typename <br class="typebreak"/>
V2::expr_type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a6ad8cdb5972da2368a4780317b5faaa6">sub</a> (const <a class="el" href="a00012.html">any_int64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00012.html">any_int64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a6ad8cdb5972da2368a4780317b5faaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 64-bit integer values.  <a href="#a6ad8cdb5972da2368a4780317b5faaa6">More...</a><br/></td></tr>
<tr class="separator:a6ad8cdb5972da2368a4780317b5faaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac798e60e201fd395b55b42c46abe1e74"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ac798e60e201fd395b55b42c46abe1e74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00057.html">expr_sub_sat</a>&lt; <a class="el" href="a00025.html">int8</a>&lt; N, <br class="typebreak"/>
E1 &gt;, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac798e60e201fd395b55b42c46abe1e74">sub_sat</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ac798e60e201fd395b55b42c46abe1e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts and saturaters signed 8-bit integer values.  <a href="#ac798e60e201fd395b55b42c46abe1e74">More...</a><br/></td></tr>
<tr class="separator:ac798e60e201fd395b55b42c46abe1e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d52ec632124731fdc1ac573aa59495"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a80d52ec632124731fdc1ac573aa59495"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00057.html">expr_sub_sat</a>&lt; <a class="el" href="a00022.html">int16</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a80d52ec632124731fdc1ac573aa59495">sub_sat</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a80d52ec632124731fdc1ac573aa59495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts and saturaters signed 16-bit integer values.  <a href="#a80d52ec632124731fdc1ac573aa59495">More...</a><br/></td></tr>
<tr class="separator:a80d52ec632124731fdc1ac573aa59495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0447c92c7905445af2b86c728bcb58"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a1f0447c92c7905445af2b86c728bcb58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00057.html">expr_sub_sat</a>&lt; <a class="el" href="a00135.html">uint8</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1f0447c92c7905445af2b86c728bcb58">sub_sat</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a1f0447c92c7905445af2b86c728bcb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts and saturaters unsigned 8-bit integer values.  <a href="#a1f0447c92c7905445af2b86c728bcb58">More...</a><br/></td></tr>
<tr class="separator:a1f0447c92c7905445af2b86c728bcb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6200c5737cdf5e7636a56e6f0ae3711c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a6200c5737cdf5e7636a56e6f0ae3711c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00057.html">expr_sub_sat</a><br class="typebreak"/>
&lt; <a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt;, <a class="el" href="a00123.html">uint16</a>&lt; N, <br class="typebreak"/>
E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a6200c5737cdf5e7636a56e6f0ae3711c">sub_sat</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a6200c5737cdf5e7636a56e6f0ae3711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts and saturaters unsigned 16-bit integer values.  <a href="#a6200c5737cdf5e7636a56e6f0ae3711c">More...</a><br/></td></tr>
<tr class="separator:a6200c5737cdf5e7636a56e6f0ae3711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc919d93c342a0bd403f67983ca7503e"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:gacc919d93c342a0bd403f67983ca7503e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gacc919d93c342a0bd403f67983ca7503e">insert</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a, uint8_t x)</td></tr>
<tr class="memdesc:gacc919d93c342a0bd403f67983ca7503e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into int8x16 vector at the position identified by <em>id</em>.  <a href="a00419.html#gacc919d93c342a0bd403f67983ca7503e">More...</a><br/></td></tr>
<tr class="separator:gacc919d93c342a0bd403f67983ca7503e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba373748094b5f009103b7b87b7bd92"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ga8ba373748094b5f009103b7b87b7bd92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga8ba373748094b5f009103b7b87b7bd92">insert</a> (<a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> a, uint16_t x)</td></tr>
<tr class="memdesc:ga8ba373748094b5f009103b7b87b7bd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into int16x8 vector at the position identified by <em>id</em>.  <a href="a00419.html#ga8ba373748094b5f009103b7b87b7bd92">More...</a><br/></td></tr>
<tr class="separator:ga8ba373748094b5f009103b7b87b7bd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e97293d736f9c2fb01e64197c80dca"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ga72e97293d736f9c2fb01e64197c80dca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga72e97293d736f9c2fb01e64197c80dca">insert</a> (<a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> a, uint32_t x)</td></tr>
<tr class="memdesc:ga72e97293d736f9c2fb01e64197c80dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into int32x4 vector at the position identified by <em>id</em>.  <a href="a00419.html#ga72e97293d736f9c2fb01e64197c80dca">More...</a><br/></td></tr>
<tr class="separator:ga72e97293d736f9c2fb01e64197c80dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9974d84f9b9b0235dc5fc091962c74d1"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ga9974d84f9b9b0235dc5fc091962c74d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga9974d84f9b9b0235dc5fc091962c74d1">insert</a> (<a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a> a, uint64_t x)</td></tr>
<tr class="memdesc:ga9974d84f9b9b0235dc5fc091962c74d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into int64x2 vector at the position identified by <em>id</em>.  <a href="a00419.html#ga9974d84f9b9b0235dc5fc091962c74d1">More...</a><br/></td></tr>
<tr class="separator:ga9974d84f9b9b0235dc5fc091962c74d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf84994b61a45cc01ddbb1e2dc7f53fa"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:gabf84994b61a45cc01ddbb1e2dc7f53fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gabf84994b61a45cc01ddbb1e2dc7f53fa">insert</a> (<a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> a, float x)</td></tr>
<tr class="memdesc:gabf84994b61a45cc01ddbb1e2dc7f53fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into float32x4 vector at the position identified by <em>id</em>.  <a href="a00419.html#gabf84994b61a45cc01ddbb1e2dc7f53fa">More...</a><br/></td></tr>
<tr class="separator:gabf84994b61a45cc01ddbb1e2dc7f53fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b92c216c5de759709d649da37cecb0b"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ga2b92c216c5de759709d649da37cecb0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga2b92c216c5de759709d649da37cecb0b">insert</a> (<a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a> a, double x)</td></tr>
<tr class="memdesc:ga2b92c216c5de759709d649da37cecb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into float64x2 vector at the position identified by <em>id</em>.  <a href="a00419.html#ga2b92c216c5de759709d649da37cecb0b">More...</a><br/></td></tr>
<tr class="separator:ga2b92c216c5de759709d649da37cecb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17909e0c29acc56a595ee0aeeec84c89"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_load&gt; </td></tr>
<tr class="memitem:a17909e0c29acc56a595ee0aeeec84c89"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a17909e0c29acc56a595ee0aeeec84c89">load</a> (const void *p)</td></tr>
<tr class="memdesc:a17909e0c29acc56a595ee0aeeec84c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an aligned memory location.  <a href="#a17909e0c29acc56a595ee0aeeec84c89">More...</a><br/></td></tr>
<tr class="separator:a17909e0c29acc56a595ee0aeeec84c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2f9c00491ea9b9cd505fd210aba587"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:a6b2f9c00491ea9b9cd505fd210aba587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a6b2f9c00491ea9b9cd505fd210aba587">load_packed2</a> (<a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a, <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;b, const void *p)</td></tr>
<tr class="memdesc:a6b2f9c00491ea9b9cd505fd210aba587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads values packed in pairs, de-interleaves them and stores the result into two vectors.  <a href="#a6b2f9c00491ea9b9cd505fd210aba587">More...</a><br/></td></tr>
<tr class="separator:a6b2f9c00491ea9b9cd505fd210aba587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3ea7d47c0cc2d7a0ba7014a54f52ad"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:a7a3ea7d47c0cc2d7a0ba7014a54f52ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7a3ea7d47c0cc2d7a0ba7014a54f52ad">load_packed3</a> (<a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a, <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;b, <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;c, const void *p)</td></tr>
<tr class="memdesc:a7a3ea7d47c0cc2d7a0ba7014a54f52ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads values packed in triplets, de-interleaves them and stores the result into three vectors.  <a href="#a7a3ea7d47c0cc2d7a0ba7014a54f52ad">More...</a><br/></td></tr>
<tr class="separator:a7a3ea7d47c0cc2d7a0ba7014a54f52ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab028abe337e2a34dbafcf356e5133ad2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:ab028abe337e2a34dbafcf356e5133ad2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab028abe337e2a34dbafcf356e5133ad2">load_packed4</a> (<a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a, <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;b, <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;c, <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;d, const void *p)</td></tr>
<tr class="memdesc:ab028abe337e2a34dbafcf356e5133ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads values packed in quartets, de-interleaves them and stores the result into four vectors.  <a href="#ab028abe337e2a34dbafcf356e5133ad2">More...</a><br/></td></tr>
<tr class="separator:ab028abe337e2a34dbafcf356e5133ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277e4fbdef7f737096d9a5122fff259d"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_load_splat&gt; </td></tr>
<tr class="memitem:a277e4fbdef7f737096d9a5122fff259d"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a277e4fbdef7f737096d9a5122fff259d">load_splat</a> (const void *p)</td></tr>
<tr class="memdesc:a277e4fbdef7f737096d9a5122fff259d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a memory location and broadcasts it to all elements of a vector.  <a href="#a277e4fbdef7f737096d9a5122fff259d">More...</a><br/></td></tr>
<tr class="separator:a277e4fbdef7f737096d9a5122fff259d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aa85fde44d769baa5132b630bdffc3"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_load_u&gt; </td></tr>
<tr class="memitem:a47aa85fde44d769baa5132b630bdffc3"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a47aa85fde44d769baa5132b630bdffc3">load_u</a> (const void *p)</td></tr>
<tr class="memdesc:a47aa85fde44d769baa5132b630bdffc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location.  <a href="#a47aa85fde44d769baa5132b630bdffc3">More...</a><br/></td></tr>
<tr class="separator:a47aa85fde44d769baa5132b630bdffc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ba99d37d67ca5723a3ad8c2b4d8d9d"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a87ba99d37d67ca5723a3ad8c2b4d8d9d"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a87ba99d37d67ca5723a3ad8c2b4d8d9d">permute2</a> (const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a87ba99d37d67ca5723a3ad8c2b4d8d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the 16-bit values within sets of two consecutive elements of the vector.  <a href="#a87ba99d37d67ca5723a3ad8c2b4d8d9d">More...</a><br/></td></tr>
<tr class="separator:a87ba99d37d67ca5723a3ad8c2b4d8d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34cb76d09ec6eb6d1ff8a19f57e4710"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned N, class V &gt; </td></tr>
<tr class="memitem:ab34cb76d09ec6eb6d1ff8a19f57e4710"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab34cb76d09ec6eb6d1ff8a19f57e4710">permute2</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:ab34cb76d09ec6eb6d1ff8a19f57e4710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the values of each set of four consecutive 32-bit values.  <a href="#ab34cb76d09ec6eb6d1ff8a19f57e4710">More...</a><br/></td></tr>
<tr class="separator:ab34cb76d09ec6eb6d1ff8a19f57e4710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbba557b08a72b4146b070a2989cfec"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:affbba557b08a72b4146b070a2989cfec"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#affbba557b08a72b4146b070a2989cfec">shuffle1</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:affbba557b08a72b4146b070a2989cfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects 64-bit values from two vectors.  <a href="#affbba557b08a72b4146b070a2989cfec">More...</a><br/></td></tr>
<tr class="separator:affbba557b08a72b4146b070a2989cfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1152f57c44c2f45f338b1784b3dfb79d"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:a1152f57c44c2f45f338b1784b3dfb79d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1152f57c44c2f45f338b1784b3dfb79d">store</a> (void *p, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a1152f57c44c2f45f338b1784b3dfb79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer vector to an aligned memory location.  <a href="#a1152f57c44c2f45f338b1784b3dfb79d">More...</a><br/></td></tr>
<tr class="separator:a1152f57c44c2f45f338b1784b3dfb79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546250aeec49e4ad17dd6165c1d898ac"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:a546250aeec49e4ad17dd6165c1d898ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a546250aeec49e4ad17dd6165c1d898ac">store_first</a> (void *p, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a, unsigned n)</td></tr>
<tr class="memdesc:a546250aeec49e4ad17dd6165c1d898ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#a546250aeec49e4ad17dd6165c1d898ac">More...</a><br/></td></tr>
<tr class="separator:a546250aeec49e4ad17dd6165c1d898ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c78ca857e9602b2574aad59593467c6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:a7c78ca857e9602b2574aad59593467c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7c78ca857e9602b2574aad59593467c6">store_last</a> (void *p, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a, unsigned n)</td></tr>
<tr class="memdesc:a7c78ca857e9602b2574aad59593467c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory.  <a href="#a7c78ca857e9602b2574aad59593467c6">More...</a><br/></td></tr>
<tr class="separator:a7c78ca857e9602b2574aad59593467c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717be328c9b42a1ac2206afe4ce7f276"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a717be328c9b42a1ac2206afe4ce7f276"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a717be328c9b42a1ac2206afe4ce7f276">store_packed2</a> (void *p, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a717be328c9b42a1ac2206afe4ce7f276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves values from two vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#a717be328c9b42a1ac2206afe4ce7f276">More...</a><br/></td></tr>
<tr class="separator:a717be328c9b42a1ac2206afe4ce7f276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c7905c8e7a5a932f089ee917158f52"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 , class V3 &gt; </td></tr>
<tr class="memitem:a32c7905c8e7a5a932f089ee917158f52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a32c7905c8e7a5a932f089ee917158f52">store_packed3</a> (void *p, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;b, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V3 &gt; &amp;c)</td></tr>
<tr class="memdesc:a32c7905c8e7a5a932f089ee917158f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves values from three vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#a32c7905c8e7a5a932f089ee917158f52">More...</a><br/></td></tr>
<tr class="separator:a32c7905c8e7a5a932f089ee917158f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506e25cb408021324450a48d2b026711"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 , class V3 , class V4 &gt; </td></tr>
<tr class="memitem:a506e25cb408021324450a48d2b026711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a506e25cb408021324450a48d2b026711">store_packed4</a> (void *p, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;b, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V3 &gt; &amp;c, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V4 &gt; &amp;d)</td></tr>
<tr class="memdesc:a506e25cb408021324450a48d2b026711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves values from four vectors and stores the result into successive locations starting from <em>p</em>.  <a href="#a506e25cb408021324450a48d2b026711">More...</a><br/></td></tr>
<tr class="separator:a506e25cb408021324450a48d2b026711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbefc2f4e28510d793e341155120a398"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:adbefc2f4e28510d793e341155120a398"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#adbefc2f4e28510d793e341155120a398">stream</a> (void *p, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:adbefc2f4e28510d793e341155120a398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible.  <a href="#adbefc2f4e28510d793e341155120a398">More...</a><br/></td></tr>
<tr class="separator:adbefc2f4e28510d793e341155120a398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376f8c92d44d07b0c03d834a837a135f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a376f8c92d44d07b0c03d834a837a135f">to_int16</a> (<a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> a)</td></tr>
<tr class="memdesc:a376f8c92d44d07b0c03d834a837a135f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign extends the 16 values of a signed int8x16 vector to 16-bits.  <a href="#a376f8c92d44d07b0c03d834a837a135f">More...</a><br/></td></tr>
<tr class="separator:a376f8c92d44d07b0c03d834a837a135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9effcb099bd1d651e6a8e9847e53616c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a9effcb099bd1d651e6a8e9847e53616c">to_int16</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a)</td></tr>
<tr class="memdesc:a9effcb099bd1d651e6a8e9847e53616c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the 16 values of a unsigned int8x16 vector to 16-bits.  <a href="#a9effcb099bd1d651e6a8e9847e53616c">More...</a><br/></td></tr>
<tr class="separator:a9effcb099bd1d651e6a8e9847e53616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349a89131862d8d7669d04c14b31873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a7349a89131862d8d7669d04c14b31873">to_int32</a> (<a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> a)</td></tr>
<tr class="memdesc:a7349a89131862d8d7669d04c14b31873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign extends the first 8 values of a signed int16x16 vector to 32-bits.  <a href="#a7349a89131862d8d7669d04c14b31873">More...</a><br/></td></tr>
<tr class="separator:a7349a89131862d8d7669d04c14b31873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a323beafc7ae25d22635e7d61efc834"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a8a323beafc7ae25d22635e7d61efc834"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8a323beafc7ae25d22635e7d61efc834">unzip16_lo</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a8a323beafc7ae25d22635e7d61efc834"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two int8x16 vectors.  <a href="#a8a323beafc7ae25d22635e7d61efc834">More...</a><br/></td></tr>
<tr class="separator:a8a323beafc7ae25d22635e7d61efc834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997d97556f3330df92cf84a07202165d"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a997d97556f3330df92cf84a07202165d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a997d97556f3330df92cf84a07202165d">unzip8_lo</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a997d97556f3330df92cf84a07202165d"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two int16x8 vectors.  <a href="#a997d97556f3330df92cf84a07202165d">More...</a><br/></td></tr>
<tr class="separator:a997d97556f3330df92cf84a07202165d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb5639f374f21f0d0ebd2f7b00b45d5"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a9eb5639f374f21f0d0ebd2f7b00b45d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9eb5639f374f21f0d0ebd2f7b00b45d5">unzip4_lo</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a9eb5639f374f21f0d0ebd2f7b00b45d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two int32x4 vectors.  <a href="#a9eb5639f374f21f0d0ebd2f7b00b45d5">More...</a><br/></td></tr>
<tr class="separator:a9eb5639f374f21f0d0ebd2f7b00b45d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffbd2ad2a07ce3f5f38e99a81ea3ccf"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:aeffbd2ad2a07ce3f5f38e99a81ea3ccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aeffbd2ad2a07ce3f5f38e99a81ea3ccf">unzip2_lo</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E1 &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:aeffbd2ad2a07ce3f5f38e99a81ea3ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two int64x2 vectors.  <a href="#aeffbd2ad2a07ce3f5f38e99a81ea3ccf">More...</a><br/></td></tr>
<tr class="separator:aeffbd2ad2a07ce3f5f38e99a81ea3ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7100ed95653d03e8d591f61af55d81"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:aed7100ed95653d03e8d591f61af55d81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aed7100ed95653d03e8d591f61af55d81">unzip4_lo</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:aed7100ed95653d03e8d591f61af55d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two float32x4 vectors.  <a href="#aed7100ed95653d03e8d591f61af55d81">More...</a><br/></td></tr>
<tr class="separator:aed7100ed95653d03e8d591f61af55d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485e9564f15bb893facf54fd9e15dfb5"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a485e9564f15bb893facf54fd9e15dfb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00021.html">float64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a485e9564f15bb893facf54fd9e15dfb5">unzip2_lo</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a485e9564f15bb893facf54fd9e15dfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the odd(lower) elements of two float64x2 vectors.  <a href="#a485e9564f15bb893facf54fd9e15dfb5">More...</a><br/></td></tr>
<tr class="separator:a485e9564f15bb893facf54fd9e15dfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3cea09a5284378a9e3a78a69fc9ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a8b3cea09a5284378a9e3a78a69fc9ac0">get_arch_gcc_builtin_cpu_supports</a> ()</td></tr>
<tr class="memdesc:a8b3cea09a5284378a9e3a78a69fc9ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves supported architecture using GCC __builtin_cpu_supports function.  <a href="#a8b3cea09a5284378a9e3a78a69fc9ac0">More...</a><br/></td></tr>
<tr class="separator:a8b3cea09a5284378a9e3a78a69fc9ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b6262cf9b117f1fbfb9ca516ce4212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a70b6262cf9b117f1fbfb9ca516ce4212">get_arch_linux_cpuinfo</a> ()</td></tr>
<tr class="memdesc:a70b6262cf9b117f1fbfb9ca516ce4212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves supported architecture from Linux /proc/cpuinfo file.  <a href="#a70b6262cf9b117f1fbfb9ca516ce4212">More...</a><br/></td></tr>
<tr class="separator:a70b6262cf9b117f1fbfb9ca516ce4212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a7e1d9682d0b80ae217d881ebd4b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#ga76a7e1d9682d0b80ae217d881ebd4b56">this_compile_arch</a> ()</td></tr>
<tr class="memdesc:ga76a7e1d9682d0b80ae217d881ebd4b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instruction set flags that will be required by the currently compiled code.  <a href="a00420.html#ga76a7e1d9682d0b80ae217d881ebd4b56">More...</a><br/></td></tr>
<tr class="separator:ga76a7e1d9682d0b80ae217d881ebd4b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gae9c4ddfb3718c3950e590a8560fa1303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gae9c4ddfb3718c3950e590a8560fa1303">transpose2</a> (<a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;a0, <a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;a1)</td></tr>
<tr class="memdesc:gae9c4ddfb3718c3950e590a8560fa1303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 2x2 32-bit matrices within two int32x4 vectors.  <a href="a00417.html#gae9c4ddfb3718c3950e590a8560fa1303">More...</a><br/></td></tr>
<tr class="separator:gae9c4ddfb3718c3950e590a8560fa1303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3784daf432503a9aa5c6338b5740770a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga3784daf432503a9aa5c6338b5740770a">transpose2</a> (<a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;a0, <a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;a1)</td></tr>
<tr class="memdesc:ga3784daf432503a9aa5c6338b5740770a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 2x2 32-bit matrices within two int32x4 vectors.  <a href="a00417.html#ga3784daf432503a9aa5c6338b5740770a">More...</a><br/></td></tr>
<tr class="separator:ga3784daf432503a9aa5c6338b5740770a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24f0bc8967ec16590ae5b1e8e87c95ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga24f0bc8967ec16590ae5b1e8e87c95ca">transpose2</a> (<a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> &amp;a0, <a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> &amp;a1)</td></tr>
<tr class="memdesc:ga24f0bc8967ec16590ae5b1e8e87c95ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 2x2 32-bit matrices within two int32x4 vectors.  <a href="a00417.html#ga24f0bc8967ec16590ae5b1e8e87c95ca">More...</a><br/></td></tr>
<tr class="separator:ga24f0bc8967ec16590ae5b1e8e87c95ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadabd298b232d28c39a2afab5b5665b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gadabd298b232d28c39a2afab5b5665b9e">transpose2</a> (<a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> &amp;a0, <a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> &amp;a1)</td></tr>
<tr class="memdesc:gadabd298b232d28c39a2afab5b5665b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 2x2 32-bit matrices within two int32x4 vectors.  <a href="a00417.html#gadabd298b232d28c39a2afab5b5665b9e">More...</a><br/></td></tr>
<tr class="separator:gadabd298b232d28c39a2afab5b5665b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga3820662e53edcd9b0cf43b5274517c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga3820662e53edcd9b0cf43b5274517c34">transpose2</a> (<a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a> &amp;a0, <a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a> &amp;a1)</td></tr>
<tr class="memdesc:ga3820662e53edcd9b0cf43b5274517c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 2x2 64-bit matrix within two int64x2 vectors.  <a href="a00417.html#ga3820662e53edcd9b0cf43b5274517c34">More...</a><br/></td></tr>
<tr class="separator:ga3820662e53edcd9b0cf43b5274517c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6b154ad129f7d9ff1ff9647e8b9ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga2a6b154ad129f7d9ff1ff9647e8b9ed6">transpose2</a> (<a class="el" href="a00156.html#a44fea5c7167ea63298fe297c499d9814">int64x2</a> &amp;a0, <a class="el" href="a00156.html#a44fea5c7167ea63298fe297c499d9814">int64x2</a> &amp;a1)</td></tr>
<tr class="memdesc:ga2a6b154ad129f7d9ff1ff9647e8b9ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 2x2 64-bit matrix within two int64x2 vectors.  <a href="a00417.html#ga2a6b154ad129f7d9ff1ff9647e8b9ed6">More...</a><br/></td></tr>
<tr class="separator:ga2a6b154ad129f7d9ff1ff9647e8b9ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae205f12d9d9dd5dda8f63414a3b7d0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gae205f12d9d9dd5dda8f63414a3b7d0d0">transpose2</a> (<a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a> &amp;a0, <a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a> &amp;a1)</td></tr>
<tr class="memdesc:gae205f12d9d9dd5dda8f63414a3b7d0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 2x2 64-bit matrix within two int64x2 vectors.  <a href="a00417.html#gae205f12d9d9dd5dda8f63414a3b7d0d0">More...</a><br/></td></tr>
<tr class="separator:gae205f12d9d9dd5dda8f63414a3b7d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da91bb756c9c7d40da09e3cfdc1168e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga5da91bb756c9c7d40da09e3cfdc1168e">transpose2</a> (<a class="el" href="a00156.html#a8da9597a0403650325e7b0df8893d6a3">int64x4</a> &amp;a0, <a class="el" href="a00156.html#a8da9597a0403650325e7b0df8893d6a3">int64x4</a> &amp;a1)</td></tr>
<tr class="memdesc:ga5da91bb756c9c7d40da09e3cfdc1168e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 2x2 64-bit matrix within two int64x2 vectors.  <a href="a00417.html#ga5da91bb756c9c7d40da09e3cfdc1168e">More...</a><br/></td></tr>
<tr class="separator:ga5da91bb756c9c7d40da09e3cfdc1168e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaab244b887d872761f969be08aabd7114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gaab244b887d872761f969be08aabd7114">transpose2</a> (<a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;a0, <a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;a1)</td></tr>
<tr class="memdesc:gaab244b887d872761f969be08aabd7114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 2x2 32-bit matrices within two float32x4 vectors.  <a href="a00417.html#gaab244b887d872761f969be08aabd7114">More...</a><br/></td></tr>
<tr class="separator:gaab244b887d872761f969be08aabd7114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbbb6033e70b6edb0df781e826793e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga2cbbb6033e70b6edb0df781e826793e5">transpose2</a> (<a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> &amp;a0, <a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> &amp;a1)</td></tr>
<tr class="memdesc:ga2cbbb6033e70b6edb0df781e826793e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 2x2 32-bit matrices within two float32x4 vectors.  <a href="a00417.html#ga2cbbb6033e70b6edb0df781e826793e5">More...</a><br/></td></tr>
<tr class="separator:ga2cbbb6033e70b6edb0df781e826793e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad907e8f074e9f072bc31eb27b087cd2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gad907e8f074e9f072bc31eb27b087cd2f">transpose2</a> (<a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a> &amp;a0, <a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a> &amp;a1)</td></tr>
<tr class="memdesc:gad907e8f074e9f072bc31eb27b087cd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 2x2 64-bit matrix within two int64x2 vectors.  <a href="a00417.html#gad907e8f074e9f072bc31eb27b087cd2f">More...</a><br/></td></tr>
<tr class="separator:gad907e8f074e9f072bc31eb27b087cd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840be7c11344bdcdb142cff75b663989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga840be7c11344bdcdb142cff75b663989">transpose2</a> (<a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> &amp;a0, <a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> &amp;a1)</td></tr>
<tr class="memdesc:ga840be7c11344bdcdb142cff75b663989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 2x2 64-bit matrix within two int64x2 vectors.  <a href="a00417.html#ga840be7c11344bdcdb142cff75b663989">More...</a><br/></td></tr>
<tr class="separator:ga840be7c11344bdcdb142cff75b663989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga32e76a49e631064c6a98f6d743ec6522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga32e76a49e631064c6a98f6d743ec6522">transpose4</a> (<a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;a0, <a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;a1, <a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;a2, <a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;a3)</td></tr>
<tr class="memdesc:ga32e76a49e631064c6a98f6d743ec6522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 4x4 32-bit matrix within four int32x4 vectors.  <a href="a00417.html#ga32e76a49e631064c6a98f6d743ec6522">More...</a><br/></td></tr>
<tr class="separator:ga32e76a49e631064c6a98f6d743ec6522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ebb097c45c4ad49c3480bc8b56cb05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga52ebb097c45c4ad49c3480bc8b56cb05">transpose4</a> (<a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;a0, <a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;a1, <a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;a2, <a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;a3)</td></tr>
<tr class="memdesc:ga52ebb097c45c4ad49c3480bc8b56cb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 4x4 32-bit matrix within four int32x4 vectors.  <a href="a00417.html#ga52ebb097c45c4ad49c3480bc8b56cb05">More...</a><br/></td></tr>
<tr class="separator:ga52ebb097c45c4ad49c3480bc8b56cb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b30a0da2621e7b48dafc433bf7733f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga93b30a0da2621e7b48dafc433bf7733f">transpose4</a> (<a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> &amp;a0, <a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> &amp;a1, <a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> &amp;a2, <a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> &amp;a3)</td></tr>
<tr class="memdesc:ga93b30a0da2621e7b48dafc433bf7733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a 4x4 32-bit matrix within four int32x4 vectors.  <a href="a00417.html#ga93b30a0da2621e7b48dafc433bf7733f">More...</a><br/></td></tr>
<tr class="separator:ga93b30a0da2621e7b48dafc433bf7733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gab6724244ae2b0a6c6631098bfd0ebfc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gab6724244ae2b0a6c6631098bfd0ebfc9">transpose4</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a0, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a1, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a2, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;a3)</td></tr>
<tr class="memdesc:gab6724244ae2b0a6c6631098bfd0ebfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes four 4x4 8-bit matrix within four int8x16 vectors.  <a href="a00417.html#gab6724244ae2b0a6c6631098bfd0ebfc9">More...</a><br/></td></tr>
<tr class="separator:gab6724244ae2b0a6c6631098bfd0ebfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7053946d22c812649a2a2eca364cba13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga7053946d22c812649a2a2eca364cba13">transpose4</a> (<a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a0, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a1, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a2, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;a3)</td></tr>
<tr class="memdesc:ga7053946d22c812649a2a2eca364cba13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes four 4x4 8-bit matrix within four int8x16 vectors.  <a href="a00417.html#ga7053946d22c812649a2a2eca364cba13">More...</a><br/></td></tr>
<tr class="separator:ga7053946d22c812649a2a2eca364cba13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a1009220a34b14eea456dec5968509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga82a1009220a34b14eea456dec5968509">transpose4</a> (<a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> &amp;a0, <a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> &amp;a1, <a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> &amp;a2, <a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> &amp;a3)</td></tr>
<tr class="memdesc:ga82a1009220a34b14eea456dec5968509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes four 4x4 8-bit matrix within four int8x16 vectors.  <a href="a00417.html#ga82a1009220a34b14eea456dec5968509">More...</a><br/></td></tr>
<tr class="separator:ga82a1009220a34b14eea456dec5968509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c517fcd394f48e3c8f0a2a143a6ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gae0c517fcd394f48e3c8f0a2a143a6ec7">transpose4</a> (<a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a0, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a1, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a2, <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> &amp;a3)</td></tr>
<tr class="memdesc:gae0c517fcd394f48e3c8f0a2a143a6ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes four 4x4 8-bit matrix within four int8x16 vectors.  <a href="a00417.html#gae0c517fcd394f48e3c8f0a2a143a6ec7">More...</a><br/></td></tr>
<tr class="separator:gae0c517fcd394f48e3c8f0a2a143a6ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e41c4d2ef059e4746c0d9f10a39096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gad3e41c4d2ef059e4746c0d9f10a39096">transpose4</a> (<a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a0, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a1, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a2, <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> &amp;a3)</td></tr>
<tr class="memdesc:gad3e41c4d2ef059e4746c0d9f10a39096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes four 4x4 8-bit matrix within four int8x16 vectors.  <a href="a00417.html#gad3e41c4d2ef059e4746c0d9f10a39096">More...</a><br/></td></tr>
<tr class="separator:gad3e41c4d2ef059e4746c0d9f10a39096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga6795d135f4be3aa7f15f680c73395634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga6795d135f4be3aa7f15f680c73395634">transpose4</a> (<a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a0, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a1, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a2, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;a3)</td></tr>
<tr class="memdesc:ga6795d135f4be3aa7f15f680c73395634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 4x4 16-bit matrices within four int16x8 vectors.  <a href="a00417.html#ga6795d135f4be3aa7f15f680c73395634">More...</a><br/></td></tr>
<tr class="separator:ga6795d135f4be3aa7f15f680c73395634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b9f74a28ad90db99d6c6402bfb1c4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gaf5b9f74a28ad90db99d6c6402bfb1c4f">transpose4</a> (<a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a0, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a1, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a2, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;a3)</td></tr>
<tr class="memdesc:gaf5b9f74a28ad90db99d6c6402bfb1c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 4x4 16-bit matrices within four int16x8 vectors.  <a href="a00417.html#gaf5b9f74a28ad90db99d6c6402bfb1c4f">More...</a><br/></td></tr>
<tr class="separator:gaf5b9f74a28ad90db99d6c6402bfb1c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c3c2a87fbdcc44bd976648ee21a868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gad3c3c2a87fbdcc44bd976648ee21a868">transpose4</a> (<a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a0, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a1, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a2, <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> &amp;a3)</td></tr>
<tr class="memdesc:gad3c3c2a87fbdcc44bd976648ee21a868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 4x4 16-bit matrices within four int16x8 vectors.  <a href="a00417.html#gad3c3c2a87fbdcc44bd976648ee21a868">More...</a><br/></td></tr>
<tr class="separator:gad3c3c2a87fbdcc44bd976648ee21a868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73bfcfb3e60b43f1c52d411621b2042f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga73bfcfb3e60b43f1c52d411621b2042f">transpose4</a> (<a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a0, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a1, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a2, <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> &amp;a3)</td></tr>
<tr class="memdesc:ga73bfcfb3e60b43f1c52d411621b2042f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes two 4x4 16-bit matrices within four int16x8 vectors.  <a href="a00417.html#ga73bfcfb3e60b43f1c52d411621b2042f">More...</a><br/></td></tr>
<tr class="separator:ga73bfcfb3e60b43f1c52d411621b2042f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga7d2aa3ffe30b5a765ac8e36f0a222fc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#ga7d2aa3ffe30b5a765ac8e36f0a222fc5">transpose4</a> (<a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;a0, <a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;a1, <a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;a2, <a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;a3)</td></tr>
<tr class="memdesc:ga7d2aa3ffe30b5a765ac8e36f0a222fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes 4x4 32-bit matrix within four float32x4 vectors.  <a href="a00417.html#ga7d2aa3ffe30b5a765ac8e36f0a222fc5">More...</a><br/></td></tr>
<tr class="separator:ga7d2aa3ffe30b5a765ac8e36f0a222fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac318c65f439880f5e446bd146a4626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html#gadac318c65f439880f5e446bd146a4626">transpose4</a> (<a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> &amp;a0, <a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> &amp;a1, <a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> &amp;a2, <a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> &amp;a3)</td></tr>
<tr class="memdesc:gadac318c65f439880f5e446bd146a4626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes 4x4 32-bit matrix within four float32x4 vectors.  <a href="a00417.html#gadac318c65f439880f5e446bd146a4626">More...</a><br/></td></tr>
<tr class="separator:gadac318c65f439880f5e446bd146a4626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af5a6527022ce4932db59e1a87f7821ff"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:af5a6527022ce4932db59e1a87f7821ff"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_bitwise2_and<br class="typebreak"/>
&lt; <a class="el" href="a00037.html">expr_bit_and</a>, V1, V2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af5a6527022ce4932db59e1a87f7821ff">bit_and</a> (const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:af5a6527022ce4932db59e1a87f7821ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND of integer or floating-point vectors.  <a href="#af5a6527022ce4932db59e1a87f7821ff">More...</a><br/></td></tr>
<tr class="separator:af5a6527022ce4932db59e1a87f7821ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1016baf256694f76d82b3072f78cccef"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a1016baf256694f76d82b3072f78cccef"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_bitwise2_and<br class="typebreak"/>
&lt; <a class="el" href="a00038.html">expr_bit_andnot</a>, V1, V2 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1016baf256694f76d82b3072f78cccef">bit_andnot</a> (const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a1016baf256694f76d82b3072f78cccef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise AND NOT of two integer or floating-point vectors.  <a href="#a1016baf256694f76d82b3072f78cccef">More...</a><br/></td></tr>
<tr class="separator:a1016baf256694f76d82b3072f78cccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af3de71e1769b7a7cb55190c310eea586"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V &gt; </td></tr>
<tr class="memitem:af3de71e1769b7a7cb55190c310eea586"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr&lt; V, <br class="typebreak"/>
<a class="el" href="a00039.html">expr_bit_not</a>&lt; V &gt; &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af3de71e1769b7a7cb55190c310eea586">bit_not</a> (const <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:af3de71e1769b7a7cb55190c310eea586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise NOT of an integer or floating-point vector.  <a href="#af3de71e1769b7a7cb55190c310eea586">More...</a><br/></td></tr>
<tr class="separator:af3de71e1769b7a7cb55190c310eea586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acfd16fff7c5da4de8cce786a2be51ec4"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:acfd16fff7c5da4de8cce786a2be51ec4"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_bit_or&lt; V1, <br class="typebreak"/>
V2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#acfd16fff7c5da4de8cce786a2be51ec4">bit_or</a> (const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:acfd16fff7c5da4de8cce786a2be51ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitwise OR of integer vectors.  <a href="#acfd16fff7c5da4de8cce786a2be51ec4">More...</a><br/></td></tr>
<tr class="separator:acfd16fff7c5da4de8cce786a2be51ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a085ed17ba35931a9944ea035f1c38a51"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 , class V3 &gt; </td></tr>
<tr class="memitem:a085ed17ba35931a9944ea035f1c38a51"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_blend&lt; V1, V2, <br class="typebreak"/>
V3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a085ed17ba35931a9944ea035f1c38a51">blend</a> (const <a class="el" href="a00018.html">any_vec</a>&lt; N, V1 &gt; &amp;on, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V2 &gt; &amp;off, const <a class="el" href="a00018.html">any_vec</a>&lt; N, V3 &gt; &amp;mask)</td></tr>
<tr class="memdesc:a085ed17ba35931a9944ea035f1c38a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a vector from two sources according to a mask.  <a href="#a085ed17ba35931a9944ea035f1c38a51">More...</a><br/></td></tr>
<tr class="separator:a085ed17ba35931a9944ea035f1c38a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a19eba8f61d67c53d5e7e780ad78b90a7"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a19eba8f61d67c53d5e7e780ad78b90a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a19eba8f61d67c53d5e7e780ad78b90a7">cmp_ge</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a19eba8f61d67c53d5e7e780ad78b90a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float32x4 vectors for greater-than or equal.  <a href="#a19eba8f61d67c53d5e7e780ad78b90a7">More...</a><br/></td></tr>
<tr class="separator:a19eba8f61d67c53d5e7e780ad78b90a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a752a838918ba7e87a3a98b348d0edead"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a752a838918ba7e87a3a98b348d0edead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00029.html">mask_int32</a>&lt; N, <a class="el" href="a00029.html">mask_int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a752a838918ba7e87a3a98b348d0edead">cmp_gt</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a752a838918ba7e87a3a98b348d0edead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two signed int32x4 vectors for greater-than.  <a href="#a752a838918ba7e87a3a98b348d0edead">More...</a><br/></td></tr>
<tr class="separator:a752a838918ba7e87a3a98b348d0edead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134fbc50643558a9e15391156671ef3c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a134fbc50643558a9e15391156671ef3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00029.html">mask_int32</a>&lt; N, <a class="el" href="a00029.html">mask_int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a134fbc50643558a9e15391156671ef3c">cmp_gt</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a134fbc50643558a9e15391156671ef3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two unsigned int32x4 vectors for greater-than.  <a href="#a134fbc50643558a9e15391156671ef3c">More...</a><br/></td></tr>
<tr class="separator:a134fbc50643558a9e15391156671ef3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14e60d5cd592795e4c42b2a401468b4"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ad14e60d5cd592795e4c42b2a401468b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad14e60d5cd592795e4c42b2a401468b4">cmp_gt</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ad14e60d5cd592795e4c42b2a401468b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float32x4 vectors for greater-than.  <a href="#ad14e60d5cd592795e4c42b2a401468b4">More...</a><br/></td></tr>
<tr class="separator:ad14e60d5cd592795e4c42b2a401468b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42af1ab59dcfcc50e3c3ed5724f53394"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a42af1ab59dcfcc50e3c3ed5724f53394"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a42af1ab59dcfcc50e3c3ed5724f53394">cmp_gt</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a42af1ab59dcfcc50e3c3ed5724f53394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float64x2 vectors for greater-than.  <a href="#a42af1ab59dcfcc50e3c3ed5724f53394">More...</a><br/></td></tr>
<tr class="separator:a42af1ab59dcfcc50e3c3ed5724f53394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a593c9b03a4b46c8956d027131e74e0cc"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a593c9b03a4b46c8956d027131e74e0cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a593c9b03a4b46c8956d027131e74e0cc">cmp_le</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a593c9b03a4b46c8956d027131e74e0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float32x4 vectors for less-than or equal.  <a href="#a593c9b03a4b46c8956d027131e74e0cc">More...</a><br/></td></tr>
<tr class="separator:a593c9b03a4b46c8956d027131e74e0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1ba7095331a10a009b764e4863a701d7"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a1ba7095331a10a009b764e4863a701d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1ba7095331a10a009b764e4863a701d7">cmp_le</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a1ba7095331a10a009b764e4863a701d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float64x2 vectors for less-than or equal.  <a href="#a1ba7095331a10a009b764e4863a701d7">More...</a><br/></td></tr>
<tr class="separator:a1ba7095331a10a009b764e4863a701d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9498cc8ba92adb2f994b0eaba4c5b1b6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a9498cc8ba92adb2f994b0eaba4c5b1b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00031.html">mask_int8</a>&lt; N, <a class="el" href="a00031.html">mask_int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9498cc8ba92adb2f994b0eaba4c5b1b6">cmp_lt</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a9498cc8ba92adb2f994b0eaba4c5b1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two signed int8x16 vectors for less-than.  <a href="#a9498cc8ba92adb2f994b0eaba4c5b1b6">More...</a><br/></td></tr>
<tr class="separator:a9498cc8ba92adb2f994b0eaba4c5b1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1dbb083b65d56e2073f0f9ff9c3f98"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ace1dbb083b65d56e2073f0f9ff9c3f98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00031.html">mask_int8</a>&lt; N, <a class="el" href="a00031.html">mask_int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ace1dbb083b65d56e2073f0f9ff9c3f98">cmp_lt</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ace1dbb083b65d56e2073f0f9ff9c3f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two unsigned int8x16 vectors for less-than.  <a href="#ace1dbb083b65d56e2073f0f9ff9c3f98">More...</a><br/></td></tr>
<tr class="separator:ace1dbb083b65d56e2073f0f9ff9c3f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3525668b4f735a062ddcacd69a33f5a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ab3525668b4f735a062ddcacd69a33f5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00028.html">mask_int16</a>&lt; N, <a class="el" href="a00028.html">mask_int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab3525668b4f735a062ddcacd69a33f5a">cmp_lt</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ab3525668b4f735a062ddcacd69a33f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two signed int16x8 vectors for less-than.  <a href="#ab3525668b4f735a062ddcacd69a33f5a">More...</a><br/></td></tr>
<tr class="separator:ab3525668b4f735a062ddcacd69a33f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298e8a9c480893a98d99e4a3209c78f3"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a298e8a9c480893a98d99e4a3209c78f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00028.html">mask_int16</a>&lt; N, <a class="el" href="a00028.html">mask_int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a298e8a9c480893a98d99e4a3209c78f3">cmp_lt</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a298e8a9c480893a98d99e4a3209c78f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two unsigned int16x8 vectors for less-than.  <a href="#a298e8a9c480893a98d99e4a3209c78f3">More...</a><br/></td></tr>
<tr class="separator:a298e8a9c480893a98d99e4a3209c78f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422ed02dbb827cd50b280066e2bdb5c8"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a422ed02dbb827cd50b280066e2bdb5c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00029.html">mask_int32</a>&lt; N, <a class="el" href="a00029.html">mask_int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a422ed02dbb827cd50b280066e2bdb5c8">cmp_lt</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a422ed02dbb827cd50b280066e2bdb5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two signed int32x4 vectors for less-than.  <a href="#a422ed02dbb827cd50b280066e2bdb5c8">More...</a><br/></td></tr>
<tr class="separator:a422ed02dbb827cd50b280066e2bdb5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718f6b905432161df1c9a562e20c9e1"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:af718f6b905432161df1c9a562e20c9e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00029.html">mask_int32</a>&lt; N, <a class="el" href="a00029.html">mask_int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af718f6b905432161df1c9a562e20c9e1">cmp_lt</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:af718f6b905432161df1c9a562e20c9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two unsigned int32x4 vectors for less-than.  <a href="#af718f6b905432161df1c9a562e20c9e1">More...</a><br/></td></tr>
<tr class="separator:af718f6b905432161df1c9a562e20c9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9bfb844c4937b6a3596d0389ce8c33"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ada9bfb844c4937b6a3596d0389ce8c33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00026.html">mask_float32</a>&lt; N, <a class="el" href="a00026.html">mask_float32</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ada9bfb844c4937b6a3596d0389ce8c33">cmp_lt</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ada9bfb844c4937b6a3596d0389ce8c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float32x4 vectors for less-than.  <a href="#ada9bfb844c4937b6a3596d0389ce8c33">More...</a><br/></td></tr>
<tr class="separator:ada9bfb844c4937b6a3596d0389ce8c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc8ada68555518402452c364b0e566a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:aacc8ada68555518402452c364b0e566a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00027.html">mask_float64</a>&lt; N, <a class="el" href="a00027.html">mask_float64</a><br class="typebreak"/>
&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aacc8ada68555518402452c364b0e566a">cmp_lt</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:aacc8ada68555518402452c364b0e566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two float64x2 vectors for less-than.  <a href="#aacc8ada68555518402452c364b0e566a">More...</a><br/></td></tr>
<tr class="separator:aacc8ada68555518402452c364b0e566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga8ae0a1b7acca54340c9d286774aa158e"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ga8ae0a1b7acca54340c9d286774aa158e"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga8ae0a1b7acca54340c9d286774aa158e">extract</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a)</td></tr>
<tr class="memdesc:ga8ae0a1b7acca54340c9d286774aa158e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <em>id-th</em> element from int8x16 vector.  <a href="a00419.html#ga8ae0a1b7acca54340c9d286774aa158e">More...</a><br/></td></tr>
<tr class="separator:ga8ae0a1b7acca54340c9d286774aa158e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a2bbbc9397ed11f14ee42749cb9b82"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ga75a2bbbc9397ed11f14ee42749cb9b82"><td class="memTemplItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga75a2bbbc9397ed11f14ee42749cb9b82">extract</a> (<a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> a)</td></tr>
<tr class="memdesc:ga75a2bbbc9397ed11f14ee42749cb9b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <em>id-th</em> element from int8x16 vector.  <a href="a00419.html#ga75a2bbbc9397ed11f14ee42749cb9b82">More...</a><br/></td></tr>
<tr class="separator:ga75a2bbbc9397ed11f14ee42749cb9b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a904d3dd1e71c4ae9daf44d0a73fe3796"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:a904d3dd1e71c4ae9daf44d0a73fe3796"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a904d3dd1e71c4ae9daf44d0a73fe3796">extract</a> (<a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> a)</td></tr>
<tr class="memdesc:a904d3dd1e71c4ae9daf44d0a73fe3796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <em>id-th</em> element from int16x8 vector.  <a href="#a904d3dd1e71c4ae9daf44d0a73fe3796">More...</a><br/></td></tr>
<tr class="separator:a904d3dd1e71c4ae9daf44d0a73fe3796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4e3ace1e253a42b74dc10c453d885e"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:a1a4e3ace1e253a42b74dc10c453d885e"><td class="memTemplItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1a4e3ace1e253a42b74dc10c453d885e">extract</a> (<a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> a)</td></tr>
<tr class="memdesc:a1a4e3ace1e253a42b74dc10c453d885e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <em>id-th</em> element from int16x8 vector.  <a href="#a1a4e3ace1e253a42b74dc10c453d885e">More...</a><br/></td></tr>
<tr class="separator:a1a4e3ace1e253a42b74dc10c453d885e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab2e29f844da34ec7b359e960ae192220"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ab2e29f844da34ec7b359e960ae192220"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab2e29f844da34ec7b359e960ae192220">extract</a> (<a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> a)</td></tr>
<tr class="memdesc:ab2e29f844da34ec7b359e960ae192220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <em>id-th</em> element from int32x4 vector.  <a href="#ab2e29f844da34ec7b359e960ae192220">More...</a><br/></td></tr>
<tr class="separator:ab2e29f844da34ec7b359e960ae192220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373f7225a8274a1905b3e48acec813a4"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:a373f7225a8274a1905b3e48acec813a4"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a373f7225a8274a1905b3e48acec813a4">extract</a> (<a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> a)</td></tr>
<tr class="memdesc:a373f7225a8274a1905b3e48acec813a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the <em>id-th</em> element from int32x4 vector.  <a href="#a373f7225a8274a1905b3e48acec813a4">More...</a><br/></td></tr>
<tr class="separator:a373f7225a8274a1905b3e48acec813a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7ad1a019b5a959f79084e00fe630c385"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:a7ad1a019b5a959f79084e00fe630c385"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7ad1a019b5a959f79084e00fe630c385">extract</a> (<a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a> a)</td></tr>
<tr class="memdesc:a7ad1a019b5a959f79084e00fe630c385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from int64x2 vector.  <a href="#a7ad1a019b5a959f79084e00fe630c385">More...</a><br/></td></tr>
<tr class="separator:a7ad1a019b5a959f79084e00fe630c385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab959a0a29466b383029b93a3ec432318"><td class="memTemplParams" colspan="2">template&lt;unsigned id&gt; </td></tr>
<tr class="memitem:ab959a0a29466b383029b93a3ec432318"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab959a0a29466b383029b93a3ec432318">extract</a> (<a class="el" href="a00156.html#a44fea5c7167ea63298fe297c499d9814">int64x2</a> a)</td></tr>
<tr class="memdesc:ab959a0a29466b383029b93a3ec432318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from int64x2 vector.  <a href="#ab959a0a29466b383029b93a3ec432318">More...</a><br/></td></tr>
<tr class="separator:ab959a0a29466b383029b93a3ec432318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aab8d29fc607d1fd0f2d9c27fa5bf58a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aab8d29fc607d1fd0f2d9c27fa5bf58a6">split</a> (<a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a> a, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;r1, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> &amp;r2)</td></tr>
<tr class="memdesc:aab8d29fc607d1fd0f2d9c27fa5bf58a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#aab8d29fc607d1fd0f2d9c27fa5bf58a6">More...</a><br/></td></tr>
<tr class="separator:aab8d29fc607d1fd0f2d9c27fa5bf58a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c9a21785f1f285ae4ad3adf1ec78f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a072c9a21785f1f285ae4ad3adf1ec78f">split</a> (<a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> a, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;r1, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> &amp;r2)</td></tr>
<tr class="memdesc:a072c9a21785f1f285ae4ad3adf1ec78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a072c9a21785f1f285ae4ad3adf1ec78f">More...</a><br/></td></tr>
<tr class="separator:a072c9a21785f1f285ae4ad3adf1ec78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef25369afe28ca59e46db546fe83377d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aef25369afe28ca59e46db546fe83377d">split</a> (<a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a> a, <a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;r1, <a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> &amp;r2)</td></tr>
<tr class="memdesc:aef25369afe28ca59e46db546fe83377d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#aef25369afe28ca59e46db546fe83377d">More...</a><br/></td></tr>
<tr class="separator:aef25369afe28ca59e46db546fe83377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef334dbace19b13d421c64e1dc47b91f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#aef334dbace19b13d421c64e1dc47b91f">split</a> (<a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a> a, <a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a> &amp;r1, <a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">uint64x2</a> &amp;r2)</td></tr>
<tr class="memdesc:aef334dbace19b13d421c64e1dc47b91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#aef334dbace19b13d421c64e1dc47b91f">More...</a><br/></td></tr>
<tr class="separator:aef334dbace19b13d421c64e1dc47b91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cce187506c789249ecb7ebbd293f9ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a5cce187506c789249ecb7ebbd293f9ca">split</a> (<a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">int8x32</a> a, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;r1, <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">int8x16</a> &amp;r2)</td></tr>
<tr class="memdesc:a5cce187506c789249ecb7ebbd293f9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a5cce187506c789249ecb7ebbd293f9ca">More...</a><br/></td></tr>
<tr class="separator:a5cce187506c789249ecb7ebbd293f9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f3753dd8ffcadb3bc7705562154f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a38f3753dd8ffcadb3bc7705562154f7d">split</a> (<a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a> a, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;r1, <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">int16x8</a> &amp;r2)</td></tr>
<tr class="memdesc:a38f3753dd8ffcadb3bc7705562154f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a38f3753dd8ffcadb3bc7705562154f7d">More...</a><br/></td></tr>
<tr class="separator:a38f3753dd8ffcadb3bc7705562154f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9426fc7565df8d882437181c4e6ba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a7f9426fc7565df8d882437181c4e6ba6">split</a> (<a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> a, <a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;r1, <a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> &amp;r2)</td></tr>
<tr class="memdesc:a7f9426fc7565df8d882437181c4e6ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a7f9426fc7565df8d882437181c4e6ba6">More...</a><br/></td></tr>
<tr class="separator:a7f9426fc7565df8d882437181c4e6ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87db14817a18d000868f8028c10fe78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ae87db14817a18d000868f8028c10fe78">split</a> (<a class="el" href="a00156.html#a8da9597a0403650325e7b0df8893d6a3">int64x4</a> a, <a class="el" href="a00156.html#a44fea5c7167ea63298fe297c499d9814">int64x2</a> &amp;r1, <a class="el" href="a00156.html#a44fea5c7167ea63298fe297c499d9814">int64x2</a> &amp;r2)</td></tr>
<tr class="memdesc:ae87db14817a18d000868f8028c10fe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#ae87db14817a18d000868f8028c10fe78">More...</a><br/></td></tr>
<tr class="separator:ae87db14817a18d000868f8028c10fe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9396693f6a2b671ceedeced2688f301c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a9396693f6a2b671ceedeced2688f301c">split</a> (<a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a> a, <a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;r1, <a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> &amp;r2)</td></tr>
<tr class="memdesc:a9396693f6a2b671ceedeced2688f301c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a9396693f6a2b671ceedeced2688f301c">More...</a><br/></td></tr>
<tr class="separator:a9396693f6a2b671ceedeced2688f301c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3baa88b2bba9c9d3d2db89e8cd25e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#acc3baa88b2bba9c9d3d2db89e8cd25e5">split</a> (<a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> a, <a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a> &amp;r1, <a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">float64x2</a> &amp;r2)</td></tr>
<tr class="memdesc:acc3baa88b2bba9c9d3d2db89e8cd25e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#acc3baa88b2bba9c9d3d2db89e8cd25e5">More...</a><br/></td></tr>
<tr class="separator:acc3baa88b2bba9c9d3d2db89e8cd25e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb4f2319c022d466b3758e770e69130"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a4bb4f2319c022d466b3758e770e69130"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4bb4f2319c022d466b3758e770e69130">split</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00135.html">uint8</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a4bb4f2319c022d466b3758e770e69130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a4bb4f2319c022d466b3758e770e69130">More...</a><br/></td></tr>
<tr class="separator:a4bb4f2319c022d466b3758e770e69130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb0ce77c80ad79470310bb7f7737486"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a7bb0ce77c80ad79470310bb7f7737486"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7bb0ce77c80ad79470310bb7f7737486">split</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00123.html">uint16</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a7bb0ce77c80ad79470310bb7f7737486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a7bb0ce77c80ad79470310bb7f7737486">More...</a><br/></td></tr>
<tr class="separator:a7bb0ce77c80ad79470310bb7f7737486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f8b1d1a4caf14dc48f0ec5c51c5606"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a45f8b1d1a4caf14dc48f0ec5c51c5606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a45f8b1d1a4caf14dc48f0ec5c51c5606">split</a> (<a class="el" href="a00127.html">uint32</a>&lt; N &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00127.html">uint32</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a45f8b1d1a4caf14dc48f0ec5c51c5606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a45f8b1d1a4caf14dc48f0ec5c51c5606">More...</a><br/></td></tr>
<tr class="separator:a45f8b1d1a4caf14dc48f0ec5c51c5606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef0bd8ad3db830e3dab4168ce9a9a52"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:acef0bd8ad3db830e3dab4168ce9a9a52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#acef0bd8ad3db830e3dab4168ce9a9a52">split</a> (<a class="el" href="a00131.html">uint64</a>&lt; N &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00131.html">uint64</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:acef0bd8ad3db830e3dab4168ce9a9a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#acef0bd8ad3db830e3dab4168ce9a9a52">More...</a><br/></td></tr>
<tr class="separator:acef0bd8ad3db830e3dab4168ce9a9a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663d33b78ff7fac36db96c999d624c52"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a663d33b78ff7fac36db96c999d624c52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a663d33b78ff7fac36db96c999d624c52">split</a> (<a class="el" href="a00025.html">int8</a>&lt; N &gt; a, <a class="el" href="a00025.html">int8</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00025.html">int8</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a663d33b78ff7fac36db96c999d624c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a663d33b78ff7fac36db96c999d624c52">More...</a><br/></td></tr>
<tr class="separator:a663d33b78ff7fac36db96c999d624c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc961fedf7d0a8ca9332bf734c1aa2a"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a4fc961fedf7d0a8ca9332bf734c1aa2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4fc961fedf7d0a8ca9332bf734c1aa2a">split</a> (<a class="el" href="a00022.html">int16</a>&lt; N &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00022.html">int16</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a4fc961fedf7d0a8ca9332bf734c1aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a4fc961fedf7d0a8ca9332bf734c1aa2a">More...</a><br/></td></tr>
<tr class="separator:a4fc961fedf7d0a8ca9332bf734c1aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742777583c7c0ba92fb2d0d5d184eb03"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a742777583c7c0ba92fb2d0d5d184eb03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a742777583c7c0ba92fb2d0d5d184eb03">split</a> (<a class="el" href="a00023.html">int32</a>&lt; N &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00023.html">int32</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a742777583c7c0ba92fb2d0d5d184eb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a742777583c7c0ba92fb2d0d5d184eb03">More...</a><br/></td></tr>
<tr class="separator:a742777583c7c0ba92fb2d0d5d184eb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854dc8c5ec7af45c4811e509c0fda28f"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a854dc8c5ec7af45c4811e509c0fda28f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a854dc8c5ec7af45c4811e509c0fda28f">split</a> (<a class="el" href="a00024.html">int64</a>&lt; N &gt; a, <a class="el" href="a00024.html">int64</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00024.html">int64</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a854dc8c5ec7af45c4811e509c0fda28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a854dc8c5ec7af45c4811e509c0fda28f">More...</a><br/></td></tr>
<tr class="separator:a854dc8c5ec7af45c4811e509c0fda28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192383a1aa540c43a7dead69ac4d59c6"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a192383a1aa540c43a7dead69ac4d59c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a192383a1aa540c43a7dead69ac4d59c6">split</a> (<a class="el" href="a00020.html">float32</a>&lt; N &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00020.html">float32</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a192383a1aa540c43a7dead69ac4d59c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a192383a1aa540c43a7dead69ac4d59c6">More...</a><br/></td></tr>
<tr class="separator:a192383a1aa540c43a7dead69ac4d59c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8678c076cd964cbadf0d2b44face76dc"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a8678c076cd964cbadf0d2b44face76dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8678c076cd964cbadf0d2b44face76dc">split</a> (<a class="el" href="a00021.html">float64</a>&lt; N &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N/2 &gt; &amp;r1, <a class="el" href="a00021.html">float64</a>&lt; N/2 &gt; &amp;r2)</td></tr>
<tr class="memdesc:a8678c076cd964cbadf0d2b44face76dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a 256-bit vector into two 128-bit vectors.  <a href="#a8678c076cd964cbadf0d2b44face76dc">More...</a><br/></td></tr>
<tr class="separator:a8678c076cd964cbadf0d2b44face76dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a73df1051681544e8a4257adf3523ee6a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:a73df1051681544e8a4257adf3523ee6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00043.html">expr_fmadd</a><br class="typebreak"/>
&lt; <a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt;, <a class="el" href="a00020.html">float32</a>&lt; N, <br class="typebreak"/>
E2 &gt;, <a class="el" href="a00020.html">float32</a>&lt; N, E3 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a73df1051681544e8a4257adf3523ee6a">fmadd</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b, <a class="el" href="a00020.html">float32</a>&lt; N, E3 &gt; c)</td></tr>
<tr class="memdesc:a73df1051681544e8a4257adf3523ee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fused multiply-add operation.  <a href="#a73df1051681544e8a4257adf3523ee6a">More...</a><br/></td></tr>
<tr class="separator:a73df1051681544e8a4257adf3523ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c72f1936ddf69973a949a639d2ec8"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:a577c72f1936ddf69973a949a639d2ec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00043.html">expr_fmadd</a><br class="typebreak"/>
&lt; <a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt;, <a class="el" href="a00021.html">float64</a>&lt; N, <br class="typebreak"/>
E2 &gt;, <a class="el" href="a00021.html">float64</a>&lt; N, E3 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a577c72f1936ddf69973a949a639d2ec8">fmadd</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b, <a class="el" href="a00021.html">float64</a>&lt; N, E3 &gt; c)</td></tr>
<tr class="memdesc:a577c72f1936ddf69973a949a639d2ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fused multiply-add operation.  <a href="#a577c72f1936ddf69973a949a639d2ec8">More...</a><br/></td></tr>
<tr class="separator:a577c72f1936ddf69973a949a639d2ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab2bb428c0878ad59f32a991db4940523"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:ab2bb428c0878ad59f32a991db4940523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00044.html">expr_fmsub</a><br class="typebreak"/>
&lt; <a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt;, <a class="el" href="a00020.html">float32</a>&lt; N, <br class="typebreak"/>
E2 &gt;, <a class="el" href="a00020.html">float32</a>&lt; N, E3 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab2bb428c0878ad59f32a991db4940523">fmsub</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b, <a class="el" href="a00020.html">float32</a>&lt; N, E3 &gt; c)</td></tr>
<tr class="memdesc:ab2bb428c0878ad59f32a991db4940523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fused multiply-sutract operation.  <a href="#ab2bb428c0878ad59f32a991db4940523">More...</a><br/></td></tr>
<tr class="separator:ab2bb428c0878ad59f32a991db4940523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05d4b470991c5fb85ae675587850230"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:ad05d4b470991c5fb85ae675587850230"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00044.html">expr_fmsub</a><br class="typebreak"/>
&lt; <a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt;, <a class="el" href="a00021.html">float64</a>&lt; N, <br class="typebreak"/>
E2 &gt;, <a class="el" href="a00021.html">float64</a>&lt; N, E3 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad05d4b470991c5fb85ae675587850230">fmsub</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b, <a class="el" href="a00021.html">float64</a>&lt; N, E3 &gt; c)</td></tr>
<tr class="memdesc:ad05d4b470991c5fb85ae675587850230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fused multiply-sutract operation.  <a href="#ad05d4b470991c5fb85ae675587850230">More...</a><br/></td></tr>
<tr class="separator:ad05d4b470991c5fb85ae675587850230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a94fa2c60eca255ba0ab478a7f2d5c330"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a94fa2c60eca255ba0ab478a7f2d5c330"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00021.html">float64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a94fa2c60eca255ba0ab478a7f2d5c330">max</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a94fa2c60eca255ba0ab478a7f2d5c330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes maxima of the values of two vectors.  <a href="#a94fa2c60eca255ba0ab478a7f2d5c330">More...</a><br/></td></tr>
<tr class="separator:a94fa2c60eca255ba0ab478a7f2d5c330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3fb2286904bc79944007a8301456894"><td class="memTemplParams" colspan="2">template&lt;unsigned P&gt; </td></tr>
<tr class="memitem:ab3fb2286904bc79944007a8301456894"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab3fb2286904bc79944007a8301456894">div_p</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> num, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> den)</td></tr>
<tr class="memdesc:ab3fb2286904bc79944007a8301456894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides one 8-bit unsigned number by another.  <a href="#ab3fb2286904bc79944007a8301456894">More...</a><br/></td></tr>
<tr class="separator:ab3fb2286904bc79944007a8301456894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ef9ad936d4ac88020496b19952930d"><td class="memTemplParams" colspan="2">template&lt;unsigned P&gt; </td></tr>
<tr class="memitem:ab6ef9ad936d4ac88020496b19952930d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab6ef9ad936d4ac88020496b19952930d">div_p</a> (<a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> num, <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> den)</td></tr>
<tr class="memdesc:ab6ef9ad936d4ac88020496b19952930d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides one 8-bit unsigned number by another.  <a href="#ab6ef9ad936d4ac88020496b19952930d">More...</a><br/></td></tr>
<tr class="separator:ab6ef9ad936d4ac88020496b19952930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a61fedb195c62753f375b6a135af04ed7"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a61fedb195c62753f375b6a135af04ed7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00050.html">expr_mull</a>&lt; <a class="el" href="a00022.html">int16</a>&lt; N, <br class="typebreak"/>
E1 &gt;, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a61fedb195c62753f375b6a135af04ed7">mull</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a61fedb195c62753f375b6a135af04ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit values and expands the results to 32 bits.  <a href="#a61fedb195c62753f375b6a135af04ed7">More...</a><br/></td></tr>
<tr class="separator:a61fedb195c62753f375b6a135af04ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce612f79de953cacb035ecd1808953"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:af9ce612f79de953cacb035ecd1808953"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00050.html">expr_mull</a>&lt; <a class="el" href="a00123.html">uint16</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af9ce612f79de953cacb035ecd1808953">mull</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:af9ce612f79de953cacb035ecd1808953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies unsigned 16-bit values and expands the results to 32 bits.  <a href="#af9ce612f79de953cacb035ecd1808953">More...</a><br/></td></tr>
<tr class="separator:af9ce612f79de953cacb035ecd1808953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef168d13752b6e7c6f13274cf89ff98"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a1ef168d13752b6e7c6f13274cf89ff98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00050.html">expr_mull</a>&lt; <a class="el" href="a00023.html">int32</a>&lt; N, <br class="typebreak"/>
E1 &gt;, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1ef168d13752b6e7c6f13274cf89ff98">mull</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a1ef168d13752b6e7c6f13274cf89ff98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 32-bit values in and expands the results to 64 bits.  <a href="#a1ef168d13752b6e7c6f13274cf89ff98">More...</a><br/></td></tr>
<tr class="separator:a1ef168d13752b6e7c6f13274cf89ff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1593ec62b30e0fe5dce5cc4b3173cca"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ab1593ec62b30e0fe5dce5cc4b3173cca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00050.html">expr_mull</a>&lt; <a class="el" href="a00127.html">uint32</a><br class="typebreak"/>
&lt; N, E1 &gt;, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab1593ec62b30e0fe5dce5cc4b3173cca">mull</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ab1593ec62b30e0fe5dce5cc4b3173cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies unsigned 32-bit values in the lower halves of the vectors and expands the results to 64 bits.  <a href="#ab1593ec62b30e0fe5dce5cc4b3173cca">More...</a><br/></td></tr>
<tr class="separator:ab1593ec62b30e0fe5dce5cc4b3173cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a283dd44c6c0eb35bf2f692be07aa4431"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a283dd44c6c0eb35bf2f692be07aa4431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a283dd44c6c0eb35bf2f692be07aa4431">shift_l</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a283dd44c6c0eb35bf2f692be07aa4431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 8-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a283dd44c6c0eb35bf2f692be07aa4431">More...</a><br/></td></tr>
<tr class="separator:a283dd44c6c0eb35bf2f692be07aa4431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc9838fd613f636a9161daf51f33e40"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:afdc9838fd613f636a9161daf51f33e40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#afdc9838fd613f636a9161daf51f33e40">shift_l</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:afdc9838fd613f636a9161daf51f33e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 8-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#afdc9838fd613f636a9161daf51f33e40">More...</a><br/></td></tr>
<tr class="separator:afdc9838fd613f636a9161daf51f33e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8a8ac7bf66fa5acfcf07e7da227c0512"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a8a8ac7bf66fa5acfcf07e7da227c0512"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8a8ac7bf66fa5acfcf07e7da227c0512">shift_l</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a8a8ac7bf66fa5acfcf07e7da227c0512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 16-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a8a8ac7bf66fa5acfcf07e7da227c0512">More...</a><br/></td></tr>
<tr class="separator:a8a8ac7bf66fa5acfcf07e7da227c0512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907cce54825bc513315355b0ef5b740a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a907cce54825bc513315355b0ef5b740a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a907cce54825bc513315355b0ef5b740a">shift_l</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a907cce54825bc513315355b0ef5b740a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 16-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a907cce54825bc513315355b0ef5b740a">More...</a><br/></td></tr>
<tr class="separator:a907cce54825bc513315355b0ef5b740a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0cca7fe880962bc0cb0579847603b939"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a0cca7fe880962bc0cb0579847603b939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a0cca7fe880962bc0cb0579847603b939">shift_l</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a0cca7fe880962bc0cb0579847603b939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 32-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a0cca7fe880962bc0cb0579847603b939">More...</a><br/></td></tr>
<tr class="separator:a0cca7fe880962bc0cb0579847603b939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adfb96f9cd90a99369ce2b5f0cf0659"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a0adfb96f9cd90a99369ce2b5f0cf0659"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a0adfb96f9cd90a99369ce2b5f0cf0659">shift_l</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a0adfb96f9cd90a99369ce2b5f0cf0659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 32-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a0adfb96f9cd90a99369ce2b5f0cf0659">More...</a><br/></td></tr>
<tr class="separator:a0adfb96f9cd90a99369ce2b5f0cf0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af934fafc5386953c29cec03680f32553"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:af934fafc5386953c29cec03680f32553"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00024.html">int64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af934fafc5386953c29cec03680f32553">shift_l</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:af934fafc5386953c29cec03680f32553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 64-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#af934fafc5386953c29cec03680f32553">More...</a><br/></td></tr>
<tr class="separator:af934fafc5386953c29cec03680f32553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af284a1fbcdbeff160dc5ef5b37178266"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:af284a1fbcdbeff160dc5ef5b37178266"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af284a1fbcdbeff160dc5ef5b37178266">shift_l</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:af284a1fbcdbeff160dc5ef5b37178266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 64-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#af284a1fbcdbeff160dc5ef5b37178266">More...</a><br/></td></tr>
<tr class="separator:af284a1fbcdbeff160dc5ef5b37178266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae04716a0087fdbff6f3ddb51bafce16c"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:ae04716a0087fdbff6f3ddb51bafce16c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ae04716a0087fdbff6f3ddb51bafce16c">shift_l</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ae04716a0087fdbff6f3ddb51bafce16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 8-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#ae04716a0087fdbff6f3ddb51bafce16c">More...</a><br/></td></tr>
<tr class="separator:ae04716a0087fdbff6f3ddb51bafce16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd9a4ca2decbce49dac8a8bcab65cc5"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a5cd9a4ca2decbce49dac8a8bcab65cc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5cd9a4ca2decbce49dac8a8bcab65cc5">shift_l</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a5cd9a4ca2decbce49dac8a8bcab65cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 8-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a5cd9a4ca2decbce49dac8a8bcab65cc5">More...</a><br/></td></tr>
<tr class="separator:a5cd9a4ca2decbce49dac8a8bcab65cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a934ce3f99012aa239a1064f82bddda8d"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a934ce3f99012aa239a1064f82bddda8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a934ce3f99012aa239a1064f82bddda8d">shift_l</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a934ce3f99012aa239a1064f82bddda8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 16-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a934ce3f99012aa239a1064f82bddda8d">More...</a><br/></td></tr>
<tr class="separator:a934ce3f99012aa239a1064f82bddda8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b8535579b8f48521e7b985a69517b8"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a59b8535579b8f48521e7b985a69517b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a59b8535579b8f48521e7b985a69517b8">shift_l</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a59b8535579b8f48521e7b985a69517b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 16-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a59b8535579b8f48521e7b985a69517b8">More...</a><br/></td></tr>
<tr class="separator:a59b8535579b8f48521e7b985a69517b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a53f1476e818ff93cec9c523b0355993b"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a53f1476e818ff93cec9c523b0355993b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a53f1476e818ff93cec9c523b0355993b">shift_l</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a53f1476e818ff93cec9c523b0355993b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 32-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#a53f1476e818ff93cec9c523b0355993b">More...</a><br/></td></tr>
<tr class="separator:a53f1476e818ff93cec9c523b0355993b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa862e9283258d1d6b1b550f501494ea1"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:aa862e9283258d1d6b1b550f501494ea1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa862e9283258d1d6b1b550f501494ea1">shift_l</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:aa862e9283258d1d6b1b550f501494ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 32-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#aa862e9283258d1d6b1b550f501494ea1">More...</a><br/></td></tr>
<tr class="separator:aa862e9283258d1d6b1b550f501494ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab4949e7f822bab1a995d829312aee104"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:ab4949e7f822bab1a995d829312aee104"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00024.html">int64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab4949e7f822bab1a995d829312aee104">shift_l</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ab4949e7f822bab1a995d829312aee104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 64-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#ab4949e7f822bab1a995d829312aee104">More...</a><br/></td></tr>
<tr class="separator:ab4949e7f822bab1a995d829312aee104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e02657792d8d22c6f69ad87647a99b"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:ab8e02657792d8d22c6f69ad87647a99b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab8e02657792d8d22c6f69ad87647a99b">shift_l</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ab8e02657792d8d22c6f69ad87647a99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts 64-bit values left by <em>count</em> bits while shifting in zeros.  <a href="#ab8e02657792d8d22c6f69ad87647a99b">More...</a><br/></td></tr>
<tr class="separator:ab8e02657792d8d22c6f69ad87647a99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a597654750a1374e31a52cec5e47a0582"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a597654750a1374e31a52cec5e47a0582"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a597654750a1374e31a52cec5e47a0582">shift_r</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a597654750a1374e31a52cec5e47a0582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 8-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#a597654750a1374e31a52cec5e47a0582">More...</a><br/></td></tr>
<tr class="separator:a597654750a1374e31a52cec5e47a0582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c88068cd5b54ab1f14ad15ee10cc12"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ab2c88068cd5b54ab1f14ad15ee10cc12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab2c88068cd5b54ab1f14ad15ee10cc12">shift_r</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:ab2c88068cd5b54ab1f14ad15ee10cc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 16-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#ab2c88068cd5b54ab1f14ad15ee10cc12">More...</a><br/></td></tr>
<tr class="separator:ab2c88068cd5b54ab1f14ad15ee10cc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae018b5538ba43b282051a57286c423a6"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ae018b5538ba43b282051a57286c423a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ae018b5538ba43b282051a57286c423a6">shift_r</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:ae018b5538ba43b282051a57286c423a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 16-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#ae018b5538ba43b282051a57286c423a6">More...</a><br/></td></tr>
<tr class="separator:ae018b5538ba43b282051a57286c423a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5602ae9285e7f8d5a05218d7fee472"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a9c5602ae9285e7f8d5a05218d7fee472"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9c5602ae9285e7f8d5a05218d7fee472">shift_r</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a9c5602ae9285e7f8d5a05218d7fee472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 32-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#a9c5602ae9285e7f8d5a05218d7fee472">More...</a><br/></td></tr>
<tr class="separator:a9c5602ae9285e7f8d5a05218d7fee472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab008c614330d6d02aee17e0ba6d5ccd5"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:ab008c614330d6d02aee17e0ba6d5ccd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab008c614330d6d02aee17e0ba6d5ccd5">shift_r</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:ab008c614330d6d02aee17e0ba6d5ccd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 32-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#ab008c614330d6d02aee17e0ba6d5ccd5">More...</a><br/></td></tr>
<tr class="separator:ab008c614330d6d02aee17e0ba6d5ccd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c13e69dd002bcce8012a01431ec8e6e"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a8c13e69dd002bcce8012a01431ec8e6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00024.html">int64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8c13e69dd002bcce8012a01431ec8e6e">shift_r</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a8c13e69dd002bcce8012a01431ec8e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 64-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#a8c13e69dd002bcce8012a01431ec8e6e">More...</a><br/></td></tr>
<tr class="separator:a8c13e69dd002bcce8012a01431ec8e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f8eac065991bac6b19235186c5279f"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E &gt; </td></tr>
<tr class="memitem:a18f8eac065991bac6b19235186c5279f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a18f8eac065991bac6b19235186c5279f">shift_r</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E &gt; a, unsigned count)</td></tr>
<tr class="memdesc:a18f8eac065991bac6b19235186c5279f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 64-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#a18f8eac065991bac6b19235186c5279f">More...</a><br/></td></tr>
<tr class="separator:a18f8eac065991bac6b19235186c5279f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f401e99d051fb08fce5e832a505ca3"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a49f401e99d051fb08fce5e832a505ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a49f401e99d051fb08fce5e832a505ca3">shift_r</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a49f401e99d051fb08fce5e832a505ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 8-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#a49f401e99d051fb08fce5e832a505ca3">More...</a><br/></td></tr>
<tr class="separator:a49f401e99d051fb08fce5e832a505ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4714c2e7284de7deca0cc07c5091cbd8"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a4714c2e7284de7deca0cc07c5091cbd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4714c2e7284de7deca0cc07c5091cbd8">shift_r</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a4714c2e7284de7deca0cc07c5091cbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 8-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#a4714c2e7284de7deca0cc07c5091cbd8">More...</a><br/></td></tr>
<tr class="separator:a4714c2e7284de7deca0cc07c5091cbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95562c4cdd6d77546de9fc501e21dd"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a4c95562c4cdd6d77546de9fc501e21dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4c95562c4cdd6d77546de9fc501e21dd">shift_r</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a4c95562c4cdd6d77546de9fc501e21dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 16-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#a4c95562c4cdd6d77546de9fc501e21dd">More...</a><br/></td></tr>
<tr class="separator:a4c95562c4cdd6d77546de9fc501e21dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac615591587f2b694c060ce5aba6eeb6e"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:ac615591587f2b694c060ce5aba6eeb6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac615591587f2b694c060ce5aba6eeb6e">shift_r</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ac615591587f2b694c060ce5aba6eeb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 16-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#ac615591587f2b694c060ce5aba6eeb6e">More...</a><br/></td></tr>
<tr class="separator:ac615591587f2b694c060ce5aba6eeb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c531a109ba8ad2bc4e06a2643511fa"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a74c531a109ba8ad2bc4e06a2643511fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a74c531a109ba8ad2bc4e06a2643511fa">shift_r</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a74c531a109ba8ad2bc4e06a2643511fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 32-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#a74c531a109ba8ad2bc4e06a2643511fa">More...</a><br/></td></tr>
<tr class="separator:a74c531a109ba8ad2bc4e06a2643511fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd9e0ed93b0970681772daa1538838"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a89dd9e0ed93b0970681772daa1538838"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a89dd9e0ed93b0970681772daa1538838">shift_r</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a89dd9e0ed93b0970681772daa1538838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 32-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#a89dd9e0ed93b0970681772daa1538838">More...</a><br/></td></tr>
<tr class="separator:a89dd9e0ed93b0970681772daa1538838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2edd99d48a4f8a4a383a179d38aa7ea"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:aa2edd99d48a4f8a4a383a179d38aa7ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00024.html">int64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa2edd99d48a4f8a4a383a179d38aa7ea">shift_r</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:aa2edd99d48a4f8a4a383a179d38aa7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts signed 64-bit values right by <em>count</em> bits while shifting in the sign bit.  <a href="#aa2edd99d48a4f8a4a383a179d38aa7ea">More...</a><br/></td></tr>
<tr class="separator:aa2edd99d48a4f8a4a383a179d38aa7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1490b245a6c2f24836c62b8cdf7fabd6"><td class="memTemplParams" colspan="2">template&lt;unsigned count, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a1490b245a6c2f24836c62b8cdf7fabd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1490b245a6c2f24836c62b8cdf7fabd6">shift_r</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a1490b245a6c2f24836c62b8cdf7fabd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts unsigned 64-bit values right by <em>count</em> bits while shifting in zeros.  <a href="#a1490b245a6c2f24836c62b8cdf7fabd6">More...</a><br/></td></tr>
<tr class="separator:a1490b245a6c2f24836c62b8cdf7fabd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaea979cd2f49a013f65b064cdce17c8e8"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaea979cd2f49a013f65b064cdce17c8e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">uint8x32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gaea979cd2f49a013f65b064cdce17c8e8">combine</a> (<a class="el" href="a00135.html">uint8</a>&lt; 16, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; 16, E2 &gt; b)</td></tr>
<tr class="memdesc:gaea979cd2f49a013f65b064cdce17c8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gaea979cd2f49a013f65b064cdce17c8e8">More...</a><br/></td></tr>
<tr class="separator:gaea979cd2f49a013f65b064cdce17c8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f920165d761d734363b41963eaee85e"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga3f920165d761d734363b41963eaee85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga3f920165d761d734363b41963eaee85e">combine</a> (<a class="el" href="a00123.html">uint16</a>&lt; 8, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; 8, E2 &gt; b)</td></tr>
<tr class="memdesc:ga3f920165d761d734363b41963eaee85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga3f920165d761d734363b41963eaee85e">More...</a><br/></td></tr>
<tr class="separator:ga3f920165d761d734363b41963eaee85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3dfa283cc21364afe371b0303b1821c"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaa3dfa283cc21364afe371b0303b1821c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">uint32x8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gaa3dfa283cc21364afe371b0303b1821c">combine</a> (<a class="el" href="a00127.html">uint32</a>&lt; 4, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; 4, E2 &gt; b)</td></tr>
<tr class="memdesc:gaa3dfa283cc21364afe371b0303b1821c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gaa3dfa283cc21364afe371b0303b1821c">More...</a><br/></td></tr>
<tr class="separator:gaa3dfa283cc21364afe371b0303b1821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac549b23ca1d2e207094281eafe0136e1"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gac549b23ca1d2e207094281eafe0136e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gac549b23ca1d2e207094281eafe0136e1">combine</a> (<a class="el" href="a00131.html">uint64</a>&lt; 2, E1 &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; 2, E2 &gt; b)</td></tr>
<tr class="memdesc:gac549b23ca1d2e207094281eafe0136e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gac549b23ca1d2e207094281eafe0136e1">More...</a><br/></td></tr>
<tr class="separator:gac549b23ca1d2e207094281eafe0136e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad07b4db46b9f97509139cae226cb7e67"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gad07b4db46b9f97509139cae226cb7e67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">int16x16</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gad07b4db46b9f97509139cae226cb7e67">combine</a> (<a class="el" href="a00022.html">int16</a>&lt; 8, E1 &gt; a, <a class="el" href="a00022.html">int16</a>&lt; 8, E2 &gt; b)</td></tr>
<tr class="memdesc:gad07b4db46b9f97509139cae226cb7e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gad07b4db46b9f97509139cae226cb7e67">More...</a><br/></td></tr>
<tr class="separator:gad07b4db46b9f97509139cae226cb7e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab745b113a9931db20e30fb65591798e0"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gab745b113a9931db20e30fb65591798e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gab745b113a9931db20e30fb65591798e0">combine</a> (<a class="el" href="a00023.html">int32</a>&lt; 4, E1 &gt; a, <a class="el" href="a00023.html">int32</a>&lt; 4, E2 &gt; b)</td></tr>
<tr class="memdesc:gab745b113a9931db20e30fb65591798e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gab745b113a9931db20e30fb65591798e0">More...</a><br/></td></tr>
<tr class="separator:gab745b113a9931db20e30fb65591798e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf692e5e530364c497fc92b292a602dc1"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaf692e5e530364c497fc92b292a602dc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a8da9597a0403650325e7b0df8893d6a3">int64x4</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gaf692e5e530364c497fc92b292a602dc1">combine</a> (<a class="el" href="a00024.html">int64</a>&lt; 2, E1 &gt; a, <a class="el" href="a00024.html">int64</a>&lt; 2, E2 &gt; b)</td></tr>
<tr class="memdesc:gaf692e5e530364c497fc92b292a602dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gaf692e5e530364c497fc92b292a602dc1">More...</a><br/></td></tr>
<tr class="separator:gaf692e5e530364c497fc92b292a602dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf66d90be8a94270d8e9d2630d1b30b"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gafbf66d90be8a94270d8e9d2630d1b30b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">float32x8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gafbf66d90be8a94270d8e9d2630d1b30b">combine</a> (<a class="el" href="a00020.html">float32</a>&lt; 4, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; 4, E2 &gt; b)</td></tr>
<tr class="memdesc:gafbf66d90be8a94270d8e9d2630d1b30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gafbf66d90be8a94270d8e9d2630d1b30b">More...</a><br/></td></tr>
<tr class="separator:gafbf66d90be8a94270d8e9d2630d1b30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d8bb8b343af4d4ee39cada413c774e"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga09d8bb8b343af4d4ee39cada413c774e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga09d8bb8b343af4d4ee39cada413c774e">combine</a> (<a class="el" href="a00021.html">float64</a>&lt; 2, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; 2, E2 &gt; b)</td></tr>
<tr class="memdesc:ga09d8bb8b343af4d4ee39cada413c774e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga09d8bb8b343af4d4ee39cada413c774e">More...</a><br/></td></tr>
<tr class="separator:ga09d8bb8b343af4d4ee39cada413c774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e4c88bf7d0f39c1a8da87bbbb049c7"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga74e4c88bf7d0f39c1a8da87bbbb049c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga74e4c88bf7d0f39c1a8da87bbbb049c7">combine</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a1, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:ga74e4c88bf7d0f39c1a8da87bbbb049c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga74e4c88bf7d0f39c1a8da87bbbb049c7">More...</a><br/></td></tr>
<tr class="separator:ga74e4c88bf7d0f39c1a8da87bbbb049c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga492c578a314e30fc43c46576d08d8757"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga492c578a314e30fc43c46576d08d8757"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga492c578a314e30fc43c46576d08d8757">combine</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a1, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:ga492c578a314e30fc43c46576d08d8757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga492c578a314e30fc43c46576d08d8757">More...</a><br/></td></tr>
<tr class="separator:ga492c578a314e30fc43c46576d08d8757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705b9e01348e03edab8fdbbb8312fb74"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga705b9e01348e03edab8fdbbb8312fb74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga705b9e01348e03edab8fdbbb8312fb74">combine</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a1, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:ga705b9e01348e03edab8fdbbb8312fb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga705b9e01348e03edab8fdbbb8312fb74">More...</a><br/></td></tr>
<tr class="separator:ga705b9e01348e03edab8fdbbb8312fb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad415a33fa19bcbc9e3b684bb48847c75"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gad415a33fa19bcbc9e3b684bb48847c75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gad415a33fa19bcbc9e3b684bb48847c75">combine</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E1 &gt; a1, <a class="el" href="a00131.html">uint64</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:gad415a33fa19bcbc9e3b684bb48847c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gad415a33fa19bcbc9e3b684bb48847c75">More...</a><br/></td></tr>
<tr class="separator:gad415a33fa19bcbc9e3b684bb48847c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b09fcf43792b3e7ff722cbf35a005d"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga60b09fcf43792b3e7ff722cbf35a005d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga60b09fcf43792b3e7ff722cbf35a005d">combine</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E1 &gt; a1, <a class="el" href="a00025.html">int8</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:ga60b09fcf43792b3e7ff722cbf35a005d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga60b09fcf43792b3e7ff722cbf35a005d">More...</a><br/></td></tr>
<tr class="separator:ga60b09fcf43792b3e7ff722cbf35a005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579f6def834de17d6612136c462541a0"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga579f6def834de17d6612136c462541a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga579f6def834de17d6612136c462541a0">combine</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E1 &gt; a1, <a class="el" href="a00022.html">int16</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:ga579f6def834de17d6612136c462541a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga579f6def834de17d6612136c462541a0">More...</a><br/></td></tr>
<tr class="separator:ga579f6def834de17d6612136c462541a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd0ab2d74d4412d5338c7ceacb2535c"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gadfd0ab2d74d4412d5338c7ceacb2535c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gadfd0ab2d74d4412d5338c7ceacb2535c">combine</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E1 &gt; a1, <a class="el" href="a00023.html">int32</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:gadfd0ab2d74d4412d5338c7ceacb2535c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gadfd0ab2d74d4412d5338c7ceacb2535c">More...</a><br/></td></tr>
<tr class="separator:gadfd0ab2d74d4412d5338c7ceacb2535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b619e7fb72a40749b1740827ad0ec50"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga5b619e7fb72a40749b1740827ad0ec50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga5b619e7fb72a40749b1740827ad0ec50">combine</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E1 &gt; a1, <a class="el" href="a00024.html">int64</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:ga5b619e7fb72a40749b1740827ad0ec50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga5b619e7fb72a40749b1740827ad0ec50">More...</a><br/></td></tr>
<tr class="separator:ga5b619e7fb72a40749b1740827ad0ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9dfa5f7b79b58f568a05650530175e2"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gad9dfa5f7b79b58f568a05650530175e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gad9dfa5f7b79b58f568a05650530175e2">combine</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a1, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:gad9dfa5f7b79b58f568a05650530175e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#gad9dfa5f7b79b58f568a05650530175e2">More...</a><br/></td></tr>
<tr class="separator:gad9dfa5f7b79b58f568a05650530175e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4ac1f2b1f8f74c9c0ca6ce402b974d"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga6d4ac1f2b1f8f74c9c0ca6ce402b974d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga6d4ac1f2b1f8f74c9c0ca6ce402b974d">combine</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a1, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; a2)</td></tr>
<tr class="memdesc:ga6d4ac1f2b1f8f74c9c0ca6ce402b974d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two 128-bit vectors into a 256-bit vector.  <a href="a00419.html#ga6d4ac1f2b1f8f74c9c0ca6ce402b974d">More...</a><br/></td></tr>
<tr class="separator:ga6d4ac1f2b1f8f74c9c0ca6ce402b974d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaa65ccf187a7146e55b4d2fffbbbd5e2"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;double,1&gt;&gt; </td></tr>
<tr class="memitem:aaa65ccf187a7146e55b4d2fffbbbd5e2"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aaa65ccf187a7146e55b4d2fffbbbd5e2">make_float</a> (double v0)</td></tr>
<tr class="memdesc:aaa65ccf187a7146e55b4d2fffbbbd5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from floating-point values known at compile-time.  <a href="#aaa65ccf187a7146e55b4d2fffbbbd5e2">More...</a><br/></td></tr>
<tr class="separator:aaa65ccf187a7146e55b4d2fffbbbd5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bf349921e9167f4d1fc57fe463b208"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;double,2&gt;&gt; </td></tr>
<tr class="memitem:ac7bf349921e9167f4d1fc57fe463b208"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac7bf349921e9167f4d1fc57fe463b208">make_float</a> (double v0, double v1)</td></tr>
<tr class="memdesc:ac7bf349921e9167f4d1fc57fe463b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from floating-point values known at compile-time.  <a href="#ac7bf349921e9167f4d1fc57fe463b208">More...</a><br/></td></tr>
<tr class="separator:ac7bf349921e9167f4d1fc57fe463b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94279b55defe4d2d446db6f4c0aab0de"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;double,4&gt;&gt; </td></tr>
<tr class="memitem:a94279b55defe4d2d446db6f4c0aab0de"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a94279b55defe4d2d446db6f4c0aab0de">make_float</a> (double v0, double v1, double v2, double v3)</td></tr>
<tr class="memdesc:a94279b55defe4d2d446db6f4c0aab0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from floating-point values known at compile-time.  <a href="#a94279b55defe4d2d446db6f4c0aab0de">More...</a><br/></td></tr>
<tr class="separator:a94279b55defe4d2d446db6f4c0aab0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6903005ddd74ebe0cadd06c8e2416b97"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;double,8&gt;&gt; </td></tr>
<tr class="memitem:a6903005ddd74ebe0cadd06c8e2416b97"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a6903005ddd74ebe0cadd06c8e2416b97">make_float</a> (double v0, double v1, double v2, double v3, double v4, double v5, double v6, double v7)</td></tr>
<tr class="memdesc:a6903005ddd74ebe0cadd06c8e2416b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from floating-point values known at compile-time.  <a href="#a6903005ddd74ebe0cadd06c8e2416b97">More...</a><br/></td></tr>
<tr class="separator:a6903005ddd74ebe0cadd06c8e2416b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a53f37aaa88fb392f3500e85acb0b58de"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;int64_t,1&gt;&gt; </td></tr>
<tr class="memitem:a53f37aaa88fb392f3500e85acb0b58de"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a53f37aaa88fb392f3500e85acb0b58de">make_int</a> (int64_t v0)</td></tr>
<tr class="memdesc:a53f37aaa88fb392f3500e85acb0b58de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from signed integer values known at compile-time.  <a href="#a53f37aaa88fb392f3500e85acb0b58de">More...</a><br/></td></tr>
<tr class="separator:a53f37aaa88fb392f3500e85acb0b58de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5c89acfe9c96b80b6fc6ffdc1d96ce"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;int64_t,2&gt;&gt; </td></tr>
<tr class="memitem:abe5c89acfe9c96b80b6fc6ffdc1d96ce"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#abe5c89acfe9c96b80b6fc6ffdc1d96ce">make_int</a> (int64_t v0, int64_t v1)</td></tr>
<tr class="memdesc:abe5c89acfe9c96b80b6fc6ffdc1d96ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from signed integer values known at compile-time.  <a href="#abe5c89acfe9c96b80b6fc6ffdc1d96ce">More...</a><br/></td></tr>
<tr class="separator:abe5c89acfe9c96b80b6fc6ffdc1d96ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af10fe42496184f4e1e533d19ff01ad"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;int64_t,4&gt;&gt; </td></tr>
<tr class="memitem:a1af10fe42496184f4e1e533d19ff01ad"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1af10fe42496184f4e1e533d19ff01ad">make_int</a> (int64_t v0, int64_t v1, int64_t v2, int64_t v3)</td></tr>
<tr class="memdesc:a1af10fe42496184f4e1e533d19ff01ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from signed integer values known at compile-time.  <a href="#a1af10fe42496184f4e1e533d19ff01ad">More...</a><br/></td></tr>
<tr class="separator:a1af10fe42496184f4e1e533d19ff01ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f9810b62d9575d97f65e3d768b3ee4"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;int64_t,8&gt;&gt; </td></tr>
<tr class="memitem:a31f9810b62d9575d97f65e3d768b3ee4"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a31f9810b62d9575d97f65e3d768b3ee4">make_int</a> (int64_t v0, int64_t v1, int64_t v2, int64_t v3, int64_t v4, int64_t v5, int64_t v6, int64_t v7)</td></tr>
<tr class="memdesc:a31f9810b62d9575d97f65e3d768b3ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from signed integer values known at compile-time.  <a href="#a31f9810b62d9575d97f65e3d768b3ee4">More...</a><br/></td></tr>
<tr class="separator:a31f9810b62d9575d97f65e3d768b3ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e3c7e4fb3b5cac0b040c6ff2688c46"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;int64_t,16&gt;&gt; </td></tr>
<tr class="memitem:a97e3c7e4fb3b5cac0b040c6ff2688c46"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a97e3c7e4fb3b5cac0b040c6ff2688c46">make_int</a> (int64_t v0, int64_t v1, int64_t v2, int64_t v3, int64_t v4, int64_t v5, int64_t v6, int64_t v7, int64_t v8, int64_t v9, int64_t v10, int64_t v11, int64_t v12, int64_t v13, int64_t v14, int64_t v15)</td></tr>
<tr class="memdesc:a97e3c7e4fb3b5cac0b040c6ff2688c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from signed integer values known at compile-time.  <a href="#a97e3c7e4fb3b5cac0b040c6ff2688c46">More...</a><br/></td></tr>
<tr class="separator:a97e3c7e4fb3b5cac0b040c6ff2688c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abc28b64fd1bb870c4e542eeb08ffe122"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, unsigned N&gt; </td></tr>
<tr class="memitem:abc28b64fd1bb870c4e542eeb08ffe122"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#abc28b64fd1bb870c4e542eeb08ffe122">make_shuffle_bytes16_mask</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:abc28b64fd1bb870c4e542eeb08ffe122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#abc28b64fd1bb870c4e542eeb08ffe122">More...</a><br/></td></tr>
<tr class="separator:abc28b64fd1bb870c4e542eeb08ffe122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50820f0531b5a7155c6cae0123e63855"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, int s2, int s3, unsigned N&gt; </td></tr>
<tr class="memitem:a50820f0531b5a7155c6cae0123e63855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a50820f0531b5a7155c6cae0123e63855">make_shuffle_bytes16_mask</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:a50820f0531b5a7155c6cae0123e63855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#a50820f0531b5a7155c6cae0123e63855">More...</a><br/></td></tr>
<tr class="separator:a50820f0531b5a7155c6cae0123e63855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320c9c0f0e43e7be582f31256dc4e50"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, int s2, int s3, int s4, int s5, int s6, int s7, unsigned N&gt; </td></tr>
<tr class="memitem:af320c9c0f0e43e7be582f31256dc4e50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af320c9c0f0e43e7be582f31256dc4e50">make_shuffle_bytes16_mask</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:af320c9c0f0e43e7be582f31256dc4e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#af320c9c0f0e43e7be582f31256dc4e50">More...</a><br/></td></tr>
<tr class="separator:af320c9c0f0e43e7be582f31256dc4e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a932864c6a9d9479660328a5b15d73"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, int s2, int s3, int s4, int s5, int s6, int s7, int s8, int s9, int s10, int s11, int s12, int s13, int s14, int s15, unsigned N&gt; </td></tr>
<tr class="memitem:ad4a932864c6a9d9479660328a5b15d73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad4a932864c6a9d9479660328a5b15d73">make_shuffle_bytes16_mask</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:ad4a932864c6a9d9479660328a5b15d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#ad4a932864c6a9d9479660328a5b15d73">More...</a><br/></td></tr>
<tr class="separator:ad4a932864c6a9d9479660328a5b15d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302abef5882c07c0a62401367c9cf86"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, unsigned N&gt; </td></tr>
<tr class="memitem:a9302abef5882c07c0a62401367c9cf86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9302abef5882c07c0a62401367c9cf86">make_shuffle_bytes16_mask</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:a9302abef5882c07c0a62401367c9cf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int16x8 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#a9302abef5882c07c0a62401367c9cf86">More...</a><br/></td></tr>
<tr class="separator:a9302abef5882c07c0a62401367c9cf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b89736672b46ddd36e573d1e3957323"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, int s2, int s3, unsigned N&gt; </td></tr>
<tr class="memitem:a5b89736672b46ddd36e573d1e3957323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5b89736672b46ddd36e573d1e3957323">make_shuffle_bytes16_mask</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:a5b89736672b46ddd36e573d1e3957323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int16x8 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#a5b89736672b46ddd36e573d1e3957323">More...</a><br/></td></tr>
<tr class="separator:a5b89736672b46ddd36e573d1e3957323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfac2767b4ffffd60c8f8eb1c23947b"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, int s2, int s3, int s4, int s5, int s6, int s7, unsigned N&gt; </td></tr>
<tr class="memitem:a2dfac2767b4ffffd60c8f8eb1c23947b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a2dfac2767b4ffffd60c8f8eb1c23947b">make_shuffle_bytes16_mask</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:a2dfac2767b4ffffd60c8f8eb1c23947b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int16x8 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#a2dfac2767b4ffffd60c8f8eb1c23947b">More...</a><br/></td></tr>
<tr class="separator:a2dfac2767b4ffffd60c8f8eb1c23947b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401c9c5103f69c0ec07cf9c869313c63"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, unsigned N&gt; </td></tr>
<tr class="memitem:a401c9c5103f69c0ec07cf9c869313c63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a401c9c5103f69c0ec07cf9c869313c63">make_shuffle_bytes16_mask</a> (<a class="el" href="a00127.html">uint32</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:a401c9c5103f69c0ec07cf9c869313c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int32x4 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#a401c9c5103f69c0ec07cf9c869313c63">More...</a><br/></td></tr>
<tr class="separator:a401c9c5103f69c0ec07cf9c869313c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fdf66f4485bc00aadb9c919dfe8ea3"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, int s2, int s3, unsigned N&gt; </td></tr>
<tr class="memitem:a44fdf66f4485bc00aadb9c919dfe8ea3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a44fdf66f4485bc00aadb9c919dfe8ea3">make_shuffle_bytes16_mask</a> (<a class="el" href="a00127.html">uint32</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:a44fdf66f4485bc00aadb9c919dfe8ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int32x4 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#a44fdf66f4485bc00aadb9c919dfe8ea3">More...</a><br/></td></tr>
<tr class="separator:a44fdf66f4485bc00aadb9c919dfe8ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c298aab08e0e47b97879f3d9ab2c8df"><td class="memTemplParams" colspan="2">template&lt;int s0, int s1, unsigned N&gt; </td></tr>
<tr class="memitem:a3c298aab08e0e47b97879f3d9ab2c8df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a3c298aab08e0e47b97879f3d9ab2c8df">make_shuffle_bytes16_mask</a> (<a class="el" href="a00131.html">uint64</a>&lt; N &gt; &amp;mask)</td></tr>
<tr class="memdesc:a3c298aab08e0e47b97879f3d9ab2c8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a mask to shuffle an int64x2 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions.  <a href="#a3c298aab08e0e47b97879f3d9ab2c8df">More...</a><br/></td></tr>
<tr class="separator:a3c298aab08e0e47b97879f3d9ab2c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4a0ba91265715324162086ea8c91d858"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;uint64_t,1&gt;&gt; </td></tr>
<tr class="memitem:a4a0ba91265715324162086ea8c91d858"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4a0ba91265715324162086ea8c91d858">make_uint</a> (uint64_t v0)</td></tr>
<tr class="memdesc:a4a0ba91265715324162086ea8c91d858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from unsigned integer values known at compile-time.  <a href="#a4a0ba91265715324162086ea8c91d858">More...</a><br/></td></tr>
<tr class="separator:a4a0ba91265715324162086ea8c91d858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b7024b6cc0424ee6ec21b56adefd5b"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;uint64_t,2&gt;&gt; </td></tr>
<tr class="memitem:aa5b7024b6cc0424ee6ec21b56adefd5b"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa5b7024b6cc0424ee6ec21b56adefd5b">make_uint</a> (uint64_t v0, uint64_t v1)</td></tr>
<tr class="memdesc:aa5b7024b6cc0424ee6ec21b56adefd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from unsigned integer values known at compile-time.  <a href="#aa5b7024b6cc0424ee6ec21b56adefd5b">More...</a><br/></td></tr>
<tr class="separator:aa5b7024b6cc0424ee6ec21b56adefd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cb3bcfd440927c056885a19f30d9dd"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;uint64_t,4&gt;&gt; </td></tr>
<tr class="memitem:a61cb3bcfd440927c056885a19f30d9dd"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a61cb3bcfd440927c056885a19f30d9dd">make_uint</a> (uint64_t v0, uint64_t v1, uint64_t v2, uint64_t v3)</td></tr>
<tr class="memdesc:a61cb3bcfd440927c056885a19f30d9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from unsigned integer values known at compile-time.  <a href="#a61cb3bcfd440927c056885a19f30d9dd">More...</a><br/></td></tr>
<tr class="separator:a61cb3bcfd440927c056885a19f30d9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea0bd3a09686dbbf7937fde652833cf"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;uint64_t,8&gt;&gt; </td></tr>
<tr class="memitem:a4ea0bd3a09686dbbf7937fde652833cf"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4ea0bd3a09686dbbf7937fde652833cf">make_uint</a> (uint64_t v0, uint64_t v1, uint64_t v2, uint64_t v3, uint64_t v4, uint64_t v5, uint64_t v6, uint64_t v7)</td></tr>
<tr class="memdesc:a4ea0bd3a09686dbbf7937fde652833cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from unsigned integer values known at compile-time.  <a href="#a4ea0bd3a09686dbbf7937fde652833cf">More...</a><br/></td></tr>
<tr class="separator:a4ea0bd3a09686dbbf7937fde652833cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab51b66c15c060eff38f122c9fd2edb"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_make_const&lt;uint64_t,16&gt;&gt; </td></tr>
<tr class="memitem:aaab51b66c15c060eff38f122c9fd2edb"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aaab51b66c15c060eff38f122c9fd2edb">make_uint</a> (uint64_t v0, uint64_t v1, uint64_t v2, uint64_t v3, uint64_t v4, uint64_t v5, uint64_t v6, uint64_t v7, uint64_t v8, uint64_t v9, uint64_t v10, uint64_t v11, uint64_t v12, uint64_t v13, uint64_t v14, uint64_t v15)</td></tr>
<tr class="memdesc:aaab51b66c15c060eff38f122c9fd2edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector from unsigned integer values known at compile-time.  <a href="#aaab51b66c15c060eff38f122c9fd2edb">More...</a><br/></td></tr>
<tr class="separator:aaab51b66c15c060eff38f122c9fd2edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1b3c78172677c62853e899574aa8b3f5"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a1b3c78172677c62853e899574aa8b3f5"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1b3c78172677c62853e899574aa8b3f5">move16_l</a> (const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a1b3c78172677c62853e899574aa8b3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in an int8x16 vector to the left by <em>shift</em> positions.  <a href="#a1b3c78172677c62853e899574aa8b3f5">More...</a><br/></td></tr>
<tr class="separator:a1b3c78172677c62853e899574aa8b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8638640fb716364bbd0ed897dc1a6"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a7ad8638640fb716364bbd0ed897dc1a6"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7ad8638640fb716364bbd0ed897dc1a6">move8_l</a> (const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a7ad8638640fb716364bbd0ed897dc1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 16-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#a7ad8638640fb716364bbd0ed897dc1a6">More...</a><br/></td></tr>
<tr class="separator:a7ad8638640fb716364bbd0ed897dc1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283dd91ecc9c13b9473a5710907c0cf5"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a283dd91ecc9c13b9473a5710907c0cf5"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a283dd91ecc9c13b9473a5710907c0cf5">move4_l</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a283dd91ecc9c13b9473a5710907c0cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#a283dd91ecc9c13b9473a5710907c0cf5">More...</a><br/></td></tr>
<tr class="separator:a283dd91ecc9c13b9473a5710907c0cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af670176ba3b2ab629b3ccf4905f376"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a4af670176ba3b2ab629b3ccf4905f376"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4af670176ba3b2ab629b3ccf4905f376">move2_l</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a4af670176ba3b2ab629b3ccf4905f376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the left by <em>shift</em> positions.  <a href="#a4af670176ba3b2ab629b3ccf4905f376">More...</a><br/></td></tr>
<tr class="separator:a4af670176ba3b2ab629b3ccf4905f376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afef04acdd6e160325d1f3ee4eb2e156f"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:afef04acdd6e160325d1f3ee4eb2e156f"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#afef04acdd6e160325d1f3ee4eb2e156f">move16_r</a> (const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:afef04acdd6e160325d1f3ee4eb2e156f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 8-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#afef04acdd6e160325d1f3ee4eb2e156f">More...</a><br/></td></tr>
<tr class="separator:afef04acdd6e160325d1f3ee4eb2e156f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c708996c09711bf1db8deeb3c0e29c"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:ab0c708996c09711bf1db8deeb3c0e29c"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab0c708996c09711bf1db8deeb3c0e29c">move8_r</a> (const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:ab0c708996c09711bf1db8deeb3c0e29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 16-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#ab0c708996c09711bf1db8deeb3c0e29c">More...</a><br/></td></tr>
<tr class="separator:ab0c708996c09711bf1db8deeb3c0e29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3277be4a184312b88add88d9bf11b49c"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a3277be4a184312b88add88d9bf11b49c"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a3277be4a184312b88add88d9bf11b49c">move4_r</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a3277be4a184312b88add88d9bf11b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 32-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#a3277be4a184312b88add88d9bf11b49c">More...</a><br/></td></tr>
<tr class="separator:a3277be4a184312b88add88d9bf11b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b00bec4a5c5c2244ba939b891c94f"><td class="memTemplParams" colspan="2">template&lt;unsigned shift, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a4d5b00bec4a5c5c2244ba939b891c94f"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4d5b00bec4a5c5c2244ba939b891c94f">move2_r</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a4d5b00bec4a5c5c2244ba939b891c94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the 64-bit elements in a vector to the right by <em>shift</em> positions.  <a href="#a4d5b00bec4a5c5c2244ba939b891c94f">More...</a><br/></td></tr>
<tr class="separator:a4d5b00bec4a5c5c2244ba939b891c94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa6d96ec58fe0ef6177912c523df00bf9"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned N, class V &gt; </td></tr>
<tr class="memitem:aa6d96ec58fe0ef6177912c523df00bf9"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa6d96ec58fe0ef6177912c523df00bf9">permute2</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:aa6d96ec58fe0ef6177912c523df00bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the values of each set of four consecutive 32-bit values.  <a href="#aa6d96ec58fe0ef6177912c523df00bf9">More...</a><br/></td></tr>
<tr class="separator:aa6d96ec58fe0ef6177912c523df00bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0607a26dbc16a9f1039cca5a03a28fd9"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a0607a26dbc16a9f1039cca5a03a28fd9"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a0607a26dbc16a9f1039cca5a03a28fd9">permute4</a> (const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a0607a26dbc16a9f1039cca5a03a28fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the 16-bit values within each 4 consecutive values of the vector.  <a href="#a0607a26dbc16a9f1039cca5a03a28fd9">More...</a><br/></td></tr>
<tr class="separator:a0607a26dbc16a9f1039cca5a03a28fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bdb1a2dfe570958d73bc1fb187f176"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a09bdb1a2dfe570958d73bc1fb187f176"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a09bdb1a2dfe570958d73bc1fb187f176">permute4</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a09bdb1a2dfe570958d73bc1fb187f176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the values of each set of four consecutive 32-bit values.  <a href="#a09bdb1a2dfe570958d73bc1fb187f176">More...</a><br/></td></tr>
<tr class="separator:a09bdb1a2dfe570958d73bc1fb187f176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07799d262b45070c606d4a20f6420b14"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a07799d262b45070c606d4a20f6420b14"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a07799d262b45070c606d4a20f6420b14">permute4</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a07799d262b45070c606d4a20f6420b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the values of each set of four consecutive 64-bit values.  <a href="#a07799d262b45070c606d4a20f6420b14">More...</a><br/></td></tr>
<tr class="separator:a07799d262b45070c606d4a20f6420b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af07615009b2fd3dd8658ccdd9775e043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#af07615009b2fd3dd8658ccdd9775e043">permute_bytes16</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> mask)</td></tr>
<tr class="memdesc:af07615009b2fd3dd8658ccdd9775e043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#af07615009b2fd3dd8658ccdd9775e043">More...</a><br/></td></tr>
<tr class="separator:af07615009b2fd3dd8658ccdd9775e043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55050dafd27987ea365a6219d224f634"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a55050dafd27987ea365a6219d224f634"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a55050dafd27987ea365a6219d224f634">permute_bytes16</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a55050dafd27987ea365a6219d224f634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#a55050dafd27987ea365a6219d224f634">More...</a><br/></td></tr>
<tr class="separator:a55050dafd27987ea365a6219d224f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d8c18a9040e3c256c2bcb5dbdb45e"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a8e1d8c18a9040e3c256c2bcb5dbdb45e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8e1d8c18a9040e3c256c2bcb5dbdb45e">permute_bytes16</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a8e1d8c18a9040e3c256c2bcb5dbdb45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#a8e1d8c18a9040e3c256c2bcb5dbdb45e">More...</a><br/></td></tr>
<tr class="separator:a8e1d8c18a9040e3c256c2bcb5dbdb45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5fd08d30d58814cd24208cc2365ffb"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a5e5fd08d30d58814cd24208cc2365ffb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5e5fd08d30d58814cd24208cc2365ffb">permute_bytes16</a> (<a class="el" href="a00127.html">uint32</a>&lt; N &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a5e5fd08d30d58814cd24208cc2365ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#a5e5fd08d30d58814cd24208cc2365ffb">More...</a><br/></td></tr>
<tr class="separator:a5e5fd08d30d58814cd24208cc2365ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9380376524cdcb253379a841ee93e50"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ad9380376524cdcb253379a841ee93e50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad9380376524cdcb253379a841ee93e50">permute_bytes16</a> (<a class="el" href="a00131.html">uint64</a>&lt; N &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ad9380376524cdcb253379a841ee93e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#ad9380376524cdcb253379a841ee93e50">More...</a><br/></td></tr>
<tr class="separator:ad9380376524cdcb253379a841ee93e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4608bc2f0d4fa9c6e8795d9192d944be"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a4608bc2f0d4fa9c6e8795d9192d944be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4608bc2f0d4fa9c6e8795d9192d944be">permute_bytes16</a> (<a class="el" href="a00020.html">float32</a>&lt; N &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a4608bc2f0d4fa9c6e8795d9192d944be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#a4608bc2f0d4fa9c6e8795d9192d944be">More...</a><br/></td></tr>
<tr class="separator:a4608bc2f0d4fa9c6e8795d9192d944be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729b44f44eb9e44b90c452ea37a83687"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a729b44f44eb9e44b90c452ea37a83687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a729b44f44eb9e44b90c452ea37a83687">permute_bytes16</a> (<a class="el" href="a00021.html">float64</a>&lt; N &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a729b44f44eb9e44b90c452ea37a83687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask.  <a href="#a729b44f44eb9e44b90c452ea37a83687">More...</a><br/></td></tr>
<tr class="separator:a729b44f44eb9e44b90c452ea37a83687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ace7e6e04e0477ca0ae96450f9d3d8997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ace7e6e04e0477ca0ae96450f9d3d8997">permute_zbytes16</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> mask)</td></tr>
<tr class="memdesc:ace7e6e04e0477ca0ae96450f9d3d8997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask, optionally selecting zero.  <a href="#ace7e6e04e0477ca0ae96450f9d3d8997">More...</a><br/></td></tr>
<tr class="separator:ace7e6e04e0477ca0ae96450f9d3d8997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75c2cea9f9c1972d2649ca245cda280"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:af75c2cea9f9c1972d2649ca245cda280"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af75c2cea9f9c1972d2649ca245cda280">permute_zbytes16</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:af75c2cea9f9c1972d2649ca245cda280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask, optionally selecting zero.  <a href="#af75c2cea9f9c1972d2649ca245cda280">More...</a><br/></td></tr>
<tr class="separator:af75c2cea9f9c1972d2649ca245cda280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87210c887a4d503f90e608ff10c8331"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ac87210c887a4d503f90e608ff10c8331"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac87210c887a4d503f90e608ff10c8331">permute_zbytes16</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ac87210c887a4d503f90e608ff10c8331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask, optionally selecting zero.  <a href="#ac87210c887a4d503f90e608ff10c8331">More...</a><br/></td></tr>
<tr class="separator:ac87210c887a4d503f90e608ff10c8331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53326a4946672d2e733638cd60267dbe"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a53326a4946672d2e733638cd60267dbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a53326a4946672d2e733638cd60267dbe">permute_zbytes16</a> (<a class="el" href="a00127.html">uint32</a>&lt; N &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a53326a4946672d2e733638cd60267dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask, optionally selecting zero.  <a href="#a53326a4946672d2e733638cd60267dbe">More...</a><br/></td></tr>
<tr class="separator:a53326a4946672d2e733638cd60267dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b467a4c8b2d3288ba0e9a7b2026104"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ad5b467a4c8b2d3288ba0e9a7b2026104"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad5b467a4c8b2d3288ba0e9a7b2026104">permute_zbytes16</a> (<a class="el" href="a00131.html">uint64</a>&lt; N &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ad5b467a4c8b2d3288ba0e9a7b2026104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask, optionally selecting zero.  <a href="#ad5b467a4c8b2d3288ba0e9a7b2026104">More...</a><br/></td></tr>
<tr class="separator:ad5b467a4c8b2d3288ba0e9a7b2026104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baf685cfad1ac330b88e2d559f73a9e"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a0baf685cfad1ac330b88e2d559f73a9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a0baf685cfad1ac330b88e2d559f73a9e">permute_zbytes16</a> (<a class="el" href="a00020.html">float32</a>&lt; N &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a0baf685cfad1ac330b88e2d559f73a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask, optionally selecting zero.  <a href="#a0baf685cfad1ac330b88e2d559f73a9e">More...</a><br/></td></tr>
<tr class="separator:a0baf685cfad1ac330b88e2d559f73a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ecaa40e2384a0dab10d61f4b8ef6f3"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ad8ecaa40e2384a0dab10d61f4b8ef6f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad8ecaa40e2384a0dab10d61f4b8ef6f3">permute_zbytes16</a> (<a class="el" href="a00021.html">float64</a>&lt; N &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ad8ecaa40e2384a0dab10d61f4b8ef6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from a vector according to a mask, optionally selecting zero.  <a href="#ad8ecaa40e2384a0dab10d61f4b8ef6f3">More...</a><br/></td></tr>
<tr class="separator:ad8ecaa40e2384a0dab10d61f4b8ef6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a20ef3dd84b7ebf2bd6f821f0f0a57c05"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_set_splat&lt;int&gt;&gt; </td></tr>
<tr class="memitem:a20ef3dd84b7ebf2bd6f821f0f0a57c05"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a20ef3dd84b7ebf2bd6f821f0f0a57c05">splat</a> (int x)</td></tr>
<tr class="memdesc:a20ef3dd84b7ebf2bd6f821f0f0a57c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a register and broadcasts it to all elements of a vector.  <a href="#a20ef3dd84b7ebf2bd6f821f0f0a57c05">More...</a><br/></td></tr>
<tr class="separator:a20ef3dd84b7ebf2bd6f821f0f0a57c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d06652df9b6c0348c0eb1d0ad2e163"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_set_splat&lt;unsigned&gt;&gt; </td></tr>
<tr class="memitem:af2d06652df9b6c0348c0eb1d0ad2e163"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af2d06652df9b6c0348c0eb1d0ad2e163">splat</a> (unsigned x)</td></tr>
<tr class="memdesc:af2d06652df9b6c0348c0eb1d0ad2e163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a register and broadcasts it to all elements of a vector.  <a href="#af2d06652df9b6c0348c0eb1d0ad2e163">More...</a><br/></td></tr>
<tr class="separator:af2d06652df9b6c0348c0eb1d0ad2e163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b6c234c50a5638b4f2ff7810a6397c"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_set_splat&lt;int64_t&gt;&gt; </td></tr>
<tr class="memitem:a01b6c234c50a5638b4f2ff7810a6397c"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a01b6c234c50a5638b4f2ff7810a6397c">splat</a> (int64_t x)</td></tr>
<tr class="memdesc:a01b6c234c50a5638b4f2ff7810a6397c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a register and broadcasts it to all elements of a vector.  <a href="#a01b6c234c50a5638b4f2ff7810a6397c">More...</a><br/></td></tr>
<tr class="separator:a01b6c234c50a5638b4f2ff7810a6397c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fab604b00a5a0cc95f23cf6fb70f29f"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_set_splat&lt;uint64_t&gt;&gt; </td></tr>
<tr class="memitem:a9fab604b00a5a0cc95f23cf6fb70f29f"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a9fab604b00a5a0cc95f23cf6fb70f29f">splat</a> (uint64_t x)</td></tr>
<tr class="memdesc:a9fab604b00a5a0cc95f23cf6fb70f29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a register and broadcasts it to all elements of a vector.  <a href="#a9fab604b00a5a0cc95f23cf6fb70f29f">More...</a><br/></td></tr>
<tr class="separator:a9fab604b00a5a0cc95f23cf6fb70f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e45524afc75598c18aa7cc290ba29d1"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_set_splat&lt;float&gt;&gt; </td></tr>
<tr class="memitem:a7e45524afc75598c18aa7cc290ba29d1"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7e45524afc75598c18aa7cc290ba29d1">splat</a> (float x)</td></tr>
<tr class="memdesc:a7e45524afc75598c18aa7cc290ba29d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a register and broadcasts it to all elements of a vector.  <a href="#a7e45524afc75598c18aa7cc290ba29d1">More...</a><br/></td></tr>
<tr class="separator:a7e45524afc75598c18aa7cc290ba29d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9a1324f1653fd892643a9a928e086"><td class="memTemplParams" colspan="2">template&lt;class V  = expr_vec_set_splat&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a7ee9a1324f1653fd892643a9a928e086"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7ee9a1324f1653fd892643a9a928e086">splat</a> (double x)</td></tr>
<tr class="memdesc:a7ee9a1324f1653fd892643a9a928e086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a register and broadcasts it to all elements of a vector.  <a href="#a7ee9a1324f1653fd892643a9a928e086">More...</a><br/></td></tr>
<tr class="separator:a7ee9a1324f1653fd892643a9a928e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a278fa4aa6167f9a23deadc3d1b51e0c8"><td class="memTemplParams" colspan="2">template&lt;unsigned sa0, unsigned sa1, unsigned sb0, unsigned sb1, unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a278fa4aa6167f9a23deadc3d1b51e0c8"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a278fa4aa6167f9a23deadc3d1b51e0c8">shuffle2</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a278fa4aa6167f9a23deadc3d1b51e0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects 32-bit floating-point values from two vectors.  <a href="#a278fa4aa6167f9a23deadc3d1b51e0c8">More...</a><br/></td></tr>
<tr class="separator:a278fa4aa6167f9a23deadc3d1b51e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b1175d39442f9b8eb99b1f4d4b98d1"><td class="memTemplParams" colspan="2">template&lt;unsigned s0, unsigned s1, unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:aa0b1175d39442f9b8eb99b1f4d4b98d1"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa0b1175d39442f9b8eb99b1f4d4b98d1">shuffle2</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aa0b1175d39442f9b8eb99b1f4d4b98d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects 32-bit values from two vectors.  <a href="#aa0b1175d39442f9b8eb99b1f4d4b98d1">More...</a><br/></td></tr>
<tr class="separator:aa0b1175d39442f9b8eb99b1f4d4b98d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a46464c3a48628ec0d6a6593cf544566a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a46464c3a48628ec0d6a6593cf544566a">shuffle_bytes16</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> b, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> mask)</td></tr>
<tr class="memdesc:a46464c3a48628ec0d6a6593cf544566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask.  <a href="#a46464c3a48628ec0d6a6593cf544566a">More...</a><br/></td></tr>
<tr class="separator:a46464c3a48628ec0d6a6593cf544566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e67a0f5a628b3275f23da530e59c294"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a0e67a0f5a628b3275f23da530e59c294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a0e67a0f5a628b3275f23da530e59c294">shuffle_bytes16</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; b, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a0e67a0f5a628b3275f23da530e59c294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask.  <a href="#a0e67a0f5a628b3275f23da530e59c294">More...</a><br/></td></tr>
<tr class="separator:a0e67a0f5a628b3275f23da530e59c294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936ab3b037dfed49a5928151212394a5"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a936ab3b037dfed49a5928151212394a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a936ab3b037dfed49a5928151212394a5">shuffle_bytes16</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; b, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a936ab3b037dfed49a5928151212394a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask.  <a href="#a936ab3b037dfed49a5928151212394a5">More...</a><br/></td></tr>
<tr class="separator:a936ab3b037dfed49a5928151212394a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa662d47992a1b4d17d18105beb9a695f"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:aa662d47992a1b4d17d18105beb9a695f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa662d47992a1b4d17d18105beb9a695f">shuffle_bytes16</a> (<a class="el" href="a00127.html">uint32</a>&lt; N &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; b, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:aa662d47992a1b4d17d18105beb9a695f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask.  <a href="#aa662d47992a1b4d17d18105beb9a695f">More...</a><br/></td></tr>
<tr class="separator:aa662d47992a1b4d17d18105beb9a695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1607b66cafb0b985b16eb3b99a1d2ac3"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a1607b66cafb0b985b16eb3b99a1d2ac3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1607b66cafb0b985b16eb3b99a1d2ac3">shuffle_bytes16</a> (<a class="el" href="a00131.html">uint64</a>&lt; N &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; b, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a1607b66cafb0b985b16eb3b99a1d2ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask.  <a href="#a1607b66cafb0b985b16eb3b99a1d2ac3">More...</a><br/></td></tr>
<tr class="separator:a1607b66cafb0b985b16eb3b99a1d2ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d9e9d7e199550c0f0446dc19891ab9"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a01d9e9d7e199550c0f0446dc19891ab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a01d9e9d7e199550c0f0446dc19891ab9">shuffle_bytes16</a> (<a class="el" href="a00020.html">float32</a>&lt; N &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N &gt; b, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a01d9e9d7e199550c0f0446dc19891ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask.  <a href="#a01d9e9d7e199550c0f0446dc19891ab9">More...</a><br/></td></tr>
<tr class="separator:a01d9e9d7e199550c0f0446dc19891ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324c0dc1ba647cdd70fed4364b5e46fe"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a324c0dc1ba647cdd70fed4364b5e46fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a324c0dc1ba647cdd70fed4364b5e46fe">shuffle_bytes16</a> (<a class="el" href="a00021.html">float64</a>&lt; N &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N &gt; b, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a324c0dc1ba647cdd70fed4364b5e46fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask.  <a href="#a324c0dc1ba647cdd70fed4364b5e46fe">More...</a><br/></td></tr>
<tr class="separator:a324c0dc1ba647cdd70fed4364b5e46fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a339c0c0894d958de219f40ef8656944a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a339c0c0894d958de219f40ef8656944a">shuffle_zbytes16</a> (<a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> a, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> b, <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> mask)</td></tr>
<tr class="memdesc:a339c0c0894d958de219f40ef8656944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask, optionally selecting zero.  <a href="#a339c0c0894d958de219f40ef8656944a">More...</a><br/></td></tr>
<tr class="separator:a339c0c0894d958de219f40ef8656944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04d2d45fcc88a1384654a5c4cabf061"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:aa04d2d45fcc88a1384654a5c4cabf061"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa04d2d45fcc88a1384654a5c4cabf061">shuffle_zbytes16</a> (<a class="el" href="a00135.html">uint8</a>&lt; N &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; b, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:aa04d2d45fcc88a1384654a5c4cabf061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask, optionally selecting zero.  <a href="#aa04d2d45fcc88a1384654a5c4cabf061">More...</a><br/></td></tr>
<tr class="separator:aa04d2d45fcc88a1384654a5c4cabf061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3d22291398426ae85362d94da478b9"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a1a3d22291398426ae85362d94da478b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a1a3d22291398426ae85362d94da478b9">shuffle_zbytes16</a> (<a class="el" href="a00123.html">uint16</a>&lt; N &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; b, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a1a3d22291398426ae85362d94da478b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask, optionally selecting zero.  <a href="#a1a3d22291398426ae85362d94da478b9">More...</a><br/></td></tr>
<tr class="separator:a1a3d22291398426ae85362d94da478b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133cc655b962d586ba81c16452bf2da"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:af133cc655b962d586ba81c16452bf2da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af133cc655b962d586ba81c16452bf2da">shuffle_zbytes16</a> (<a class="el" href="a00127.html">uint32</a>&lt; N &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; b, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:af133cc655b962d586ba81c16452bf2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask, optionally selecting zero.  <a href="#af133cc655b962d586ba81c16452bf2da">More...</a><br/></td></tr>
<tr class="separator:af133cc655b962d586ba81c16452bf2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae138b38d09693d90ed6066ca116dc488"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ae138b38d09693d90ed6066ca116dc488"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ae138b38d09693d90ed6066ca116dc488">shuffle_zbytes16</a> (<a class="el" href="a00131.html">uint64</a>&lt; N &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; b, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ae138b38d09693d90ed6066ca116dc488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask, optionally selecting zero.  <a href="#ae138b38d09693d90ed6066ca116dc488">More...</a><br/></td></tr>
<tr class="separator:ae138b38d09693d90ed6066ca116dc488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c6546bcae7edf6a9f6987e8971d79"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:aef0c6546bcae7edf6a9f6987e8971d79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aef0c6546bcae7edf6a9f6987e8971d79">shuffle_zbytes16</a> (<a class="el" href="a00020.html">float32</a>&lt; N &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N &gt; b, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:aef0c6546bcae7edf6a9f6987e8971d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask, optionally selecting zero.  <a href="#aef0c6546bcae7edf6a9f6987e8971d79">More...</a><br/></td></tr>
<tr class="separator:aef0c6546bcae7edf6a9f6987e8971d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e4c9d2d98c3b02edba5a44c5a017e9"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a74e4c9d2d98c3b02edba5a44c5a017e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a74e4c9d2d98c3b02edba5a44c5a017e9">shuffle_zbytes16</a> (<a class="el" href="a00021.html">float64</a>&lt; N &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N &gt; b, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a74e4c9d2d98c3b02edba5a44c5a017e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects bytes from two vectors according to a mask, optionally selecting zero.  <a href="#a74e4c9d2d98c3b02edba5a44c5a017e9">More...</a><br/></td></tr>
<tr class="separator:a74e4c9d2d98c3b02edba5a44c5a017e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8db1bd4774382f83ac647eb05a394893"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class V &gt; </td></tr>
<tr class="memitem:a8db1bd4774382f83ac647eb05a394893"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr_nomask&lt; V, <br class="typebreak"/>
void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8db1bd4774382f83ac647eb05a394893">splat</a> (const <a class="el" href="a00018.html">any_vec</a>&lt; N, V &gt; &amp;a)</td></tr>
<tr class="memdesc:a8db1bd4774382f83ac647eb05a394893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified element to all elements.  <a href="#a8db1bd4774382f83ac647eb05a394893">More...</a><br/></td></tr>
<tr class="separator:a8db1bd4774382f83ac647eb05a394893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a81b48a4d10a52523171769236a3a2714"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a81b48a4d10a52523171769236a3a2714"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00052.html">expr_splat16</a>&lt; s, <a class="el" href="a00025.html">int8</a><br class="typebreak"/>
&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a81b48a4d10a52523171769236a3a2714">splat16</a> (<a class="el" href="a00025.html">int8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a81b48a4d10a52523171769236a3a2714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 8-bit value to all elements within 128-bit lanes.  <a href="#a81b48a4d10a52523171769236a3a2714">More...</a><br/></td></tr>
<tr class="separator:a81b48a4d10a52523171769236a3a2714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f73adb0766b415789cef8892fa753e4"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a4f73adb0766b415789cef8892fa753e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00052.html">expr_splat16</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00135.html">uint8</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4f73adb0766b415789cef8892fa753e4">splat16</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a4f73adb0766b415789cef8892fa753e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 8-bit value to all elements within 128-bit lanes.  <a href="#a4f73adb0766b415789cef8892fa753e4">More...</a><br/></td></tr>
<tr class="separator:a4f73adb0766b415789cef8892fa753e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9001ceaa947d4c3592feadac3df7ca9"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:ac9001ceaa947d4c3592feadac3df7ca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00055.html">expr_splat8</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac9001ceaa947d4c3592feadac3df7ca9">splat8</a> (<a class="el" href="a00022.html">int16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:ac9001ceaa947d4c3592feadac3df7ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 16-bit value to all elements within 128-bit lanes.  <a href="#ac9001ceaa947d4c3592feadac3df7ca9">More...</a><br/></td></tr>
<tr class="separator:ac9001ceaa947d4c3592feadac3df7ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080c5ee7b6017736b3a39983facf682b"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a080c5ee7b6017736b3a39983facf682b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00055.html">expr_splat8</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00123.html">uint16</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a080c5ee7b6017736b3a39983facf682b">splat8</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a080c5ee7b6017736b3a39983facf682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 16-bit value to all elements within 128-bit lanes.  <a href="#a080c5ee7b6017736b3a39983facf682b">More...</a><br/></td></tr>
<tr class="separator:a080c5ee7b6017736b3a39983facf682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af8bf115f90afe41b27d34884007e589b"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:af8bf115f90afe41b27d34884007e589b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00054.html">expr_splat4</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#af8bf115f90afe41b27d34884007e589b">splat4</a> (<a class="el" href="a00023.html">int32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:af8bf115f90afe41b27d34884007e589b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 32-bit value to all elements within 128-bit lanes.  <a href="#af8bf115f90afe41b27d34884007e589b">More...</a><br/></td></tr>
<tr class="separator:af8bf115f90afe41b27d34884007e589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483c93fac94d14fc18ad43a2750a795d"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a483c93fac94d14fc18ad43a2750a795d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00054.html">expr_splat4</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00127.html">uint32</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a483c93fac94d14fc18ad43a2750a795d">splat4</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a483c93fac94d14fc18ad43a2750a795d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 32-bit value to all elements within 128-bit lanes.  <a href="#a483c93fac94d14fc18ad43a2750a795d">More...</a><br/></td></tr>
<tr class="separator:a483c93fac94d14fc18ad43a2750a795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a21737f6d0da525e8f93924d4e2420fd3"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a21737f6d0da525e8f93924d4e2420fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00053.html">expr_splat2</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a21737f6d0da525e8f93924d4e2420fd3">splat2</a> (<a class="el" href="a00024.html">int64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a21737f6d0da525e8f93924d4e2420fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 64-bit value to all elements within 128-bit lanes.  <a href="#a21737f6d0da525e8f93924d4e2420fd3">More...</a><br/></td></tr>
<tr class="separator:a21737f6d0da525e8f93924d4e2420fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c89b28fdb1789048249a32edc4fd52"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:a77c89b28fdb1789048249a32edc4fd52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00053.html">expr_splat2</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00131.html">uint64</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a77c89b28fdb1789048249a32edc4fd52">splat2</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:a77c89b28fdb1789048249a32edc4fd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 64-bit value to all elements within 128-bit lanes.  <a href="#a77c89b28fdb1789048249a32edc4fd52">More...</a><br/></td></tr>
<tr class="separator:a77c89b28fdb1789048249a32edc4fd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adba85714a35ff2c0f71e3308e926d71b"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:adba85714a35ff2c0f71e3308e926d71b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00054.html">expr_splat4</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#adba85714a35ff2c0f71e3308e926d71b">splat4</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:adba85714a35ff2c0f71e3308e926d71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 32-bit value to all elements within 128-bit lanes.  <a href="#adba85714a35ff2c0f71e3308e926d71b">More...</a><br/></td></tr>
<tr class="separator:adba85714a35ff2c0f71e3308e926d71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acc82f7e042e5c2dd3b6f41791699cf09"><td class="memTemplParams" colspan="2">template&lt;unsigned s, unsigned N, class E &gt; </td></tr>
<tr class="memitem:acc82f7e042e5c2dd3b6f41791699cf09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00053.html">expr_splat2</a>&lt; s, <br class="typebreak"/>
<a class="el" href="a00021.html">float64</a>&lt; N, E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#acc82f7e042e5c2dd3b6f41791699cf09">splat2</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E &gt; a)</td></tr>
<tr class="memdesc:acc82f7e042e5c2dd3b6f41791699cf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the specified 64-bit value to all elements within 128-bit lanes.  <a href="#acc82f7e042e5c2dd3b6f41791699cf09">More...</a><br/></td></tr>
<tr class="separator:acc82f7e042e5c2dd3b6f41791699cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abedd53be61669845b7dc8b40b800edce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#abedd53be61669845b7dc8b40b800edce">to_float32</a> (<a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> a)</td></tr>
<tr class="memdesc:abedd53be61669845b7dc8b40b800edce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 32-bit integer values to 32-bit float values.  <a href="#abedd53be61669845b7dc8b40b800edce">More...</a><br/></td></tr>
<tr class="separator:abedd53be61669845b7dc8b40b800edce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab664dde884f3d1b3024ab93d7210d781"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ab664dde884f3d1b3024ab93d7210d781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ab664dde884f3d1b3024ab93d7210d781">to_float32</a> (<a class="el" href="a00023.html">int32</a>&lt; N &gt; a)</td></tr>
<tr class="memdesc:ab664dde884f3d1b3024ab93d7210d781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 32-bit integer values to 32-bit float values.  <a href="#ab664dde884f3d1b3024ab93d7210d781">More...</a><br/></td></tr>
<tr class="separator:ab664dde884f3d1b3024ab93d7210d781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a32d8eb3c717b5f5be926d92d77ee11e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a32d8eb3c717b5f5be926d92d77ee11e8">to_float32</a> (<a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> a)</td></tr>
<tr class="memdesc:a32d8eb3c717b5f5be926d92d77ee11e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 64-bit float values to 32-bit float values.  <a href="#a32d8eb3c717b5f5be926d92d77ee11e8">More...</a><br/></td></tr>
<tr class="separator:a32d8eb3c717b5f5be926d92d77ee11e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4de0a98825cd64942cda55345e20f89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a4de0a98825cd64942cda55345e20f89c">to_float64</a> (<a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> a)</td></tr>
<tr class="memdesc:a4de0a98825cd64942cda55345e20f89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the 32-bit integer values to 64-bit float values.  <a href="#a4de0a98825cd64942cda55345e20f89c">More...</a><br/></td></tr>
<tr class="separator:a4de0a98825cd64942cda55345e20f89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a31451c628d1165fec02f1db37b555c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a3a31451c628d1165fec02f1db37b555c">to_float64</a> (<a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> a)</td></tr>
<tr class="memdesc:a3a31451c628d1165fec02f1db37b555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the 32-bit float values to 64-bit float values.  <a href="#a3a31451c628d1165fec02f1db37b555c">More...</a><br/></td></tr>
<tr class="separator:a3a31451c628d1165fec02f1db37b555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a67d6fc7f844f1091901d5e5e757f68aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a67d6fc7f844f1091901d5e5e757f68aa">to_int32</a> (<a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> a)</td></tr>
<tr class="memdesc:a67d6fc7f844f1091901d5e5e757f68aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the values of a float32x4 vector into signed int32_t representation using truncation if only an inexact conversion can be performed.  <a href="#a67d6fc7f844f1091901d5e5e757f68aa">More...</a><br/></td></tr>
<tr class="separator:a67d6fc7f844f1091901d5e5e757f68aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a569752132430cba7b86bbb2392d23"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ac3a569752132430cba7b86bbb2392d23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac3a569752132430cba7b86bbb2392d23">to_int32x8</a> (<a class="el" href="a00020.html">float32</a>&lt; N &gt; a)</td></tr>
<tr class="memdesc:ac3a569752132430cba7b86bbb2392d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the values of a float32x4 vector into signed int32_t representation using truncation if only an inexact conversion can be performed.  <a href="#ac3a569752132430cba7b86bbb2392d23">More...</a><br/></td></tr>
<tr class="separator:ac3a569752132430cba7b86bbb2392d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9077a37c4d6c107a48c9de643a94e122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a9077a37c4d6c107a48c9de643a94e122">to_int32</a> (<a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> a)</td></tr>
<tr class="memdesc:a9077a37c4d6c107a48c9de643a94e122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the values of a doublex2 vector into int32_t representation using truncation.  <a href="#a9077a37c4d6c107a48c9de643a94e122">More...</a><br/></td></tr>
<tr class="separator:a9077a37c4d6c107a48c9de643a94e122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ace2349f5a9358fe2c69abfb5be14cd85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ace2349f5a9358fe2c69abfb5be14cd85">to_int64</a> (<a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> a)</td></tr>
<tr class="memdesc:ace2349f5a9358fe2c69abfb5be14cd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the values of a signed int32x4 vector to 64-bits.  <a href="#ace2349f5a9358fe2c69abfb5be14cd85">More...</a><br/></td></tr>
<tr class="separator:ace2349f5a9358fe2c69abfb5be14cd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979c58a8b0274077eb9281b89e8fb671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a979c58a8b0274077eb9281b89e8fb671">to_int64</a> (<a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">uint32x4</a> a)</td></tr>
<tr class="memdesc:a979c58a8b0274077eb9281b89e8fb671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the values of an unsigned int32x4 vector to 64-bits.  <a href="#a979c58a8b0274077eb9281b89e8fb671">More...</a><br/></td></tr>
<tr class="separator:a979c58a8b0274077eb9281b89e8fb671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa0c9c9cc95e346c886bb3533e1007d4b"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:aa0c9c9cc95e346c886bb3533e1007d4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa0c9c9cc95e346c886bb3533e1007d4b">unzip16_hi</a> (<a class="el" href="a00135.html">uint8</a>&lt; N, E1 &gt; a, <a class="el" href="a00135.html">uint8</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:aa0c9c9cc95e346c886bb3533e1007d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two int8x16 vectors.  <a href="#aa0c9c9cc95e346c886bb3533e1007d4b">More...</a><br/></td></tr>
<tr class="separator:aa0c9c9cc95e346c886bb3533e1007d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9e3674f2cf1c7cba35e0ade19992ea"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a8f9e3674f2cf1c7cba35e0ade19992ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a8f9e3674f2cf1c7cba35e0ade19992ea">unzip8_hi</a> (<a class="el" href="a00123.html">uint16</a>&lt; N, E1 &gt; a, <a class="el" href="a00123.html">uint16</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a8f9e3674f2cf1c7cba35e0ade19992ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two int16x8 vectors.  <a href="#a8f9e3674f2cf1c7cba35e0ade19992ea">More...</a><br/></td></tr>
<tr class="separator:a8f9e3674f2cf1c7cba35e0ade19992ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465862c8c577cb1be6180b12c5b863b3"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a465862c8c577cb1be6180b12c5b863b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a465862c8c577cb1be6180b12c5b863b3">unzip4_hi</a> (<a class="el" href="a00127.html">uint32</a>&lt; N, E1 &gt; a, <a class="el" href="a00127.html">uint32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a465862c8c577cb1be6180b12c5b863b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two int32x4 vectors.  <a href="#a465862c8c577cb1be6180b12c5b863b3">More...</a><br/></td></tr>
<tr class="separator:a465862c8c577cb1be6180b12c5b863b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8137f2298b755e5331e18f9783d6a75"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ac8137f2298b755e5331e18f9783d6a75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ac8137f2298b755e5331e18f9783d6a75">unzip2_hi</a> (<a class="el" href="a00131.html">uint64</a>&lt; N, E1 &gt; a, <a class="el" href="a00131.html">uint64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ac8137f2298b755e5331e18f9783d6a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two int64x2 vectors.  <a href="#ac8137f2298b755e5331e18f9783d6a75">More...</a><br/></td></tr>
<tr class="separator:ac8137f2298b755e5331e18f9783d6a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f01aabf4c4999ca147a62c09dff9a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ace8f01aabf4c4999ca147a62c09dff9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00020.html">float32</a>&lt; N, <a class="el" href="a00020.html">float32</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ace8f01aabf4c4999ca147a62c09dff9a">unzip4_hi</a> (<a class="el" href="a00020.html">float32</a>&lt; N, E1 &gt; a, <a class="el" href="a00020.html">float32</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:ace8f01aabf4c4999ca147a62c09dff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two float32x4 vectors.  <a href="#ace8f01aabf4c4999ca147a62c09dff9a">More...</a><br/></td></tr>
<tr class="separator:ace8f01aabf4c4999ca147a62c09dff9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f7b085cdcc2dfc968249d39c28c166"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a26f7b085cdcc2dfc968249d39c28c166"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00021.html">float64</a>&lt; N, <a class="el" href="a00021.html">float64</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a26f7b085cdcc2dfc968249d39c28c166">unzip2_hi</a> (<a class="el" href="a00021.html">float64</a>&lt; N, E1 &gt; a, <a class="el" href="a00021.html">float64</a>&lt; N, E2 &gt; b)</td></tr>
<tr class="memdesc:a26f7b085cdcc2dfc968249d39c28c166"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-interleaves the even(higher) elements of two float64x2 vectors.  <a href="#a26f7b085cdcc2dfc968249d39c28c166">More...</a><br/></td></tr>
<tr class="separator:a26f7b085cdcc2dfc968249d39c28c166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa17419954add2a414828dd078ea90e7f"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:aa17419954add2a414828dd078ea90e7f"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#aa17419954add2a414828dd078ea90e7f">zip16_hi</a> (const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aa17419954add2a414828dd078ea90e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#aa17419954add2a414828dd078ea90e7f">More...</a><br/></td></tr>
<tr class="separator:aa17419954add2a414828dd078ea90e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3a63afcd58d77294ccc8252f62e718"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:adf3a63afcd58d77294ccc8252f62e718"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#adf3a63afcd58d77294ccc8252f62e718">zip8_hi</a> (const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:adf3a63afcd58d77294ccc8252f62e718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#adf3a63afcd58d77294ccc8252f62e718">More...</a><br/></td></tr>
<tr class="separator:adf3a63afcd58d77294ccc8252f62e718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df7922ab8f779fbf68e5c9b02a0722a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a5df7922ab8f779fbf68e5c9b02a0722a"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a5df7922ab8f779fbf68e5c9b02a0722a">zip4_hi</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a5df7922ab8f779fbf68e5c9b02a0722a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#a5df7922ab8f779fbf68e5c9b02a0722a">More...</a><br/></td></tr>
<tr class="separator:a5df7922ab8f779fbf68e5c9b02a0722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58837fe38f00b5d9321b81bd87fdaf7"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad58837fe38f00b5d9321b81bd87fdaf7"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#ad58837fe38f00b5d9321b81bd87fdaf7">zip2_hi</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ad58837fe38f00b5d9321b81bd87fdaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the higher halves of two vectors.  <a href="#ad58837fe38f00b5d9321b81bd87fdaf7">More...</a><br/></td></tr>
<tr class="separator:ad58837fe38f00b5d9321b81bd87fdaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abaf75ea95edfd3044789e8dc34b63691"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:abaf75ea95edfd3044789e8dc34b63691"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#abaf75ea95edfd3044789e8dc34b63691">zip16_lo</a> (const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00017.html">any_vec8</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:abaf75ea95edfd3044789e8dc34b63691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#abaf75ea95edfd3044789e8dc34b63691">More...</a><br/></td></tr>
<tr class="separator:abaf75ea95edfd3044789e8dc34b63691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7877fb314db391b60e8cc50c928a09e9"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a7877fb314db391b60e8cc50c928a09e9"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a7877fb314db391b60e8cc50c928a09e9">zip8_lo</a> (const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00014.html">any_vec16</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a7877fb314db391b60e8cc50c928a09e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#a7877fb314db391b60e8cc50c928a09e9">More...</a><br/></td></tr>
<tr class="separator:a7877fb314db391b60e8cc50c928a09e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12525d4e72ed06a487fab061d3c4394a"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a12525d4e72ed06a487fab061d3c4394a"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a12525d4e72ed06a487fab061d3c4394a">zip4_lo</a> (const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00015.html">any_vec32</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a12525d4e72ed06a487fab061d3c4394a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#a12525d4e72ed06a487fab061d3c4394a">More...</a><br/></td></tr>
<tr class="separator:a12525d4e72ed06a487fab061d3c4394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c006705ed8ee5ef56cf17702dda9a48"><td class="memTemplParams" colspan="2">template&lt;unsigned N, class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a4c006705ed8ee5ef56cf17702dda9a48"><td class="memTemplItemLeft" align="right" valign="top">detail::get_expr2_nomask&lt; V1, <br class="typebreak"/>
V2, void &gt;::empty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#a4c006705ed8ee5ef56cf17702dda9a48">zip2_lo</a> (const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V1 &gt; &amp;a, const <a class="el" href="a00016.html">any_vec64</a>&lt; N, V2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a4c006705ed8ee5ef56cf17702dda9a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the lower halves of two vectors.  <a href="#a4c006705ed8ee5ef56cf17702dda9a48">More...</a><br/></td></tr>
<tr class="separator:a4c006705ed8ee5ef56cf17702dda9a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaccd069283aa674f25a0223e797465acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#gaccd069283aa674f25a0223e797465acc">operator|=</a> (<a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;x, const <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;y)</td></tr>
<tr class="memdesc:gaccd069283aa674f25a0223e797465acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operators for <code>Arch</code>.  <a href="a00420.html#gaccd069283aa674f25a0223e797465acc">More...</a><br/></td></tr>
<tr class="separator:gaccd069283aa674f25a0223e797465acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393c6361b34c2e4d4bd1d8474dd4d140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#ga393c6361b34c2e4d4bd1d8474dd4d140">operator&amp;=</a> (<a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;x, const <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;y)</td></tr>
<tr class="memdesc:ga393c6361b34c2e4d4bd1d8474dd4d140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operators for <code>Arch</code>.  <a href="a00420.html#ga393c6361b34c2e4d4bd1d8474dd4d140">More...</a><br/></td></tr>
<tr class="separator:ga393c6361b34c2e4d4bd1d8474dd4d140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65f225594866cec403804180c1a80b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#gae65f225594866cec403804180c1a80b8">operator|</a> (const <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;x, const <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;y)</td></tr>
<tr class="memdesc:gae65f225594866cec403804180c1a80b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operators for <code>Arch</code>.  <a href="a00420.html#gae65f225594866cec403804180c1a80b8">More...</a><br/></td></tr>
<tr class="separator:gae65f225594866cec403804180c1a80b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46de53d24834d2e128098807a5e3ad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#gae46de53d24834d2e128098807a5e3ad6">operator&amp;</a> (const <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;x, const <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;y)</td></tr>
<tr class="memdesc:gae46de53d24834d2e128098807a5e3ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operators for <code>Arch</code>.  <a href="a00420.html#gae46de53d24834d2e128098807a5e3ad6">More...</a><br/></td></tr>
<tr class="separator:gae46de53d24834d2e128098807a5e3ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga492daf1de430083aa9b8810975fb0839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html#ga492daf1de430083aa9b8810975fb0839">operator~</a> (const <a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> &amp;x)</td></tr>
<tr class="memdesc:ga492daf1de430083aa9b8810975fb0839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operators for <code>Arch</code>.  <a href="a00420.html#ga492daf1de430083aa9b8810975fb0839">More...</a><br/></td></tr>
<tr class="separator:ga492daf1de430083aa9b8810975fb0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5876ca85abbab40fa7ed12e91546f774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a5876ca85abbab40fa7ed12e91546f774">simdpp::float32v</a> = typedef <a class="el" href="a00020.html">float32</a>&lt;SIMDPP_FAST_FLOAT32_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aadf470566815d9760d834f02f3d09126"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#aadf470566815d9760d834f02f3d09126">simdpp::float32v4</a> = typedef <a class="el" href="a00020.html">float32</a>&lt;SIMDPP_FAST_FLOAT32_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2892535dd751dc65998ffb71e1aaeb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">simdpp::float32x4</a> = typedef <a class="el" href="a00020.html">float32</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf873a9926daeeb1ca3a4d94aa0beb15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#adf873a9926daeeb1ca3a4d94aa0beb15">simdpp::float32x8</a> = typedef <a class="el" href="a00020.html">float32</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d7a460b6530460c48ccd3997c83a220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a0d7a460b6530460c48ccd3997c83a220">simdpp::float64v</a> = typedef <a class="el" href="a00021.html">float64</a>&lt;SIMDPP_FAST_FLOAT64_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a699b2df7b6d1dffbabce1cfdfb09c278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a699b2df7b6d1dffbabce1cfdfb09c278">simdpp::float64v2</a> = typedef <a class="el" href="a00021.html">float64</a>&lt;SIMDPP_FAST_FLOAT64_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9eb7e167c35b997a9885a2addb654ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a9eb7e167c35b997a9885a2addb654ccc">simdpp::float64v4</a> = typedef <a class="el" href="a00021.html">float64</a>&lt;SIMDPP_FAST_FLOAT64_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abdcdb04bee0301a502678b15b613cdc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#abdcdb04bee0301a502678b15b613cdc2">simdpp::float64x2</a> = typedef <a class="el" href="a00021.html">float64</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c6da1e3ea4a68551086bddb9c0f54f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">simdpp::float64x4</a> = typedef <a class="el" href="a00021.html">float64</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab051b76cb6f5d602d27c750be7e3235f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ab051b76cb6f5d602d27c750be7e3235f">simdpp::int16v</a> = typedef <a class="el" href="a00022.html">int16</a>&lt;SIMDPP_FAST_INT16_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b962cd8ac9d6ed8c2ba56ee3fd26610"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a9b962cd8ac9d6ed8c2ba56ee3fd26610">simdpp::int16v2</a> = typedef <a class="el" href="a00022.html">int16</a>&lt;SIMDPP_FAST_INT16_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc716bce6a3697384fbaff6ab124e0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#abc716bce6a3697384fbaff6ab124e0bf">simdpp::int16v4</a> = typedef <a class="el" href="a00022.html">int16</a>&lt;SIMDPP_FAST_INT16_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a873c12cd4e0429754b8ec03d501221d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a873c12cd4e0429754b8ec03d501221d7">simdpp::int16x16</a> = typedef <a class="el" href="a00022.html">int16</a>&lt;16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b2e24bda9b4fc2e661f92f428d66338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a3b2e24bda9b4fc2e661f92f428d66338">simdpp::int16x8</a> = typedef <a class="el" href="a00022.html">int16</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7764655e6a399e09809cf0ca25f05242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a7764655e6a399e09809cf0ca25f05242">simdpp::int32v</a> = typedef <a class="el" href="a00023.html">int32</a>&lt;SIMDPP_FAST_INT32_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa579219029d2146bcc6fe2773b1ee2da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#aa579219029d2146bcc6fe2773b1ee2da">simdpp::int32v2</a> = typedef <a class="el" href="a00023.html">int32</a>&lt;SIMDPP_FAST_INT32_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa507ad3ff49bf66e369038d1286836f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#aa507ad3ff49bf66e369038d1286836f5">simdpp::int32v4</a> = typedef <a class="el" href="a00023.html">int32</a>&lt;SIMDPP_FAST_INT32_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad58023c756757d023687e5daa41f3be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">simdpp::int32x4</a> = typedef <a class="el" href="a00023.html">int32</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3c0263ee6d69f8fe2891c69359440ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">simdpp::int32x8</a> = typedef <a class="el" href="a00023.html">int32</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a94dde11bc7f9e1954f61e03d6aa6fba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a94dde11bc7f9e1954f61e03d6aa6fba2">simdpp::int64v</a> = typedef <a class="el" href="a00024.html">int64</a>&lt;SIMDPP_FAST_INT64_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa351656d6b414873ca95c47d3000d06c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#aa351656d6b414873ca95c47d3000d06c">simdpp::int64v2</a> = typedef <a class="el" href="a00024.html">int64</a>&lt;SIMDPP_FAST_INT64_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af72098c16c63296a58f29a975c48b0dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#af72098c16c63296a58f29a975c48b0dd">simdpp::int64v4</a> = typedef <a class="el" href="a00024.html">int64</a>&lt;SIMDPP_FAST_INT64_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a44fea5c7167ea63298fe297c499d9814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a44fea5c7167ea63298fe297c499d9814">simdpp::int64x2</a> = typedef <a class="el" href="a00024.html">int64</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8da9597a0403650325e7b0df8893d6a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a8da9597a0403650325e7b0df8893d6a3">simdpp::int64x4</a> = typedef <a class="el" href="a00024.html">int64</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a802cec15d01221d578bb508369310129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a802cec15d01221d578bb508369310129">simdpp::int8v</a> = typedef <a class="el" href="a00025.html">int8</a>&lt;SIMDPP_FAST_INT8_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a66fa73d2ef1bcd3ca07be763da07c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a7a66fa73d2ef1bcd3ca07be763da07c5">simdpp::int8v2</a> = typedef <a class="el" href="a00025.html">int8</a>&lt;SIMDPP_FAST_INT8_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aba3c15b1eab5f199e10f0dbd6d4ae01a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#aba3c15b1eab5f199e10f0dbd6d4ae01a">simdpp::int8v4</a> = typedef <a class="el" href="a00025.html">int8</a>&lt;SIMDPP_FAST_INT8_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a04bf64e6f29bfddf2a8c9036c8755132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a04bf64e6f29bfddf2a8c9036c8755132">simdpp::int8x16</a> = typedef <a class="el" href="a00025.html">int8</a>&lt;16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b2056b5479d97aa816fa946eb925fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a7b2056b5479d97aa816fa946eb925fca">simdpp::int8x32</a> = typedef <a class="el" href="a00025.html">int8</a>&lt;32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae434b87dace1c712306c8817176df849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ae434b87dace1c712306c8817176df849">simdpp::mask_float32v</a> = typedef <a class="el" href="a00026.html">mask_float32</a>&lt;SIMDPP_FAST_FLOAT32_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84b6de057707f9e2587a3d6b0820a35a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a84b6de057707f9e2587a3d6b0820a35a">simdpp::mask_float32v2</a> = typedef <a class="el" href="a00026.html">mask_float32</a>&lt;SIMDPP_FAST_FLOAT32_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afcafd1349e6e6bee86fee131528ed7f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#afcafd1349e6e6bee86fee131528ed7f7">simdpp::mask_float32v4</a> = typedef <a class="el" href="a00026.html">mask_float32</a>&lt;SIMDPP_FAST_FLOAT32_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a623fb0bc7684000397d1210d7a7f55ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a623fb0bc7684000397d1210d7a7f55ef">simdpp::mask_float32x4</a> = typedef <a class="el" href="a00026.html">mask_float32</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d9b76b6b6f66f996f6097e693c139a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a6d9b76b6b6f66f996f6097e693c139a9">simdpp::mask_float32x8</a> = typedef <a class="el" href="a00026.html">mask_float32</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5e2441ca0ef219e14741d5b8f1570ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a5e2441ca0ef219e14741d5b8f1570ea1">simdpp::mask_float64v</a> = typedef <a class="el" href="a00027.html">mask_float64</a>&lt;SIMDPP_FAST_FLOAT64_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a54d4788951be0805bdd72be20ae948a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a54d4788951be0805bdd72be20ae948a0">simdpp::mask_float64v2</a> = typedef <a class="el" href="a00027.html">mask_float64</a>&lt;SIMDPP_FAST_FLOAT64_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa400af09a7e4eb2786e1c4b12b1ed54f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#aa400af09a7e4eb2786e1c4b12b1ed54f">simdpp::mask_float64v4</a> = typedef <a class="el" href="a00027.html">mask_float64</a>&lt;SIMDPP_FAST_FLOAT64_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7de241f18e59796c7e25255458997c56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a7de241f18e59796c7e25255458997c56">simdpp::mask_float64x2</a> = typedef <a class="el" href="a00027.html">mask_float64</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae538ea7c8001934e9d4d048a2894274c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ae538ea7c8001934e9d4d048a2894274c">simdpp::mask_float64x4</a> = typedef <a class="el" href="a00027.html">mask_float64</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a82044d10f10df4cc0948c380ac1e5357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a82044d10f10df4cc0948c380ac1e5357">simdpp::mask_int16v</a> = typedef <a class="el" href="a00028.html">mask_int16</a>&lt;SIMDPP_FAST_INT16_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab104cf04a97174f5d47e87a7624a946a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ab104cf04a97174f5d47e87a7624a946a">simdpp::mask_int16v2</a> = typedef <a class="el" href="a00028.html">mask_int16</a>&lt;SIMDPP_FAST_INT16_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31112136cdc7f9f5fbd568fee66fa850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a31112136cdc7f9f5fbd568fee66fa850">simdpp::mask_int16v4</a> = typedef <a class="el" href="a00028.html">mask_int16</a>&lt;SIMDPP_FAST_INT16_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c93f6b1edd3291a9f12fc6426f0f18b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a0c93f6b1edd3291a9f12fc6426f0f18b">simdpp::mask_int16x16</a> = typedef <a class="el" href="a00028.html">mask_int16</a>&lt;16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2dcb15d216074f5e91dc6139ec8a2d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a2dcb15d216074f5e91dc6139ec8a2d3b">simdpp::mask_int16x8</a> = typedef <a class="el" href="a00028.html">mask_int16</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d0e9fa85319c0156a7f47af8bb7b332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a9d0e9fa85319c0156a7f47af8bb7b332">simdpp::mask_int32v</a> = typedef <a class="el" href="a00029.html">mask_int32</a>&lt;SIMDPP_FAST_INT32_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f19d048c80311f47be485ccae9854c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a3f19d048c80311f47be485ccae9854c5">simdpp::mask_int32v2</a> = typedef <a class="el" href="a00029.html">mask_int32</a>&lt;SIMDPP_FAST_INT32_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a68d6b9886ed86d1792d7f1c39b7c599c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a68d6b9886ed86d1792d7f1c39b7c599c">simdpp::mask_int32v4</a> = typedef <a class="el" href="a00029.html">mask_int32</a>&lt;SIMDPP_FAST_INT32_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3fc414746dc4bd8956bd8285b8cb4221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a3fc414746dc4bd8956bd8285b8cb4221">simdpp::mask_int32x4</a> = typedef <a class="el" href="a00029.html">mask_int32</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a07afbc5eed207d25d4ab52ae0e5e8d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a07afbc5eed207d25d4ab52ae0e5e8d0f">simdpp::mask_int32x8</a> = typedef <a class="el" href="a00029.html">mask_int32</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d3c5b1ca432d8a5b3fb9074722f514c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a0d3c5b1ca432d8a5b3fb9074722f514c">simdpp::mask_int64v</a> = typedef <a class="el" href="a00030.html">mask_int64</a>&lt;SIMDPP_FAST_INT64_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abdad7b73b52b91867310b79102c22e7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#abdad7b73b52b91867310b79102c22e7d">simdpp::mask_int64v2</a> = typedef <a class="el" href="a00030.html">mask_int64</a>&lt;SIMDPP_FAST_INT64_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a320de5f43b0605c2e39ad5523bcc8795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a320de5f43b0605c2e39ad5523bcc8795">simdpp::mask_int64v4</a> = typedef <a class="el" href="a00030.html">mask_int64</a>&lt;SIMDPP_FAST_INT64_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbe369fb0f0f3a6c93fbedd06ad6c426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#abbe369fb0f0f3a6c93fbedd06ad6c426">simdpp::mask_int64x2</a> = typedef <a class="el" href="a00030.html">mask_int64</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff4fab13b2225dbbb5f5f6ed58995203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#aff4fab13b2225dbbb5f5f6ed58995203">simdpp::mask_int64x4</a> = typedef <a class="el" href="a00030.html">mask_int64</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1ce6192aea042064558f2c756d66520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ad1ce6192aea042064558f2c756d66520">simdpp::mask_int8v</a> = typedef <a class="el" href="a00031.html">mask_int8</a>&lt;SIMDPP_FAST_INT8_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b1243f1cfe0bb3a56bf30db37b80633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a2b1243f1cfe0bb3a56bf30db37b80633">simdpp::mask_int8v2</a> = typedef <a class="el" href="a00031.html">mask_int8</a>&lt;SIMDPP_FAST_INT8_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0085b660f958a0ecbf2d57567d7b0ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a0085b660f958a0ecbf2d57567d7b0ff2">simdpp::mask_int8v4</a> = typedef <a class="el" href="a00031.html">mask_int8</a>&lt;SIMDPP_FAST_INT8_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ed4ceaf3feaf7e671f5c00326214562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a3ed4ceaf3feaf7e671f5c00326214562">simdpp::mask_int8x16</a> = typedef <a class="el" href="a00031.html">mask_int8</a>&lt;16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a374a871711d189080d701faa471f6472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a374a871711d189080d701faa471f6472">simdpp::mask_int8x32</a> = typedef <a class="el" href="a00031.html">mask_int8</a>&lt;32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1141a320bfb7f8e5e12c179342fc4763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a1141a320bfb7f8e5e12c179342fc4763">simdpp::uint16v</a> = typedef <a class="el" href="a00123.html">uint16</a>&lt;SIMDPP_FAST_INT16_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a04f595b7686a2519428f8e8792b10d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a04f595b7686a2519428f8e8792b10d71">simdpp::uint16v2</a> = typedef <a class="el" href="a00123.html">uint16</a>&lt;SIMDPP_FAST_INT16_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e83c21b0f77210dd3a0f31759ec4c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a2e83c21b0f77210dd3a0f31759ec4c67">simdpp::uint16v4</a> = typedef <a class="el" href="a00123.html">uint16</a>&lt;SIMDPP_FAST_INT16_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f51af32fa2f6caf3538118beb1beeb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">simdpp::uint16x16</a> = typedef <a class="el" href="a00123.html">uint16</a>&lt;16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12a21291847f6b893d9b965695fdb939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">simdpp::uint16x8</a> = typedef <a class="el" href="a00123.html">uint16</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43d1ba44382f8277c8235ce6078b5f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a43d1ba44382f8277c8235ce6078b5f35">simdpp::uint32v</a> = typedef <a class="el" href="a00127.html">uint32</a>&lt;SIMDPP_FAST_INT32_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a819225bbc006f5f405182e6932d6f38c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a819225bbc006f5f405182e6932d6f38c">simdpp::uint32v2</a> = typedef <a class="el" href="a00127.html">uint32</a>&lt;SIMDPP_FAST_INT32_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af25b44826cfc85f09fdd955d530a44aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#af25b44826cfc85f09fdd955d530a44aa">simdpp::uint32v4</a> = typedef <a class="el" href="a00127.html">uint32</a>&lt;SIMDPP_FAST_INT32_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac20dd929c7688955c0420f9ad159df0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ac20dd929c7688955c0420f9ad159df0a">simdpp::uint32x4</a> = typedef <a class="el" href="a00127.html">uint32</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19715f058184b65e0250d37e82d7204d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a19715f058184b65e0250d37e82d7204d">simdpp::uint32x8</a> = typedef <a class="el" href="a00127.html">uint32</a>&lt;8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e8acafb8d0431e8620d8bf19c093be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a1e8acafb8d0431e8620d8bf19c093be2">simdpp::uint64v</a> = typedef <a class="el" href="a00131.html">uint64</a>&lt;SIMDPP_FAST_INT64_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e7bccb6051a3548a7ff956c34c3b05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a3e7bccb6051a3548a7ff956c34c3b05b">simdpp::uint64v2</a> = typedef <a class="el" href="a00131.html">uint64</a>&lt;SIMDPP_FAST_INT64_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3e5db862943b8d6c9e8a0ada4b11af9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ab3e5db862943b8d6c9e8a0ada4b11af9">simdpp::uint64v4</a> = typedef <a class="el" href="a00131.html">uint64</a>&lt;SIMDPP_FAST_INT64_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a88fa6bce9edc39f1e33381101cb60296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a88fa6bce9edc39f1e33381101cb60296">simdpp::uint64x2</a> = typedef <a class="el" href="a00131.html">uint64</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6695b8dbe92c54e1fc4844174b4623ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">simdpp::uint64x4</a> = typedef <a class="el" href="a00131.html">uint64</a>&lt;4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a68be0fb2aa42c9b52d37cc53373f7fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a68be0fb2aa42c9b52d37cc53373f7fac">simdpp::uint8v</a> = typedef <a class="el" href="a00135.html">uint8</a>&lt;SIMDPP_FAST_INT8_SIZE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1fc3277aec19119b9fb01063e809f7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ad1fc3277aec19119b9fb01063e809f7b">simdpp::uint8v2</a> = typedef <a class="el" href="a00135.html">uint8</a>&lt;SIMDPP_FAST_INT8_SIZE*2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40fb5ce979e25831856d8bf576760224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a40fb5ce979e25831856d8bf576760224">simdpp::uint8v4</a> = typedef <a class="el" href="a00135.html">uint8</a>&lt;SIMDPP_FAST_INT8_SIZE*4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f89eaaf7f8fcd3a69ed31e17a1846d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">simdpp::uint8x16</a> = typedef <a class="el" href="a00135.html">uint8</a>&lt;16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7cc2e646e03b2e3f7b97394d1863140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00156.html#ad7cc2e646e03b2e3f7b97394d1863140">simdpp::uint8x32</a> = typedef <a class="el" href="a00135.html">uint8</a>&lt;32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a501311c3a1979838d8253a74d92c2a0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00034.html">expr_abs</a>&lt;<a class="el" href="a00025.html">int8</a>&lt;N,E&gt; &gt; &gt; simdpp::abs </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes absolute value of 8-bit integer values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-4 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a41d9986b34dbc68becf9758add0d35a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00034.html">expr_abs</a>&lt;<a class="el" href="a00020.html">float32</a>&lt;N,E&gt; &gt; &gt; simdpp::abs </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes absolute value of floating point values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a361f99bb30f53ca402f9fd966587f4d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00034.html">expr_abs</a>&lt;<a class="el" href="a00022.html">int16</a>&lt;N,E&gt; &gt; &gt; simdpp::abs </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes absolute value of 16-bit integer values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(aN)</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a15992441248b52212c33f893ba8bc7bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00034.html">expr_abs</a>&lt;<a class="el" href="a00021.html">float64</a>&lt;N,E&gt; &gt; &gt; simdpp::abs </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes absolute value of floating point values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-AVX2 this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1-2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a727525242b4c33c21b24eb0ade861f22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00034.html">expr_abs</a>&lt;<a class="el" href="a00023.html">int32</a>&lt;N,E&gt; &gt; &gt; simdpp::abs </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes absolute value of 32-bit integer values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(aN)</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-4 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6bf1e6f9fe1ce165bf96111211919623"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N, <a class="el" href="a00034.html">expr_abs</a>&lt;<a class="el" href="a00024.html">int64</a>&lt;N,E&gt; &gt; &gt; simdpp::abs </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes absolute value of 64-bit integer values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a41d9986b34dbc68becf9758add0d35a2" title="Computes absolute value of floating point values. ">abs</a>(aN)</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 5 instructions. </li>
<li>In NEON this intrinsic results in at least 6 instructions. </li>
<li>Not vectorized in ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 10 instructions. </li>
<li>In NEON this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4 instructions. </li>
<li>Not vectorized in ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a41841a925565233350d53362752a34c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00035.html">expr_add</a>&lt;<a class="el" href="a00020.html">float32</a>&lt;N,E1&gt;, <a class="el" href="a00020.html">float32</a>&lt;N,E2&gt; &gt; &gt; simdpp::add </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 + b0</div>
<div class="line">...</div>
<div class="line">rN = aN + bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a24e3115c5acdf0a1a5dc5b0c5ecc2131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00035.html">expr_add</a>&lt;<a class="el" href="a00135.html">uint8</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00135.html">uint8</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::add </td>
          <td>(</td>
          <td class="paramtype">const any_int8&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int8&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds 8-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 + b0</div>
<div class="line">...</div>
<div class="line">rN = aN + bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a25090f42331539d545277c754747e472"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00035.html">expr_add</a>&lt;<a class="el" href="a00021.html">float64</a>&lt;N,E1&gt;, <a class="el" href="a00021.html">float64</a>&lt;N,E2&gt; &gt; &gt; simdpp::add </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 + b0</div>
<div class="line">...</div>
<div class="line">rN = aN + bN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a41df05d747fdd4ebe0e2ce8667eb4014"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00035.html">expr_add</a>&lt;<a class="el" href="a00123.html">uint16</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00123.html">uint16</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::add </td>
          <td>(</td>
          <td class="paramtype">const any_int16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds 16-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 + b0</div>
<div class="line">...</div>
<div class="line">rN = aN + bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1d55bf201f41ad2a9cf7203578f22538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00035.html">expr_add</a>&lt;<a class="el" href="a00127.html">uint32</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00127.html">uint32</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::add </td>
          <td>(</td>
          <td class="paramtype">const any_int32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds 32-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 + b0</div>
<div class="line">...</div>
<div class="line">rN = aN + bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3f1a0be1b9746648028eaa35ee624345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00035.html">expr_add</a>&lt;<a class="el" href="a00131.html">uint64</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00131.html">uint64</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::add </td>
          <td>(</td>
          <td class="paramtype">const any_int64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds 64-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 + b0</div>
<div class="line">...</div>
<div class="line">rN = aN + bN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 5-6 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 10-11 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad8338a491d46a2258657f9b412d8bd5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00036.html">expr_add_sat</a>&lt;<a class="el" href="a00025.html">int8</a>&lt;N,E1&gt;, <a class="el" href="a00025.html">int8</a>&lt;N,E2&gt; &gt; &gt; simdpp::add_sat </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds and saturates signed 8-bit integer values. </p>
<div class="fragment"><div class="line">r0 = signed_saturate(a0 + b0)</div>
<div class="line">...</div>
<div class="line">rN = signed_saturate(aN + bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a83d5d493566064116841cac49ba8dc4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00036.html">expr_add_sat</a>&lt;<a class="el" href="a00022.html">int16</a>&lt;N,E1&gt;, <a class="el" href="a00022.html">int16</a>&lt;N,E2&gt; &gt; &gt; simdpp::add_sat </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds and saturates signed 16-bit integer values. </p>
<div class="fragment"><div class="line">r0 = signed_saturate(a0 + b0)</div>
<div class="line">...</div>
<div class="line">rN = signed_saturate(aN + bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6c2436051cb2206ac077aa4c5ab96752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00036.html">expr_add_sat</a>&lt;<a class="el" href="a00135.html">uint8</a>&lt;N,E1&gt;, <a class="el" href="a00135.html">uint8</a>&lt;N,E2&gt; &gt; &gt; simdpp::add_sat </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds and saturates unsigned 8-bit integer values. </p>
<div class="fragment"><div class="line">r0 = unsigned_saturate(a0 + b0)</div>
<div class="line">...</div>
<div class="line">rN = unsigned_saturate(aN + bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5faa602ab50b10d40b5b52092c800e75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00036.html">expr_add_sat</a>&lt;<a class="el" href="a00123.html">uint16</a>&lt;N,E1&gt;, <a class="el" href="a00123.html">uint16</a>&lt;N,E2&gt; &gt; &gt; simdpp::add_sat </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds and saturates unsigned 16-bit integer values. </p>
<div class="fragment"><div class="line">r0 = unsigned_saturate(a0 + b0)</div>
<div class="line">...</div>
<div class="line">rN = unsigned_saturate(aN + bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac101484a86a30cd5ffed52d6e0072b2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::align16 </td>
          <td>(</td>
          <td class="paramtype">const any_vec8&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec8&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a int8x16 vector from two concatenated int8x16 vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ l0  l1   .  l14 l15 ]</div>
<div class="line"> 1      r = [ l1  l2   .  l15 u0  ]</div>
<div class="line"> 2      r = [ l2  l3   .  u0  l1  ]</div>
<div class="line">  ...    ..   .. ..  ... .. ..</div>
<div class="line"> 15     r = [ l15 u0   .  u13 u14 ]</div>
<div class="line"> 16     r = [ u0  u1   .  u14 u15 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2a446eb3a7437a1c6826443d57b157de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::align2 </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a int64x2 vector from two concatenated int64x2 vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ l0 l1 ]</div>
<div class="line"> 1      r = [ l1 u0 ]</div>
<div class="line"> 2      r = [ u0 u1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>int64</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
<dl class="section user"><dt>float64</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-SSE4.1 NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad6a47f9bf99ad41a3ffb7c6f65d17273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::align4 </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a int32x4 vector from two concatenated int32x4 vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ l0 l1 l2 l3 ]</div>
<div class="line"> 1      r = [ l1 l2 l3 u0 ]</div>
<div class="line"> 2      r = [ l2 l3 u0 u1 ]</div>
<div class="line"> 3      r = [ l3 u0 u1 u2 ]</div>
<div class="line"> 4      r = [ u0 u1 u2 u3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>int32</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
<dl class="section user"><dt>float32</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-SSE4.1 NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7d43daa93ab922a0c862d72bc04d950c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::align8 </td>
          <td>(</td>
          <td class="paramtype">const any_vec16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a int16x8 vector from two concatenated int16x8 vectors. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1    .  6  7  |</div>
<div class="line"> 0      r = [ l0 l1   .  l6 l7 ]</div>
<div class="line"> 1      r = [ l1 l2   .  l7 u0 ]</div>
<div class="line"> 2      r = [ l2 l3   .  u0 l1 ]</div>
<div class="line">  ...    ..   .. ..  ... .. ..</div>
<div class="line"> 7      r = [ l3 u0   .  u5 u6 ]</div>
<div class="line"> 8      r = [ u0 u1   .  u6 u7 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
The all 128-bit sub-vectors are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="a927476604c6376171af163fb63f4d431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00135.html">uint8</a>&lt;N&gt; &gt; simdpp::avg </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes rounded average of the unsigned 8-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0 + 1) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN + 1) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a55ab590d418e1b2da8b4859f16fad10b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00025.html">int8</a>&lt;N&gt; &gt; simdpp::avg </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes rounded average of signed 8-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0 + 1) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN + 1) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8-9 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adf69200e18bf0efde43d673b53aa68f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00123.html">uint16</a>&lt;N&gt; &gt; simdpp::avg </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes rounded average of unsigned 16-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0 + 1) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN + 1) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a928f2f40587aee9860fb2b2f9a2af322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00022.html">int16</a>&lt;N&gt; &gt; simdpp::avg </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes rounded average of signed 16-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0 + 1) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN + 1) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8-9 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7755045244614af942343cd5cb87697b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00127.html">uint32</a>&lt;N&gt; &gt; simdpp::avg </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes rounded average of unsigned 32-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0 + 1) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN + 1) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 6-7 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 12-13 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6-7 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3a731a765a019f13408829326c72990b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00023.html">int32</a>&lt;N&gt; &gt; simdpp::avg </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes rounded average of signed 32-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0 + 1) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN + 1) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 9-10 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 18-19 instructions. </li>
<li>In AVX2 this intrinsic results in at least 9-10 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad34e1af18c1513f406b8acb05e82ccbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00135.html">uint8</a>&lt;N&gt; &gt; simdpp::avg_trunc </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes truncated average of the unsigned 8-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4ac5518b77e7d14eedec9b628d9f9940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00025.html">int8</a>&lt;N&gt; &gt; simdpp::avg_trunc </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes truncated average of signed 8-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 7-8 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 14-15 instructions. </li>
<li>In AVX2 this intrinsic results in at least 7-8 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad116f56fdf371c7939dc3408a582be85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00123.html">uint16</a>&lt;N&gt; &gt; simdpp::avg_trunc </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes truncated average of unsigned 16-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9d028214036fd5bebad3a82517fe0bdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00022.html">int16</a>&lt;N&gt; &gt; simdpp::avg_trunc </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes truncated average of signed 16-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 7-8 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 14-15 instructions. </li>
<li>In AVX2 this intrinsic results in at least 7-8 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5474b56675e4fd7c1f0601972bc40e24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00127.html">uint32</a>&lt;N&gt; &gt; simdpp::avg_trunc </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes truncated average of unsigned 32-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In NEON this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2ed7ef03e2b5793ffab2f69d96ed9312"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00023.html">int32</a>&lt;N&gt; &gt; simdpp::avg_trunc </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes truncated average of signed 32-bit values. </p>
<div class="fragment"><div class="line">r0 = (a0 + b0) / 2</div>
<div class="line">...</div>
<div class="line">rN = (aN + bN) / 2</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 7-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 14-15 instructions. </li>
<li>In AVX2 this intrinsic results in at least 7-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 8 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af5a6527022ce4932db59e1a87f7821ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_bitwise2_and&lt;<a class="el" href="a00037.html">expr_bit_and</a>, V1, V2&gt;::type simdpp::bit_and </td>
          <td>(</td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes bitwise AND of integer or floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; bN</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="a00422.html#_todo000001">Todo:</a></b></dt><dd>: icost </dd></dl>

</div>
</div>
<a class="anchor" id="a1016baf256694f76d82b3072f78cccef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_bitwise2_and&lt;<a class="el" href="a00038.html">expr_bit_andnot</a>, V1, V2&gt;::type simdpp::bit_andnot </td>
          <td>(</td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes bitwise AND NOT of two integer or floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; ~b0</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; ~bN</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="a00422.html#_todo000002">Todo:</a></b></dt><dd>: icost </dd></dl>

</div>
</div>
<a class="anchor" id="a148f57260a9ff1588cf574adfa8e38be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R simdpp::bit_cast </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts between unrelated types. </p>
<p>No changes to the stored values are performed.</p>
<p>Conversions between vector and non-vector types are not allowed.</p>
<p>Conversion from non-mask type to mask type is not allowed.</p>
<p>Conversion from mask type to a non-mask type is not a costless operation because masks may have different logical and physical layout (e.g., in some implementations one bit represents entire element in a vector).</p>
<p>Conversions between mask types is only allowed if the element size is the same. </p>

</div>
</div>
<a class="anchor" id="af3de71e1769b7a7cb55190c310eea586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr&lt;V, <a class="el" href="a00039.html">expr_bit_not</a>&lt;V&gt; &gt;::empty simdpp::bit_not </td>
          <td>(</td>
          <td class="paramtype">const any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes bitwise NOT of an integer or floating-point vector. </p>
<div class="fragment"><div class="line">r = ~a</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="a00422.html#_todo000003">Todo:</a></b></dt><dd>icost </dd></dl>

</div>
</div>
<a class="anchor" id="acfd16fff7c5da4de8cce786a2be51ec4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_bit_or&lt;V1, V2&gt;::type simdpp::bit_or </td>
          <td>(</td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes bitwise OR of integer vectors. </p>
<div class="fragment"><div class="line">r0 = a0 | b0</div>
<div class="line">...</div>
<div class="line">rN = aN | bN</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="a00422.html#_todo000004">Todo:</a></b></dt><dd>icost </dd></dl>

</div>
</div>
<a class="anchor" id="afb44bd8cadf25b2dd23d91a30aae5bd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2&lt;V1, V2, void&gt;::empty simdpp::bit_xor </td>
          <td>(</td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes bitwise XOR of integer or floating-point vectors. </p>
<div class="fragment"><div class="line">r0 = a0 ^ b0</div>
<div class="line">...</div>
<div class="line">rN = aN ^ bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a085ed17ba35931a9944ea035f1c38a51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 , class V3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_blend&lt;V1, V2, V3&gt;::type simdpp::blend </td>
          <td>(</td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes a vector from two sources according to a mask. </p>
<p>Each element within the mask must have either all bits set or all bits unset.</p>
<div class="fragment"><div class="line">r0 = (mask0 == 0xff ) ? on0 : off0</div>
<div class="line">...</div>
<div class="line">rN = (maskN == 0xff ) ? onN : offN</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="a00422.html#_todo000005">Todo:</a></b></dt><dd>icost</dd></dl>
<dl class="section user"><dt>int16</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>int32</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>int64</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>float32</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>float64</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aafc2460cf6237f33f17372acac09f51e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::ceil </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds the values a vector towards positive infinity. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#aafc2460cf6237f33f17372acac09f51e" title="Rounds the values a vector towards positive infinity. ">ceil</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#aafc2460cf6237f33f17372acac09f51e" title="Rounds the values a vector towards positive infinity. ">ceil</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 13-15 instructions. </li>
<li>In NEON this intrinsic results in at least 11-13 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 26-28 instructions. </li>
<li>In NEON this intrinsic results in at least 22-24 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8227ff67e3d1c3bde0818e7583ec7391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">mask_int8</a>&lt;N, <a class="el" href="a00031.html">mask_int8</a>&lt;N&gt; &gt; simdpp::cmp_eq </td>
          <td>(</td>
          <td class="paramtype">const any_int8&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int8&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares 8-bit values for equality. </p>
<div class="fragment"><div class="line">r0 = (a0 == b0) ? 0xff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN == bN) ? 0xff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac27e9979e0e71e9c082ec7f305417b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00028.html">mask_int16</a>&lt;N, <a class="el" href="a00028.html">mask_int16</a>&lt;N&gt; &gt; simdpp::cmp_eq </td>
          <td>(</td>
          <td class="paramtype">const any_int16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares 16-bit values for equality. </p>
<div class="fragment"><div class="line">r0 = (a0 == b0) ? 0xffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN == bN) ? 0xffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9224d4af1aa9f4765a4089e60416b0c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00029.html">mask_int32</a>&lt;N, <a class="el" href="a00029.html">mask_int32</a>&lt;N&gt; &gt; simdpp::cmp_eq </td>
          <td>(</td>
          <td class="paramtype">const any_int32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two int32x4 vectors for equality. </p>
<div class="fragment"><div class="line">r0 = (a0 == b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN == bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5b0dec4d9b83a104898edfa87f974271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">mask_int64</a>&lt;N, <a class="el" href="a00030.html">mask_int64</a>&lt;N&gt; &gt; simdpp::cmp_eq </td>
          <td>(</td>
          <td class="paramtype">const any_int64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two int64x2 vectors for equality. </p>
<div class="fragment"><div class="line">r0 = (a0 == b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN == bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 5 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 3-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 and AVX this intrinsic results in at least 10 instructions. </li>
<li>In XOP and SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 6 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 6-7 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a34e67cb83257b34f02e9ab3fdd58651b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::cmp_eq </td>
          <td>(</td>
          <td class="paramtype">const any_float32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_float32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float32x4 vectors for equality. </p>
<div class="fragment"><div class="line">r0 = (a0 == b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN == bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad270ec959a78609539d55b272a066e28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::cmp_eq </td>
          <td>(</td>
          <td class="paramtype">const any_float64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_float64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float64x2 vectors for equality. </p>
<div class="fragment"><div class="line">r0 = (a0 == b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN == bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a19eba8f61d67c53d5e7e780ad78b90a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::cmp_ge </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float32x4 vectors for greater-than or equal. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt;= b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt;= bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9cfa48fca71e706030682df171264e49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::cmp_ge </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float64x2 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt;= b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt;= bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac76a41b250183c6fa347cce18308fa58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">mask_int8</a>&lt;N, <a class="el" href="a00031.html">mask_int8</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two signed int16x8 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9e2cfd381578cd1bde6ba07dfae376cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">mask_int8</a>&lt;N, <a class="el" href="a00031.html">mask_int8</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two unsigned int16x8 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-7 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a27ebc182233c5115c22953496fbb0e99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00028.html">mask_int16</a>&lt;N, <a class="el" href="a00028.html">mask_int16</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two signed int16x8 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a938d19cb0bd2dbaeae57a91a76e79845"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00028.html">mask_int16</a>&lt;N, <a class="el" href="a00028.html">mask_int16</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two unsigned int16x8 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-7 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a752a838918ba7e87a3a98b348d0edead"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00029.html">mask_int32</a>&lt;N, <a class="el" href="a00029.html">mask_int32</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two signed int32x4 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a134fbc50643558a9e15391156671ef3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00029.html">mask_int32</a>&lt;N, <a class="el" href="a00029.html">mask_int32</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two unsigned int32x4 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-7 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad14e60d5cd592795e4c42b2a401468b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float32x4 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a42af1ab59dcfcc50e3c3ed5724f53394"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::cmp_gt </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float64x2 vectors for greater-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &gt; b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &gt; bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a593c9b03a4b46c8956d027131e74e0cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::cmp_le </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float32x4 vectors for less-than or equal. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt;= b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt;= bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1ba7095331a10a009b764e4863a701d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::cmp_le </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float64x2 vectors for less-than or equal. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt;= b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt;= bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9498cc8ba92adb2f994b0eaba4c5b1b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">mask_int8</a>&lt;N, <a class="el" href="a00031.html">mask_int8</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two signed int8x16 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ace1dbb083b65d56e2073f0f9ff9c3f98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">mask_int8</a>&lt;N, <a class="el" href="a00031.html">mask_int8</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two unsigned int8x16 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-7 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab3525668b4f735a062ddcacd69a33f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00028.html">mask_int16</a>&lt;N, <a class="el" href="a00028.html">mask_int16</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two signed int16x8 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a298e8a9c480893a98d99e4a3209c78f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00028.html">mask_int16</a>&lt;N, <a class="el" href="a00028.html">mask_int16</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two unsigned int16x8 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-7 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a422ed02dbb827cd50b280066e2bdb5c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00029.html">mask_int32</a>&lt;N, <a class="el" href="a00029.html">mask_int32</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two signed int32x4 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af718f6b905432161df1c9a562e20c9e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00029.html">mask_int32</a>&lt;N, <a class="el" href="a00029.html">mask_int32</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two unsigned int32x4 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6-7 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In XOP, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ada9bfb844c4937b6a3596d0389ce8c33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float32x4 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aacc8ada68555518402452c364b0e566a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::cmp_lt </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float64x2 vectors for less-than. </p>
<div class="fragment"><div class="line">r0 = (a0 &lt; b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN &lt; bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a52c4699da18a3863d07b0a61f90900d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">mask_int8</a>&lt;N, <a class="el" href="a00031.html">mask_int8</a>&lt;N&gt; &gt; simdpp::cmp_neq </td>
          <td>(</td>
          <td class="paramtype">const any_int8&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int8&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two int8x16 vectors for inequality. </p>
<div class="fragment"><div class="line">r0 = (a0 != b0) ? 0xff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN != bN) ? 0xff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa4b3924c9f05016fbb931995b9c1786a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00028.html">mask_int16</a>&lt;N, <a class="el" href="a00028.html">mask_int16</a>&lt;N&gt; &gt; simdpp::cmp_neq </td>
          <td>(</td>
          <td class="paramtype">const any_int16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two int16x8 vectors for inequality. </p>
<div class="fragment"><div class="line">r0 = (a0 != b0) ? 0xffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN != bN) ? 0xffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a266ec768c16b373414ff96f3d983dad5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00029.html">mask_int32</a>&lt;N, <a class="el" href="a00029.html">mask_int32</a>&lt;N&gt; &gt; simdpp::cmp_neq </td>
          <td>(</td>
          <td class="paramtype">const any_int32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two int32x4 vectors for inequality. </p>
<div class="fragment"><div class="line">r0 = (a0 != b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN != bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad04156653405d32f8f6d598bb0040498"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">mask_int64</a>&lt;N, <a class="el" href="a00030.html">mask_int64</a>&lt;N&gt; &gt; simdpp::cmp_neq </td>
          <td>(</td>
          <td class="paramtype">const any_int64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two int64x2 vectors for inequality. </p>
<div class="fragment"><div class="line">r0 = (a0 != b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN != bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 5 instructions. </li>
<li>In SSE4.1 and AVX this intrinsic results in at least 2 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 3-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 and AVX this intrinsic results in at least 10 instructions. </li>
<li>In SSE4.1 and NEON this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 and XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 6-8 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad8c4dd9026f0e88772dcc07e19aa7227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::cmp_neq </td>
          <td>(</td>
          <td class="paramtype">const any_float32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_float32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float32x4 vectors for inequality. </p>
<div class="fragment"><div class="line">r0 = (a0 != b0) ? 0xffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN != bN) ? 0xffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 4 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8e524875159826db31506ec6d90747fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::cmp_neq </td>
          <td>(</td>
          <td class="paramtype">const any_float64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_float64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two float64x2 vectors for inequality. </p>
<div class="fragment"><div class="line">r0 = (a0 != b0) ? 0xffffffffffffffff : 0x0</div>
<div class="line">...</div>
<div class="line">rN = (aN != bN) ? 0xffffffffffffffff : 0x0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7d79efa77ce2122851dfaf19f4042ec3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::div </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 / b0</div>
<div class="line">...</div>
<div class="line">rN = aN / bN</div>
</div><!-- fragment --><ul>
<li>In NEON this intrinsic results in at least 6 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 10 instructions.</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 12 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 19 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afefa6a78bbd66dfa881e6c6f6c5f9a5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00021.html">float64</a>&lt;N&gt; &gt; simdpp::div </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 / b0</div>
<div class="line">...</div>
<div class="line">rN = aN / bN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab3fb2286904bc79944007a8301456894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> simdpp::div_p </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides one 8-bit unsigned number by another. </p>
<p>The precision of the operation is configurable: only P least significant bits of both numerator and denumerator are considered.</p>
<div class="fragment"><div class="line">r0 = num0 / den0</div>
<div class="line">...</div>
<div class="line">rN = numN / denN</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd>The operations costs at least 9 instructions per bit of precision.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 10 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab6ef9ad936d4ac88020496b19952930d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a12a21291847f6b893d9b965695fdb939">uint16x8</a> simdpp::div_p </td>
          <td>(</td>
          <td class="paramtype">uint16x8&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides one 8-bit unsigned number by another. </p>
<p>The precision of the operation is configurable: only P least significant bits of both numerator and denumerator are considered.</p>
<div class="fragment"><div class="line">r0 = num0 / den0</div>
<div class="line">...</div>
<div class="line">rN = numN / denN</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd>The operations costs at least 9 instructions per bit of precision.</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 10 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a904d3dd1e71c4ae9daf44d0a73fe3796"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">uint16x8&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <em>id-th</em> element from int16x8 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1a4e3ace1e253a42b74dc10c453d885e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int16_t simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">int16x8&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <em>id-th</em> element from int16x8 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab2e29f844da34ec7b359e960ae192220"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">uint32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <em>id-th</em> element from int32x4 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a373f7225a8274a1905b3e48acec813a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">int32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the <em>id-th</em> element from int32x4 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7ad1a019b5a959f79084e00fe630c385"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">uint64x2&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts an element from int64x2 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 1-2 instructions. </li>
<li>In SSE4_1 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2_32bit, SSE3_32bit and SSSE3_32bit this intrinsic results in at least 3-4 instructions. </li>
<li>In SSE4_1_32bit this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab959a0a29466b383029b93a3ec432318"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">int64x2&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts an element from int64x2 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 1-2 instructions. </li>
<li>In SSE4_1 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2_32bit, SSE3_32bit and SSSE3_32bit this intrinsic results in at least 3-4 instructions. </li>
<li>In SSE4_1_32bit this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad28e8cfc78e167b5e0342634767ad6f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts an element from float32x4 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a97264bf14196dca72e4439fca3bbe12f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double simdpp::extract </td>
          <td>(</td>
          <td class="paramtype">float64x2&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts an element from float64x2 vector. </p>
<div class="fragment"><div class="line">r = a[id]</div>
</div><!-- fragment --><p>This function may have very high latency.</p>
<ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5cdb081735e8de53da5a3f713d9d72dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t simdpp::extract_bits </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts specific bit from each byte of each element of a int8x16 vector. </p>
<p>The default template argument selects the bits from each byte in most efficient way.</p>
<div class="fragment"><div class="line">r = (a[0] &amp; 0x80 &gt;&gt; 7) | (a[1] &amp; 0x80 &gt;&gt; 6) | ...  | (a[15] &amp; 0x80 &lt;&lt; 8)</div>
</div><!-- fragment --><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 7-9 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 9-11 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3ad6a75f035db9c8d631af13ce3e17c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t simdpp::extract_bits_any </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a bit from each byte of each element of a int8x16 vector. </p>
<p>This operation is only sensible if each byte within the vector is either 0x00 or 0xff.</p>
<div class="fragment"><div class="line">r = ((a[0] &amp; 0x??) ? 0x01 : 0) |</div>
<div class="line">    ((a[1] &amp; 0x??) ? 0x02 : 0) |</div>
<div class="line">    ...</div>
<div class="line">    ((a[15] &amp; 0x??) ? 0x80 : 0)</div>
</div><!-- fragment --><ul>
<li>In NEON this intrinsic results in at least 6-7 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 8-9 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac1e6f8d875b59375b2a198c4e4652f65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::floor </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds the values of a vector towards negative infinity. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#ac1e6f8d875b59375b2a198c4e4652f65" title="Rounds the values of a vector towards negative infinity. ">floor</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#ac1e6f8d875b59375b2a198c4e4652f65" title="Rounds the values of a vector towards negative infinity. ">floor</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 12-14 instructions. </li>
<li>In NEON this intrinsic results in at least 10-11 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 24-26 instructions. </li>
<li>In NEON this intrinsic results in at least 20-21 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a73df1051681544e8a4257adf3523ee6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00043.html">expr_fmadd</a>&lt;<a class="el" href="a00020.html">float32</a>&lt;N,E1&gt;, <a class="el" href="a00020.html">float32</a>&lt;N,E2&gt;, <a class="el" href="a00020.html">float32</a>&lt;N,E3&gt; &gt; &gt; simdpp::fmadd </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E3 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a fused multiply-add operation. </p>
<div class="fragment"><div class="line">r0 = a0 * b0 + c0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN + cN</div>
</div><!-- fragment --><p>Implemented only on architectures with either <code>X86_FMA3</code> or <code>X86_FMA4</code> support. </p>

</div>
</div>
<a class="anchor" id="a577c72f1936ddf69973a949a639d2ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00043.html">expr_fmadd</a>&lt;<a class="el" href="a00021.html">float64</a>&lt;N,E1&gt;, <a class="el" href="a00021.html">float64</a>&lt;N,E2&gt;, <a class="el" href="a00021.html">float64</a>&lt;N,E3&gt; &gt; &gt; simdpp::fmadd </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E3 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a fused multiply-add operation. </p>
<div class="fragment"><div class="line">r0 = a0 * b0 + c0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN + cN</div>
</div><!-- fragment --><p>Implemented only on architectures with either <code>X86_FMA3</code> or <code>X86_FMA4</code> support. </p>

</div>
</div>
<a class="anchor" id="ab2bb428c0878ad59f32a991db4940523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00044.html">expr_fmsub</a>&lt;<a class="el" href="a00020.html">float32</a>&lt;N,E1&gt;, <a class="el" href="a00020.html">float32</a>&lt;N,E2&gt;, <a class="el" href="a00020.html">float32</a>&lt;N,E3&gt; &gt; &gt; simdpp::fmsub </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E3 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a fused multiply-sutract operation. </p>
<div class="fragment"><div class="line">r0 = a0 * b0 - c0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN - cN</div>
</div><!-- fragment --><p>Implemented only on architectures with either <code>X86_FMA3</code> or <code>X86_FMA4</code> support. </p>

</div>
</div>
<a class="anchor" id="ad05d4b470991c5fb85ae675587850230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 , class E3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00044.html">expr_fmsub</a>&lt;<a class="el" href="a00021.html">float64</a>&lt;N,E1&gt;, <a class="el" href="a00021.html">float64</a>&lt;N,E2&gt;, <a class="el" href="a00021.html">float64</a>&lt;N,E3&gt; &gt; &gt; simdpp::fmsub </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E3 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a fused multiply-sutract operation. </p>
<div class="fragment"><div class="line">r0 = a0 * b0 - c0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN - cN</div>
</div><!-- fragment --><p>Implemented only on architectures with either <code>X86_FMA3</code> or <code>X86_FMA4</code> support. </p>

</div>
</div>
<a class="anchor" id="a8b3cea09a5284378a9e3a78a69fc9ac0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> simdpp::get_arch_gcc_builtin_cpu_supports </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves supported architecture using GCC __builtin_cpu_supports function. </p>
<p>Works only on x86. </p>

</div>
</div>
<a class="anchor" id="a70b6262cf9b117f1fbfb9ca516ce4212"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00420.html#ga5335c7b7726de1a63a10b2975ad430b4">Arch</a> simdpp::get_arch_linux_cpuinfo </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves supported architecture from Linux /proc/cpuinfo file. </p>
<p>Works on X86 and ARM. </p>

</div>
</div>
<a class="anchor" id="ac1fea06d72d5938df37cc4b5a1bd8994"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::isnan </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether elements in <em>a</em> are IEEE754 NaN. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(a0) ? 0xffffffff : 0</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(aN) ? 0xffffffff : 0</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5db1158dfd39324487fffb381dc2fd3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::isnan </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether elements in <em>a</em> are IEEE754 NaN. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(a0) ? 0xffffffffffffffff : 0</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(aN) ? 0xffffffffffffffff : 0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adcfc55930679fb559b7ca93019b64a29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">mask_float32</a>&lt;N, <a class="el" href="a00026.html">mask_float32</a>&lt;N&gt; &gt; simdpp::isnan2 </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether corresponding elements in either <em>a</em> or <em>b</em> are IEEE754 NaN. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(a0) || <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(b0) ? 0xffffffff : 0</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(aN) || <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(bN) ? 0xffffffff : 0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 6 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5dd7f80eb0e6c9520031d587a00ecd7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">mask_float64</a>&lt;N, <a class="el" href="a00027.html">mask_float64</a>&lt;N&gt; &gt; simdpp::isnan2 </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether corresponding elements in either <em>a</em> or <em>b</em> are IEEE754 NaN. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(a0) || <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(b0) ? 0xffffffffffffffff : 0</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(aN) || <a class="code" href="a00156.html#ac1fea06d72d5938df37cc4b5a1bd8994" title="Checks whether elements in a are IEEE754 NaN. ">isnan</a>(bN) ? 0xffffffffffffffff : 0</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a17909e0c29acc56a595ee0aeeec84c89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_load&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::load </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an aligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes.</p>
<ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a6b2f9c00491ea9b9cd505fd210aba587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed2 </td>
          <td>(</td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads values packed in pairs, de-interleaves them and stores the result into two vectors. </p>
<div class="fragment"><div class="line">a = [ *(p),   *(p+2), *(p+4), ... , *(p+M*2-2) ]</div>
<div class="line">b = [ *(p+1), *(p+3), *(p+5), ... , *(p+M*2-1) ]</div>
</div><!-- fragment --><p>Here M is the number of elements in the vector</p>
<p><em>p</em> must be aligned to the vector size in bytes </p>

</div>
</div>
<a class="anchor" id="a7a3ea7d47c0cc2d7a0ba7014a54f52ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed3 </td>
          <td>(</td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads values packed in triplets, de-interleaves them and stores the result into three vectors. </p>
<div class="fragment"><div class="line">a = [ *(p),   *(p+3), *(p+6), ... , *(p+M*3-3) ]</div>
<div class="line">b = [ *(p+1), *(p+4), *(p+7), ... , *(p+M*3-2) ]</div>
<div class="line">c = [ *(p+2), *(p+5), *(p+8), ... , *(p+M*3-1) ]</div>
</div><!-- fragment --><p>Here M is the number of elements in the vector</p>
<p><em>p</em> must be aligned to the vector size in bytes </p>

</div>
</div>
<a class="anchor" id="ab028abe337e2a34dbafcf356e5133ad2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::load_packed4 </td>
          <td>(</td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads values packed in quartets, de-interleaves them and stores the result into four vectors. </p>
<div class="fragment"><div class="line">a = [ *(p),   *(p+4), *(p+8),  ... , *(p+M*4-4) ]</div>
<div class="line">b = [ *(p+1), *(p+5), *(p+9),  ... , *(p+M*4-3) ]</div>
<div class="line">c = [ *(p+2), *(p+6), *(p+10), ... , *(p+M*4-2) ]</div>
<div class="line">d = [ *(p+3), *(p+7), *(p+11), ... , *(p+M*4-1) ]</div>
</div><!-- fragment --><p>Here M is the number of elements in the vector</p>
<p><em>p</em> must be aligned to the vector size in bytes </p>

</div>
</div>
<a class="anchor" id="a277e4fbdef7f737096d9a5122fff259d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_load_splat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::load_splat </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a memory location and broadcasts it to all elements of a vector. </p>
<div class="fragment"><div class="line">r0 = *p</div>
<div class="line">...</div>
<div class="line">rN = *p</div>
</div><!-- fragment --><p><em>p</em> must have the alignment of the element of the target vector. </p>

</div>
</div>
<a class="anchor" id="a47aa85fde44d769baa5132b630bdffc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_load_u&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::load_u </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a 128-bit or 256-bit integer, 32-bit or 64-bit float vector from an unaligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..127] = *(p)</div>
</div><!-- fragment --><p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 16 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 16-byte aligned 32-byte block may be accessed.</p>
<ul>
<li>In ALTIVEC this intrinsic results in at least 4 instructions.</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">a[0..255] = *(p)</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1 and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 6 instructions.</li>
</ul>
<p><em>p</em> must be aligned to the element size. If <em>p</em> is aligned to 32 bytes only the referenced 16 byte block is accessed. Otherwise, memory within the smallest 32-byte aligned 64-byte block may be accessed. </p>

</div>
</div>
<a class="anchor" id="aaa65ccf187a7146e55b4d2fffbbbd5e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;double,1&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_float </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from floating-point values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7bf349921e9167f4d1fc57fe463b208"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;double,2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_float </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from floating-point values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a94279b55defe4d2d446db6f4c0aab0de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;double,4&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_float </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from floating-point values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a6903005ddd74ebe0cadd06c8e2416b97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;double,8&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_float </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from floating-point values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a53f37aaa88fb392f3500e85acb0b58de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;int64_t,1&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_int </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v0</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from signed integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="abe5c89acfe9c96b80b6fc6ffdc1d96ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;int64_t,2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_int </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from signed integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a1af10fe42496184f4e1e533d19ff01ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;int64_t,4&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_int </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from signed integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a31f9810b62d9575d97f65e3d768b3ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;int64_t,8&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_int </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from signed integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a97e3c7e4fb3b5cac0b040c6ff2688c46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;int64_t,16&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_int </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v14</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v15</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from signed integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="abc28b64fd1bb870c4e542eeb08ffe122"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of two adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,1] select elements from the first vector. Values [2,3] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0] : b[s0-2])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1] : b[s1-2])</div>
<div class="line">r2 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+2] : b[s0])</div>
<div class="line">r3 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+2] : b[s1])</div>
<div class="line">...</div>
<div class="line">r14 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+14] : b[s0+12])</div>
<div class="line">r15 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+14] : b[s1+12])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a50820f0531b5a7155c6cae0123e63855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, int s2, int s3, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of four adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,3] select elements from the first vector. Values [4,7] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 4 ? a[s0] : b[s0-4])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 4 ? a[s1] : b[s1-4])</div>
<div class="line">r2 = (s2 == -1) ? 0 : (s2 &lt; 4 ? a[s2] : b[s2-4])</div>
<div class="line">r3 = (s3 == -1) ? 0 : (s3 &lt; 4 ? a[s3] : b[s3-4])</div>
<div class="line">...</div>
<div class="line">r12 = (s0 == -1) ? 0 : (s0 &lt; 4 ? a[s0+12] : b[s0+8])</div>
<div class="line">r13 = (s1 == -1) ? 0 : (s1 &lt; 4 ? a[s1+12] : b[s1+8])</div>
<div class="line">r14 = (s2 == -1) ? 0 : (s2 &lt; 4 ? a[s2+12] : b[s2+8])</div>
<div class="line">r15 = (s3 == -1) ? 0 : (s3 &lt; 4 ? a[s3+12] : b[s3+8])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="af320c9c0f0e43e7be582f31256dc4e50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, int s2, int s3, int s4, int s5, int s6, int s7, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of eight adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,7] select elements from the first vector. Values [8,15] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 8 ? a[s0] : b[s0-8])</div>
<div class="line">...</div>
<div class="line">r7 = (s7 == -1) ? 0 : (s7 &lt; 8 ? a[s7] : b[s7-8])</div>
<div class="line">r8 = (s0 == -1) ? 0 : (s0 &lt; 8 ? a[s0+8] : b[s0])</div>
<div class="line">...</div>
<div class="line">r15 = (s7 == -1) ? 0 : (s7 &lt; 8 ? a[s7+8] : b[s7])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="ad4a932864c6a9d9479660328a5b15d73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, int s2, int s3, int s4, int s5, int s6, int s7, int s8, int s9, int s10, int s11, int s12, int s13, int s14, int s15, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int8x16 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>The template arguments define which elements to select from each element group: Values [0,15] select elements from the first vector. Values [16,32] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 16 ? a[s0] : b[s0-16])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s0 &lt; 16 ? a[s1] : b[s1-16])</div>
<div class="line">...</div>
<div class="line">r15 = (s15 == -1) ? 0 : (s15 &lt; 16 ? a[s15] : b[s15-16])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a9302abef5882c07c0a62401367c9cf86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int16x8 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of two adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,1] select elements from the first vector. Values [2,3] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0] : b[s0-2])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1] : b[s1-2])</div>
<div class="line">r2 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+2] : b[s0])</div>
<div class="line">r3 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+2] : b[s1])</div>
<div class="line">...</div>
<div class="line">r6 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+6] : b[s0+4])</div>
<div class="line">r7 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+6] : b[s1+4])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a5b89736672b46ddd36e573d1e3957323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, int s2, int s3, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int16x8 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of four adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,3] select elements from the first vector. Values [4,7] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 4 ? a[s0] : b[s0-4])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 4 ? a[s1] : b[s1-4])</div>
<div class="line">r2 = (s2 == -1) ? 0 : (s2 &lt; 4 ? a[s2] : b[s2-4])</div>
<div class="line">r3 = (s3 == -1) ? 0 : (s3 &lt; 4 ? a[s3] : b[s3-4])</div>
<div class="line">...</div>
<div class="line">r12 = (s0 == -1) ? 0 : (s0 &lt; 4 ? a[s0+12] : b[s0+8])</div>
<div class="line">r13 = (s1 == -1) ? 0 : (s1 &lt; 4 ? a[s1+12] : b[s1+8])</div>
<div class="line">r14 = (s2 == -1) ? 0 : (s2 &lt; 4 ? a[s2+12] : b[s2+8])</div>
<div class="line">r15 = (s3 == -1) ? 0 : (s3 &lt; 4 ? a[s3+12] : b[s3+8])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a2dfac2767b4ffffd60c8f8eb1c23947b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, int s2, int s3, int s4, int s5, int s6, int s7, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int16x8 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>The template arguments define which elements to select from each element group: Values [0,7] select elements from the first vector. Values [8,15] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 8 ? a[s0] : b[s0-8])</div>
<div class="line">...</div>
<div class="line">r7 = (s7 == -1) ? 0 : (s7 &lt; 8 ? a[s7] : b[s7-8])</div>
<div class="line">r8 = (s0 == -1) ? 0 : (s0 &lt; 8 ? a[s0+8] : b[s0])</div>
<div class="line">...</div>
<div class="line">r15 = (s7 == -1) ? 0 : (s7 &lt; 8 ? a[s7+8] : b[s7])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a401c9c5103f69c0ec07cf9c869313c63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int32x4 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>All elements within vectors are grouped into sets of two adjacent elements. Elements within each set of the resulting vector can be selected only from corresponding sets of the source vectors.</p>
<p>The template arguments define which elements to select from each element group: Values [0,1] select elements from the first vector. Values [2,3] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0] : b[s0-2])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1] : b[s1-2])</div>
<div class="line">r2 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0+2] : b[s0])</div>
<div class="line">r3 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1+2] : b[s1])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a44fdf66f4485bc00aadb9c919dfe8ea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, int s2, int s3, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int32x4 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>The template arguments define which elements to select from each element group: Values [0,3] select elements from the first vector. Values [4,7] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 4 ? a[s0] : b[s0-4])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 4 ? a[s1] : b[s1-4])</div>
<div class="line">r2 = (s2 == -1) ? 0 : (s2 &lt; 4 ? a[s2] : b[s2-4])</div>
<div class="line">r3 = (s3 == -1) ? 0 : (s3 &lt; 4 ? a[s3] : b[s3-4])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a3c298aab08e0e47b97879f3d9ab2c8df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s0, int s1, unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N&gt; simdpp::make_shuffle_bytes16_mask </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a mask to shuffle an int64x2 vector using <code>permute_bytes16</code>, <code>shuffle_bytes16</code>, <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> functions. </p>
<p>The template arguments define which elements to select from each element group: Values [0,1] select elements from the first vector. Values [2,3] select elements from the second vector. The mask can only be used in <code>shuffle_bytes16</code> or <code>shuffle_zbytes16</code> Value [-1] sets the corresponding element to zero. The mask can only be used in <code>permute_zbytes16</code> or <code>shuffle_zbytes16</code> </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<p>The created mask will cause <code>shuffle_bytes16</code> to perform as follows: </p>
<div class="fragment"><div class="line">r0 = (s0 == -1) ? 0 : (s0 &lt; 2 ? a[s0] : b[s0])</div>
<div class="line">r1 = (s1 == -1) ? 0 : (s1 &lt; 2 ? a[s1] : b[s1])</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately. </p>

</div>
</div>
<a class="anchor" id="a4a0ba91265715324162086ea8c91d858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;uint64_t,1&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_uint </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v0</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from unsigned integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<p>Note that per C++ rules negative values are sign-extended to fill entire element before being converted to unsigned type thus e.g. it's safe to use -1 to fill element with ones.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b7024b6cc0424ee6ec21b56adefd5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;uint64_t,2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_uint </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from unsigned integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<p>Note that per C++ rules negative values are sign-extended to fill entire element before being converted to unsigned type thus e.g. it's safe to use -1 to fill element with ones.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a61cb3bcfd440927c056885a19f30d9dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;uint64_t,4&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_uint </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from unsigned integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<p>Note that per C++ rules negative values are sign-extended to fill entire element before being converted to unsigned type thus e.g. it's safe to use -1 to fill element with ones.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a4ea0bd3a09686dbbf7937fde652833cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;uint64_t,8&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_uint </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from unsigned integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<p>Note that per C++ rules negative values are sign-extended to fill entire element before being converted to unsigned type thus e.g. it's safe to use -1 to fill element with ones.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aaab51b66c15c060eff38f122c9fd2edb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_make_const&lt;uint64_t,16&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::make_uint </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v14</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v15</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector from unsigned integer values known at compile-time. </p>
<p>The result of this function may be assigned or converted to a vector of any type: standard conversions are used to convert the arguments. All conversions and other overhead is performed at compile-time thus even if the minimal optimization level is selected, the function results in a simple load from memory.</p>
<p>The function is not guaranteed to have adequate performance if the arguments are not known at compile-time.</p>
<p>If the vector has fewer elements than the number of the parameters this function accepts then the extra values are discarded.</p>
<p>Note that per C++ rules negative values are sign-extended to fill entire element before being converted to unsigned type thus e.g. it's safe to use -1 to fill element with ones.</p>
<dl class="section user"><dt>1 parameter version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v0 v0 v0 ... v0 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>2 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v0 v1 ... v1 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>4 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  2  3  ... n  |</div>
<div class="line">r = [ v0 v1 v2 v3 ... v3 ]</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>8 parameters version</dt><dd><div class="fragment"><div class="line">    | 0  1  ..  7  8  ... n  |</div>
<div class="line">r = [ v0 v1 .. v7 v0  ... v7 ]</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a7aa59db112d340032eba1ebf5ded06e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maxima of the values of two vectors. </p>
<p>If at least one of the values is NaN, or both values are zeroes, it is unspecified which value will be returned.</p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0761c4077c8fe889f664e2ddc48080b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00025.html">int8</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maximum of the signed 8-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 8 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5b0bc204d48fdf680e1479c8309791b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00135.html">uint8</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maximum of the unsigned 8-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a94fa2c60eca255ba0ab478a7f2d5c330"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00021.html">float64</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maxima of the values of two vectors. </p>
<p>If at least one of the values is NaN, or both values are zeroes, it is unspecified which value will be returned.</p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac05c527df4d10c893a0d470a79f750a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00022.html">int16</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maximum of the signed 16-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a407a9edc4850386e66d60a540e02770c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00123.html">uint16</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maximum of the unsigned 16-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 6-7 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 12-13 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad1020392e00b5eee61b0f6f943680622"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00023.html">int32</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maximum of the signed 32-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 8 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad0bd56064b366f6161440bb2e98debcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00127.html">uint32</a>&lt;N&gt; &gt; simdpp::max </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes maximum of the unsigned 32-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 6-7 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 12-13 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4ba3a107f8b0b3181030f9891219a259"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minimum of the values in two vectors. </p>
<p>If at least one of the values is NaN, or both values are zeroes, it is unspecified which value will be returned.</p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5a365a1ffd95d0d8e34fe5d1ffa3ac19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00025.html">int8</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minimum of signed 8-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 8 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0648202e8e0451ddb45447816d5108e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00135.html">uint8</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minimum of the unsigned 8-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3eee066c94d6510f314c6538bc597d49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00021.html">float64</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minima of the values in two vectors. </p>
<p>If at least one of the values is NaN, or both values are zeroes, it is unspecified which value will be returned.</p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2b90b4fc2d4210d9bebf41317693bd60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00022.html">int16</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minimum of the signed 16-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a91ca381a9cd41a9a6d2b51c8f0e9b58f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00123.html">uint16</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minimum of the unsigned 16-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 6-7 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 12-13 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aed48804fb936cb1431a1051cb44d75ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00023.html">int32</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minimum of the signed 32-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 8 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a435cd4d9b25c380060ecdba3dab2839c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00127.html">uint32</a>&lt;N&gt; &gt; simdpp::min </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes minimum of the unsigned 32-bit values. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(a0, b0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a4ba3a107f8b0b3181030f9891219a259" title="Computes minimum of the values in two vectors. ">min</a>(aN, bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 6-7 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 12-13 instructions. </li>
<li>In SSE4.1-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1b3c78172677c62853e899574aa8b3f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move16_l </td>
          <td>(</td>
          <td class="paramtype">const any_vec8&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the elements in an int8x16 vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ a0  a1   .  a14 a15 ]</div>
<div class="line"> 1      r = [ a1  a2   .  a15  0  ]</div>
<div class="line"> 2      r = [ a2  a3   .   0   0  ]</div>
<div class="line">  ...    ..   .. ..   ...  ..  .. ..</div>
<div class="line"> 14     r = [ a15  0   .   0   0  ]</div>
<div class="line"> 15     r = [  0   0   .   0   0  ]</div>
<div class="line"> 16     r = [  0   0   .   0   0  ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="afef04acdd6e160325d1f3ee4eb2e156f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move16_r </td>
          <td>(</td>
          <td class="paramtype">const any_vec8&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 8-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0   1    .  14  15  |</div>
<div class="line"> 0      r = [ a0  a1   .  a14 a15 ]</div>
<div class="line"> 1      r = [  0  a0   .  a13 a14 ]</div>
<div class="line"> 2      r = [  0   0   .  a12 a13 ]</div>
<div class="line">  ...    ..   .. ..   ...  ..  .. ..</div>
<div class="line"> 14     r = [  0   0   .  a0  a1  ]</div>
<div class="line"> 15     r = [  0   0   .   0  a0  ]</div>
<div class="line"> 16     r = [  0   0   .   0   0  ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4af670176ba3b2ab629b3ccf4905f376"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move2_l </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [ a1  0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4d5b00bec4a5c5c2244ba939b891c94f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move2_r </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 64-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  |</div>
<div class="line"> 0      r = [ a0 a1 ]</div>
<div class="line"> 1      r = [  0 a0 ]</div>
<div class="line"> 2      r = [  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a283dd91ecc9c13b9473a5710907c0cf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move4_l </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 1      r = [ a1 a2 a3  0 ]</div>
<div class="line"> 2      r = [ a2 a3  0  0 ]</div>
<div class="line"> 3      r = [ a3  0  0  0 ]</div>
<div class="line"> 4      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3277be4a184312b88add88d9bf11b49c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move4_r </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 32-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1  2  3  |</div>
<div class="line"> 0      r = [ a0 a1 a2 a3 ]</div>
<div class="line"> 1      r = [  0 a0 a1 a2 ]</div>
<div class="line"> 2      r = [  0  0 a0 a1 ]</div>
<div class="line"> 3      r = [  0  0  0 a0 ]</div>
<div class="line"> 4      r = [  0  0  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7ad8638640fb716364bbd0ed897dc1a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move8_l </td>
          <td>(</td>
          <td class="paramtype">const any_vec16&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 16-bit elements in a vector to the left by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1   . 6  7  |</div>
<div class="line"> 0      r = [ a0 a1  . a6 a7 ]</div>
<div class="line"> 1      r = [ a1 a2  . a7  0 ]</div>
<div class="line"> 2      r = [ a2 a3  .  0  0 ]</div>
<div class="line">  ...    ..   .. .. ... .. ..</div>
<div class="line"> 6      r = [ a6 a7  .  0  0 ]</div>
<div class="line"> 7      r = [ a7  0  .  0  0 ]</div>
<div class="line"> 8      r = [  0  0  .  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab0c708996c09711bf1db8deeb3c0e29c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned shift, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::move8_r </td>
          <td>(</td>
          <td class="paramtype">const any_vec16&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the 16-bit elements in a vector to the right by <em>shift</em> positions. </p>
<div class="fragment"><div class="line">shift:  pos:| 0  1   . 6  7  |</div>
<div class="line"> 0      r = [ a0 a1  . a6 a7 ]</div>
<div class="line"> 1      r = [  0 a0  . a5 a6 ]</div>
<div class="line"> 2      r = [  0  0  . a4 a5 ]</div>
<div class="line">  ...    ..   .. .. ... .. ..</div>
<div class="line"> 6      r = [  0  0  . a0 a1 ]</div>
<div class="line"> 7      r = [  0  0  .  0 a0 ]</div>
<div class="line"> 8      r = [  0  0  .  0  0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a20c3eacf9886d5e5d369b8ef4ab82294"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00047.html">expr_mul</a>&lt;<a class="el" href="a00020.html">float32</a>&lt;N,E1&gt;, <a class="el" href="a00020.html">float32</a>&lt;N,E2&gt; &gt; &gt; simdpp::mul </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 * b0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a676d2c7f4c1f58a9eb2e9d17421367c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00047.html">expr_mul</a>&lt;<a class="el" href="a00021.html">float64</a>&lt;N,E1&gt;, <a class="el" href="a00021.html">float64</a>&lt;N,E2&gt; &gt; &gt; simdpp::mul </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 * b0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae0ff262e172a5834bcc35ac990bbf5e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00048.html">expr_mul_hi</a>&lt;<a class="el" href="a00022.html">int16</a>&lt;N,E1&gt;, <a class="el" href="a00022.html">int16</a>&lt;N,E2&gt; &gt; &gt; simdpp::mul_hi </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit values and returns the higher half of the result. </p>
<div class="fragment"><div class="line">r0 = high(a0 * b0)</div>
<div class="line">...</div>
<div class="line">rN = high(aN * bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 6 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6bc3b6b14d4eab3a0e095ac82fc85e61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00048.html">expr_mul_hi</a>&lt;<a class="el" href="a00123.html">uint16</a>&lt;N,E1&gt;, <a class="el" href="a00123.html">uint16</a>&lt;N,E2&gt; &gt; &gt; simdpp::mul_hi </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies unsigned 16-bit values and returns the higher half of the result. </p>
<div class="fragment"><div class="line">r0 = high(a0 * b0)</div>
<div class="line">...</div>
<div class="line">rN = high(aN * bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 6 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aab9ac150759822bb2390eea905fcf859"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00049.html">expr_mul_lo</a>&lt;<a class="el" href="a00123.html">uint16</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00123.html">uint16</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::mul_lo </td>
          <td>(</td>
          <td class="paramtype">const any_int16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies 16-bit values and returns the lower part of the multiplication. </p>
<div class="fragment"><div class="line">r0 = low(a0 * b0)</div>
<div class="line">...</div>
<div class="line">rN = low(aN * bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aeec3aa7a9f48ca8d24d57be3447c54c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00049.html">expr_mul_lo</a>&lt;<a class="el" href="a00127.html">uint32</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00127.html">uint32</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::mul_lo </td>
          <td>(</td>
          <td class="paramtype">const any_int32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies 32-bit values and returns the lower half of the result. </p>
<div class="fragment"><div class="line">r0 = low(a0 * b0)</div>
<div class="line">...</div>
<div class="line">rN = low(aN * bN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 8 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1, AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 16 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a61fedb195c62753f375b6a135af04ed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00050.html">expr_mull</a>&lt;<a class="el" href="a00022.html">int16</a>&lt;N,E1&gt;, <a class="el" href="a00022.html">int16</a>&lt;N,E2&gt; &gt; &gt; simdpp::mull </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit values and expands the results to 32 bits. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">r0 = a0 * b0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN</div>
</div><!-- fragment --></dd></dl>
<ul>
<li>In SSE2-AVX and ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<p>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</p>
<ul>
<li>In SSE2-AVX and ALTIVEC this intrinsic results in at least 4-6 instructions. </li>
<li>In AVX2 and NEON this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="af9ce612f79de953cacb035ecd1808953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00050.html">expr_mull</a>&lt;<a class="el" href="a00123.html">uint16</a>&lt;N,E1&gt;, <a class="el" href="a00123.html">uint16</a>&lt;N,E2&gt; &gt; &gt; simdpp::mull </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies unsigned 16-bit values and expands the results to 32 bits. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">r0 = a0 * b0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN</div>
</div><!-- fragment --></dd></dl>
<ul>
<li>In SSE2-AVX2 and ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX and ALTIVEC this intrinsic results in at least 4-6 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2-3 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. <dl class="section note"><dt>Note</dt><dd>Use with mull_hi on the same arguments to save instructions. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a1ef168d13752b6e7c6f13274cf89ff98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">int64</a>&lt;N, <a class="el" href="a00050.html">expr_mull</a>&lt;<a class="el" href="a00023.html">int32</a>&lt;N,E1&gt;, <a class="el" href="a00023.html">int32</a>&lt;N,E2&gt; &gt; &gt; simdpp::mull </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies signed 32-bit values in and expands the results to 64 bits. </p>
<div class="fragment"><div class="line">r0 = a0 * b0</div>
<div class="line">...</div>
<div class="line">rN = aN * bN</div>
</div><!-- fragment --> <dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE4.1-AVX this intrinsic results in at least 3 instructions. </li>
<li>Not implemented for SSE2-SSSE3 and ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE4.1-AVX this intrinsic results in at least 6 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>Not implemented for SSE2-SSSE3 and ALTIVEC. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab1593ec62b30e0fe5dce5cc4b3173cca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N, <a class="el" href="a00050.html">expr_mull</a>&lt;<a class="el" href="a00127.html">uint32</a>&lt;N,E1&gt;, <a class="el" href="a00127.html">uint32</a>&lt;N,E2&gt; &gt; &gt; simdpp::mull </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies unsigned 32-bit values in the lower halves of the vectors and expands the results to 64 bits. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">r0 = a0 * b0</div>
<div class="line">r1 = a1 * b1</div>
</div><!-- fragment --> <ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>Not implemented for ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad88283884c72955203f292750acc8815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00051.html">expr_neg</a>&lt;<a class="el" href="a00025.html">int8</a>&lt;N,E&gt; &gt; &gt; simdpp::neg </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates signed 8-bit values. </p>
<div class="fragment"><div class="line">r0 = -a0</div>
<div class="line">...</div>
<div class="line">rN = -aN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a99872876f61e9352d814dc1d9980a15c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00051.html">expr_neg</a>&lt;<a class="el" href="a00020.html">float32</a>&lt;N,E&gt; &gt; &gt; simdpp::neg </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates the values of a float32x4 vector. </p>
<div class="fragment"><div class="line">r0 = -a0</div>
<div class="line">...</div>
<div class="line">rN = -aN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 and ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 and ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX-AVX2 and NEON this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af62ed3b801192dbf45db14c3d6300dc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00051.html">expr_neg</a>&lt;<a class="el" href="a00022.html">int16</a>&lt;N,E&gt; &gt; &gt; simdpp::neg </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates signed 16-bit values. </p>
<div class="fragment"><div class="line">r0 = -a0</div>
<div class="line">...</div>
<div class="line">rN = -aN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae539d567bbaa90164cdca58dfc59de0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00051.html">expr_neg</a>&lt;<a class="el" href="a00021.html">float64</a>&lt;N,E&gt; &gt; &gt; simdpp::neg </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates the values of a vector. </p>
<div class="fragment"><div class="line">r0 = -a0</div>
<div class="line">...</div>
<div class="line">rN = -aN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 1-2 instructions. </li>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1-2 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad66a8bedf5a336936507a0618bb254e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00051.html">expr_neg</a>&lt;<a class="el" href="a00023.html">int32</a>&lt;N,E&gt; &gt; &gt; simdpp::neg </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates signed 32-bit values. </p>
<div class="fragment"><div class="line">r0 = -a0</div>
<div class="line">...</div>
<div class="line">rN = -aN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a03619c8be5e6b5667765b43b6fbfd106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">int64</a>&lt;N, <a class="el" href="a00051.html">expr_neg</a>&lt;<a class="el" href="a00024.html">int64</a>&lt;N,E&gt; &gt; &gt; simdpp::neg </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates signed 64-bit values. </p>
<div class="fragment"><div class="line">r0 = -a0</div>
<div class="line">...</div>
<div class="line">rN = -aN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 4-5 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 8-9 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a87ba99d37d67ca5723a3ad8c2b4d8d9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::permute2 </td>
          <td>(</td>
          <td class="paramtype">const any_vec16&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the 16-bit values within sets of two consecutive elements of the vector. </p>
<p>The selector values must be in range [0; 1].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">r1 = a[s1]</div>
<div class="line">r2 = a[s0+2]</div>
<div class="line">r3 = a[s1+2]</div>
<div class="line">r4 = a[s0+4]</div>
<div class="line">r5 = a[s1+4]</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section user"><dt>: 128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>: 256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab34cb76d09ec6eb6d1ff8a19f57e4710"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::permute2 </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the values of each set of four consecutive 32-bit values. </p>
<p>The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">r1 = a[s1]</div>
<div class="line">r2 = a[s0+2]</div>
<div class="line">r3 = a[s1+2]</div>
<div class="line">256-bit version:</div>
<div class="line">r4 = a[s0+4]</div>
<div class="line">r5 = a[s1+4]</div>
<div class="line">r6 = a[s0+6]</div>
<div class="line">r7 = a[s1+6]</div>
</div><!-- fragment --><dl class="section user"><dt>integer</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>floating-point</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa6d96ec58fe0ef6177912c523df00bf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::permute2 </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the values of each set of four consecutive 32-bit values. </p>
<p>The selector values must be in range [0; 1].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">r1 = a[s1]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line">r2 = a[s0+2]</div>
<div class="line">r3 = a[s1+2]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-4 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0607a26dbc16a9f1039cca5a03a28fd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::permute4 </td>
          <td>(</td>
          <td class="paramtype">const any_vec16&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the 16-bit values within each 4 consecutive values of the vector. </p>
<p>The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">...</div>
<div class="line">r3 = a[s3]</div>
<div class="line">r4 = a[s0+4]</div>
<div class="line">...</div>
<div class="line">r7 = a[s3+4]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line"></div>
<div class="line">r8 = a[s0+8]</div>
<div class="line">...</div>
<div class="line">r11 = a[s3+8]</div>
<div class="line">r12 = a[s0+12]</div>
<div class="line">...</div>
<div class="line">r15 = a[s3+12]</div>
</div><!-- fragment --><dl class="section user"><dt>: 128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 1-5 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>: 256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-10 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a09bdb1a2dfe570958d73bc1fb187f176"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::permute4 </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the values of each set of four consecutive 32-bit values. </p>
<p>The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">...</div>
<div class="line">r3 = a[s3]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line">r4 = a[s0+4]</div>
<div class="line">...</div>
<div class="line">r7 = a[s3+4]</div>
</div><!-- fragment --><dl class="section user"><dt>integer</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>floating-point</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a07799d262b45070c606d4a20f6420b14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::permute4 </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the values of each set of four consecutive 64-bit values. </p>
<p>The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">r1 = a[s1]</div>
<div class="line">r2 = a[s2]</div>
<div class="line">r3 = a[s3]</div>
</div><!-- fragment --><dl class="section user"><dt>integer</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>floating-point</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 1-2 instructions. </li>
<li>In NEON this intrinsic results in at least 1-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af07615009b2fd3dd8658ccdd9775e043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a55050dafd27987ea365a6219d224f634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8e1d8c18a9040e3c256c2bcb5dbdb45e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N&gt; simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5e5fd08d30d58814cd24208cc2365ffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N&gt; simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad9380376524cdcb253379a841ee93e50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N&gt; simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4608bc2f0d4fa9c6e8795d9192d944be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N&gt; simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a729b44f44eb9e44b90c452ea37a83687"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N&gt; simdpp::permute_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ace7e6e04e0477ca0ae96450f9d3d8997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> simdpp::permute_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="af75c2cea9f9c1972d2649ca245cda280"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::permute_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac87210c887a4d503f90e608ff10c8331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N&gt; simdpp::permute_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a53326a4946672d2e733638cd60267dbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N&gt; simdpp::permute_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad5b467a4c8b2d3288ba0e9a7b2026104"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N&gt; simdpp::permute_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0baf685cfad1ac330b88e2d559f73a9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N&gt; simdpp::permute_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad8ecaa40e2384a0dab10d61f4b8ef6f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N&gt; simdpp::permute_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from a vector according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-4 must be zero or the behavior is undefined Bits 3-0 define the element within the given vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1d52060accdfc70b3d1a413faae3f4e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::rcp_e </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes approximate reciprocal. </p>
<p>Relative error is as follows:</p>
<ul>
<li>1/2 ULP for NULL and NEON</li>
<li>~1/2730 for SSE2</li>
<li>1/4096 for ALTIVEC</li>
<li>1/256 for NEON_FLT_SP</li>
</ul>
<div class="fragment"><div class="line">r0 = approx(1.0f / a0)</div>
<div class="line">...</div>
<div class="line">rN = approx(1.0f / aN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a841f5f032d89fe22b20ab3929f2e315f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::rcp_rh </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes one Newton-Rhapson iterations for reciprocal. </p>
<p><em>x</em> is the current estimate, <em>a</em> are the values to estimate reciprocal for.</p>
<div class="fragment"><div class="line">r0 = x0 * (2 - x0*a0)</div>
<div class="line">...</div>
<div class="line">rN = xN * (2 - xN*aN)</div>
</div><!-- fragment --><p>Using this function, one can the division can be implemented as follows: </p>
<div class="fragment"><div class="line"><span class="comment">// a/b</span></div>
<div class="line"><a class="code" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> x;</div>
<div class="line">x = <a class="code" href="a00156.html#a1d52060accdfc70b3d1a413faae3f4e6" title="Computes approximate reciprocal. ">rcp_e</a>(b);</div>
<div class="line">x = <a class="code" href="a00156.html#a841f5f032d89fe22b20ab3929f2e315f" title="Computes one Newton-Rhapson iterations for reciprocal. ">rcp_rh</a>(x, b);</div>
<div class="line">x = <a class="code" href="a00156.html#a841f5f032d89fe22b20ab3929f2e315f" title="Computes one Newton-Rhapson iterations for reciprocal. ">rcp_rh</a>(x, b);</div>
<div class="line"><span class="keywordflow">return</span> <a class="code" href="a00156.html#a20c3eacf9886d5e5d369b8ef4ab82294" title="Multiplies the values of two vectors. ">mul</a>(a, x);</div>
</div><!-- fragment --><p>Precision can be controlled by selecting the number of <code>rcp_rh</code> steps.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In AVX-AVX2 this intrinsic results in at least 3-4 instructions. </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 6-7 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 4-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af606974cd7c2e7b489665af171c757a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::rsqrt_e </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes approximate reciprocal square root. </p>
<p>Relative error is as follows:</p>
<ul>
<li>1/2 ULP for NULL and NEON</li>
<li>~1/2730 for SSE2</li>
<li>1/4096 for ALTIVEC</li>
<li>1/256 for NEON_FLT_SP</li>
</ul>
<div class="fragment"><div class="line">r0 = approx(1 / <a class="code" href="a00156.html#acc5197ff42cca41e903165e77262b662" title="Computes square root. ">sqrt</a>(a0))</div>
<div class="line">...</div>
<div class="line">rN = approx(1 / <a class="code" href="a00156.html#acc5197ff42cca41e903165e77262b662" title="Computes square root. ">sqrt</a>(aN))</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5484877996923c12dcbbfb8d5440353c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::rsqrt_rh </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes one Newton-Rhapson iteration for inverse of square root. </p>
<p><em>x</em> is the current estimate, <em>a</em> are the values to estimate the inverse square root for.</p>
<div class="fragment"><div class="line">r0 = x0 * (3 - a0*x0*x0) * 0.5</div>
<div class="line">...</div>
<div class="line">rN = xN * (3 - aN*xN*xN) * 0.5</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2, SSE3, SSSE3 and SSE4.1 this intrinsic results in at least 5-7 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 4-6 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In AVX-AVX2 this intrinsic results in at least 7 instructions. </li>
<li>In SSE2, SSE3, SSSE3 and SSE4.1 this intrinsic results in at least 10-12 instructions. </li>
<li>In NEON this intrinsic results in at least 6 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 8-10 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a283dd44c6c0eb35bf2f692be07aa4431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00025.html">int8</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 8-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8-9 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afdc9838fd613f636a9161daf51f33e40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 8-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8-9 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8a8ac7bf66fa5acfcf07e7da227c0512"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00022.html">int16</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 16-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a907cce54825bc513315355b0ef5b740a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 16-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0cca7fe880962bc0cb0579847603b939"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00023.html">int32</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 32-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0adfb96f9cd90a99369ce2b5f0cf0659"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 32-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af934fafc5386953c29cec03680f32553"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">int64</a>&lt;N, <a class="el" href="a00024.html">int64</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 64-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>Not implemented for ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af284a1fbcdbeff160dc5ef5b37178266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 64-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>Not implemented for ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae04716a0087fdbff6f3ddb51bafce16c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00025.html">int8</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 8-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 2-3 instructions. </li>
<li>In NEON this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4-5 instructions. </li>
<li>In AVX2 and NEON this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5cd9a4ca2decbce49dac8a8bcab65cc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 8-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 2-3 instructions. </li>
<li>In NEON this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4-5 instructions. </li>
<li>In AVX2 and NEON this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a934ce3f99012aa239a1064f82bddda8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00022.html">int16</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 16-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a59b8535579b8f48521e7b985a69517b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 16-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a53f1476e818ff93cec9c523b0355993b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00023.html">int32</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 32-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa862e9283258d1d6b1b550f501494ea1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 32-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab4949e7f822bab1a995d829312aee104"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">int64</a>&lt;N, <a class="el" href="a00024.html">int64</a>&lt;N&gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 64-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><ul>
<li>Not implemented for ALTIVEC.</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab8e02657792d8d22c6f69ad87647a99b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt; simdpp::shift_l </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts 64-bit values left by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &lt;&lt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &lt;&lt; count</div>
</div><!-- fragment --><ul>
<li>Not implemented for ALTIVEC.</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3815103f7b6c5319cf00676785cb8c4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 8-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a597654750a1374e31a52cec5e47a0582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 8-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8-9 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab2c88068cd5b54ab1f14ad15ee10cc12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 16-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae018b5538ba43b282051a57286c423a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 16-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9c5602ae9285e7f8d5a05218d7fee472"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 32-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --> <ul>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab008c614330d6d02aee17e0ba6d5ccd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 32-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-5 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8c13e69dd002bcce8012a01431ec8e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00024.html">int64</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 64-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4-6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>Not implemented for ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 8-10 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-6 instructions. </li>
<li>In NEON this intrinsic results in at least 3 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a18f8eac065991bac6b19235186c5279f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 64-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>Not implemented for ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-3 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a49f401e99d051fb08fce5e832a505ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt; N, <a class="el" href="a00025.html">int8</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 8-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4714c2e7284de7deca0cc07c5091cbd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt; N, <a class="el" href="a00135.html">uint8</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 8-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions. </li>
<li>In SSE2-AVX2 this intrinsic results in at least 2-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 4-5 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2-3 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4c95562c4cdd6d77546de9fc501e21dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt; N, <a class="el" href="a00022.html">int16</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 16-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac615591587f2b694c060ce5aba6eeb6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt; N, <a class="el" href="a00123.html">uint16</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 16-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a74c531a109ba8ad2bc4e06a2643511fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt; N, <a class="el" href="a00023.html">int32</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 32-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a89dd9e0ed93b0970681772daa1538838"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt; N, <a class="el" href="a00127.html">uint32</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 32-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa2edd99d48a4f8a4a383a179d38aa7ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">int64</a>&lt; N, <a class="el" href="a00024.html">int64</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts signed 64-bit values right by <em>count</em> bits while shifting in the sign bit. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in SSE2-AVX2. </li>
<li>In SSE2-AVX2 this intrinsic results in at least 4-6 instructions. </li>
<li>Not implemented for ALTIVEC.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in SSE2-AVX. </li>
<li>In SSE2-AVX this intrinsic results in at least 8-10 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-6 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1490b245a6c2f24836c62b8cdf7fabd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned count, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt; N, <a class="el" href="a00131.html">uint64</a>&lt; N &gt; &gt; simdpp::shift_r </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts unsigned 64-bit values right by <em>count</em> bits while shifting in zeros. </p>
<div class="fragment"><div class="line">r0 = a0 &gt;&gt; count</div>
<div class="line">...</div>
<div class="line">rN = aN &gt;&gt; count</div>
</div><!-- fragment --><ul>
<li>Not implemented for ALTIVEC.</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>Not implemented for ALTIVEC. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="affbba557b08a72b4146b070a2989cfec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::shuffle1 </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects 64-bit values from two vectors. </p>
<p>The first value in each pair of values must come from <em>a</em>, the second - from <em>b</em>. The selector values must be in range [0; 1].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">r1 = b[s1]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line">r2 = a[s0+2]</div>
<div class="line">r3 = b[s1+2]</div>
</div><!-- fragment --><dl class="section user"><dt>floating-point</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>integer</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 1-2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a278fa4aa6167f9a23deadc3d1b51e0c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned sa0, unsigned sa1, unsigned sb0, unsigned sb1, unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::shuffle2 </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects 32-bit floating-point values from two vectors. </p>
<p>The first two values in each four consecutive values must come from <em>a</em>, the last two - from <em>b</em>. The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[a0]</div>
<div class="line">r1 = a[a1]</div>
<div class="line">r2 = b[b0]</div>
<div class="line">r3 = b[b1]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line">r4 = a[a0+4]</div>
<div class="line">r5 = a[a1+4]</div>
<div class="line">r6 = b[b0+4]</div>
<div class="line">r7 = b[b1+4]</div>
</div><!-- fragment --><dl class="section user"><dt>floating-point</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions. </li>
<li>In NEON this intrinsic results in at least 1-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>integer</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 1-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa0b1175d39442f9b8eb99b1f4d4b98d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s0, unsigned s1, unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::shuffle2 </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects 32-bit values from two vectors. </p>
<p>The first two values in each four consecutive values must come from <em>a</em>, the last two - from <em>b</em>. The selector values must be in range [0; 3].</p>
<div class="fragment"><div class="line">r0 = a[s0]</div>
<div class="line">r1 = a[s1]</div>
<div class="line">r2 = b[s0]</div>
<div class="line">r3 = b[s1]</div>
<div class="line"></div>
<div class="line">256-bit version:</div>
<div class="line">r4 = a[s0+4]</div>
<div class="line">r5 = a[s1+4]</div>
<div class="line">r6 = b[s0+4]</div>
<div class="line">r7 = b[s1+4]</div>
</div><!-- fragment --><dl class="section user"><dt>floating-point</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions. </li>
<li>In NEON this intrinsic results in at least 2-4 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>integer</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 2-4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4-8 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a46464c3a48628ec0d6a6593cf544566a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> simdpp::shuffle_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0e67a0f5a628b3275f23da530e59c294"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::shuffle_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a936ab3b037dfed49a5928151212394a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N&gt; simdpp::shuffle_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa662d47992a1b4d17d18105beb9a695f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N&gt; simdpp::shuffle_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1607b66cafb0b985b16eb3b99a1d2ac3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N&gt; simdpp::shuffle_bytes16 </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a01d9e9d7e199550c0f0446dc19891ab9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N&gt; simdpp::shuffle_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a324c0dc1ba647cdd70fed4364b5e46fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N&gt; simdpp::shuffle_bytes16 </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask. </p>
<p>Each byte within the mask defines which element to select: Bits 7-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 12 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a339c0c0894d958de219f40ef8656944a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a4f89eaaf7f8fcd3a69ed31e17a1846d5">uint8x16</a> simdpp::shuffle_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 9 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 18 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa04d2d45fcc88a1384654a5c4cabf061"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N&gt; simdpp::shuffle_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 9 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 18 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1a3d22291398426ae85362d94da478b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N&gt; simdpp::shuffle_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 9 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 18 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="af133cc655b962d586ba81c16452bf2da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N&gt; simdpp::shuffle_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 9 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 18 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae138b38d09693d90ed6066ca116dc488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N&gt; simdpp::shuffle_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 9 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 18 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aef0c6546bcae7edf6a9f6987e8971d79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N&gt; simdpp::shuffle_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 9 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 18 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a74e4c9d2d98c3b02edba5a44c5a017e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N&gt; simdpp::shuffle_zbytes16 </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects bytes from two vectors according to a mask, optionally selecting zero. </p>
<p>Each byte within the mask defines which element to select: Bit 7 results in the result byte being zeroed, if set. Bits 6-5 must be zero or the behavior is undefined Bit 4 defines which vector to select. 0 corresponds to <em>a</em>, 1 to <em>b</em>. Bits 3-0 define the element within the selected vector.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 9 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 1 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The vectors will be shuffled as if the 128-bit version was applied to the lower and higher halves of the vectors separately.</dd></dl>
<ul>
<li>Not implemented for SSE2-SSE3. </li>
<li>In SSSE3 this intrinsic results in at least 18 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 12 instructions. </li>
<li>In AVX2 this intrinsic results in at least 6 instructions. </li>
<li>In XOP this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 4 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad6bd925b02334c203f5052089d7caacc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::sign </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts sign bits from the values in float32x4 vector. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; 0x80000000</div>
<div class="line">...</div>
<div class="line">rN = aN &amp; 0x80000000</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, ALTIVEC and NEON this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, ALTIVEC and NEON this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1-2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa7181ea06b84354524ae84509575a60a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00021.html">float64</a>&lt;N&gt; &gt; simdpp::sign </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts sigh bit from the values in float64x2 vector. </p>
<div class="fragment"><div class="line">r0 = a0 &amp; 0x8000000000000000</div>
<div class="line">...</div>
<div class="line">r0 = aN &amp; 0x8000000000000000</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 1-2 instructions. </li>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX-AVX2 this intrinsic results in at least 1-2 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a20ef3dd84b7ebf2bd6f821f0f0a57c05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_set_splat&lt;int&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::splat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a register and broadcasts it to all elements of a vector. </p>
<p>The argument value is converted to the element of the resulting vector using standard conversions.</p>
<div class="fragment"><div class="line">r0 = a</div>
<div class="line">...</div>
<div class="line">rN = a</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af2d06652df9b6c0348c0eb1d0ad2e163"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_set_splat&lt;unsigned&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::splat </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a register and broadcasts it to all elements of a vector. </p>
<p>The argument value is converted to the element of the resulting vector using standard conversions.</p>
<div class="fragment"><div class="line">r0 = a</div>
<div class="line">...</div>
<div class="line">rN = a</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a01b6c234c50a5638b4f2ff7810a6397c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_set_splat&lt;int64_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::splat </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a register and broadcasts it to all elements of a vector. </p>
<p>The argument value is converted to the element of the resulting vector using standard conversions.</p>
<div class="fragment"><div class="line">r0 = a</div>
<div class="line">...</div>
<div class="line">rN = a</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9fab604b00a5a0cc95f23cf6fb70f29f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_set_splat&lt;uint64_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::splat </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a register and broadcasts it to all elements of a vector. </p>
<p>The argument value is converted to the element of the resulting vector using standard conversions.</p>
<div class="fragment"><div class="line">r0 = a</div>
<div class="line">...</div>
<div class="line">rN = a</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7e45524afc75598c18aa7cc290ba29d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_set_splat&lt;float&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::splat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a register and broadcasts it to all elements of a vector. </p>
<p>The argument value is converted to the element of the resulting vector using standard conversions.</p>
<div class="fragment"><div class="line">r0 = a</div>
<div class="line">...</div>
<div class="line">rN = a</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7ee9a1324f1653fd892643a9a928e086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = expr_vec_set_splat&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V simdpp::splat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a register and broadcasts it to all elements of a vector. </p>
<p>The argument value is converted to the element of the resulting vector using standard conversions.</p>
<div class="fragment"><div class="line">r0 = a</div>
<div class="line">...</div>
<div class="line">rN = a</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8db1bd4774382f83ac647eb05a394893"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr_nomask&lt;V, void&gt;::empty simdpp::splat </td>
          <td>(</td>
          <td class="paramtype">const any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified element to all elements. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">rN = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>int8</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 5 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>int16</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 5 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>int32</dt><dd></dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>int64</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>float32</dt><dd></dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>float64</dt><dd></dd></dl>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a81b48a4d10a52523171769236a3a2714"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00052.html">expr_splat16</a>&lt;s,<a class="el" href="a00025.html">int8</a>&lt;N,E&gt; &gt; &gt; simdpp::splat16 </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 8-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">rN = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 7 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 1-2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE3 this intrinsic results in at least 14 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4f73adb0766b415789cef8892fa753e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00052.html">expr_splat16</a>&lt;s,<a class="el" href="a00135.html">uint8</a>&lt;N,E&gt; &gt; &gt; simdpp::splat16 </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 8-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">rN = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 7 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 1-2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE3 this intrinsic results in at least 14 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a21737f6d0da525e8f93924d4e2420fd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">int64</a>&lt;N, <a class="el" href="a00053.html">expr_splat2</a>&lt;s,<a class="el" href="a00024.html">int64</a>&lt;N,E&gt; &gt; &gt; simdpp::splat2 </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 64-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a77c89b28fdb1789048249a32edc4fd52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N, <a class="el" href="a00053.html">expr_splat2</a>&lt;s,<a class="el" href="a00131.html">uint64</a>&lt;N,E&gt; &gt; &gt; simdpp::splat2 </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 64-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acc82f7e042e5c2dd3b6f41791699cf09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00053.html">expr_splat2</a>&lt;s,<a class="el" href="a00021.html">float64</a>&lt;N,E&gt; &gt; &gt; simdpp::splat2 </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 64-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af8bf115f90afe41b27d34884007e589b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">int32</a>&lt;N, <a class="el" href="a00054.html">expr_splat4</a>&lt;s,<a class="el" href="a00023.html">int32</a>&lt;N,E&gt; &gt; &gt; simdpp::splat4 </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 32-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">r2 = a[s]</div>
<div class="line">r3 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a483c93fac94d14fc18ad43a2750a795d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00054.html">expr_splat4</a>&lt;s,<a class="el" href="a00127.html">uint32</a>&lt;N,E&gt; &gt; &gt; simdpp::splat4 </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 32-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">r2 = a[s]</div>
<div class="line">r3 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adba85714a35ff2c0f71e3308e926d71b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00054.html">expr_splat4</a>&lt;s,<a class="el" href="a00020.html">float32</a>&lt;N,E&gt; &gt; &gt; simdpp::splat4 </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 32-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">r2 = a[s]</div>
<div class="line">r3 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac9001ceaa947d4c3592feadac3df7ca9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00055.html">expr_splat8</a>&lt;s,<a class="el" href="a00022.html">int16</a>&lt;N,E&gt; &gt; &gt; simdpp::splat8 </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 16-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">r7 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 1-2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a080c5ee7b6017736b3a39983facf682b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned s, unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00055.html">expr_splat8</a>&lt;s,<a class="el" href="a00123.html">uint16</a>&lt;N,E&gt; &gt; &gt; simdpp::splat8 </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the specified 16-bit value to all elements within 128-bit lanes. </p>
<div class="fragment"><div class="line">r0 = a[s]</div>
<div class="line">r1 = a[s]</div>
<div class="line">...</div>
<div class="line">r7 = a[s]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 3 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 1-2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE3 this intrinsic results in at least 6 instructions. </li>
<li>In SSSE3-AVX this intrinsic results in at least 2-3 instructions. </li>
<li>In AVX2, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aab8d29fc607d1fd0f2d9c27fa5bf58a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8x16 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a072c9a21785f1f285ae4ad3adf1ec78f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aef25369afe28ca59e46db546fe83377d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32x4 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32x4 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aef334dbace19b13d421c64e1dc47b91f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64x2 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64x2 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5cce187506c789249ecb7ebbd293f9ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int8x32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8x16 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8x16 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a38f3753dd8ffcadb3bc7705562154f7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int16x16&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7f9426fc7565df8d882437181c4e6ba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32x4 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32x4 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae87db14817a18d000868f8028c10fe78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64x2 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64x2 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9396693f6a2b671ceedeced2688f301c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">float32x8&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="acc3baa88b2bba9c9d3d2db89e8cd25e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64x2 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4bb4f2319c022d466b3758e770e69130"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7bb0ce77c80ad79470310bb7f7737486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a45f8b1d1a4caf14dc48f0ec5c51c5606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="acef0bd8ad3db830e3dab4168ce9a9a52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a663d33b78ff7fac36db96c999d624c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4fc961fedf7d0a8ca9332bf734c1aa2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a742777583c7c0ba92fb2d0d5d184eb03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a854dc8c5ec7af45c4811e509c0fda28f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">int64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a192383a1aa540c43a7dead69ac4d59c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8678c076cd964cbadf0d2b44face76dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::split </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a 256-bit vector into two 128-bit vectors. </p>
<div class="fragment"><div class="line">[ r1, r2 ] = a</div>
</div><!-- fragment --><ul>
<li>In AVX2 this intrinsic results in at least 1 instructions. </li>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 0 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="acc5197ff42cca41e903165e77262b662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::sqrt </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes square root. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#acc5197ff42cca41e903165e77262b662" title="Computes square root. ">sqrt</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#acc5197ff42cca41e903165e77262b662" title="Computes square root. ">sqrt</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In NEON this intrinsic results in at least 5 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 5-7 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>In NEON this intrinsic results in at least 10 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 10-12 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a52555d4a71e3df3b755d2de54ff33ab1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00021.html">float64</a>&lt;N&gt; &gt; simdpp::sqrt </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes square root. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#acc5197ff42cca41e903165e77262b662" title="Computes square root. ">sqrt</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#acc5197ff42cca41e903165e77262b662" title="Computes square root. ">sqrt</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1152f57c44c2f45f338b1784b3dfb79d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer vector to an aligned memory location. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a546250aeec49e4ad17dd6165c1d898ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the first <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<p>The function may write entire block of 128 or 256 bits.</p>
<div class="fragment"><div class="line"> (p) = a0</div>
<div class="line"> (p+1) = a1</div>
<div class="line">...</div>
<div class="line"> (p+n-1) = a{n-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c78ca857e9602b2574aad59593467c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_last </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the last <em>n</em> elements of an 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory. </p>
<p><em>n</em> must be in range [0..N-1] where <em>N</em> is the number of elements in the vector. If <em>n</em> is zero, no store is made.</p>
<p>The function may write entire block of 128 or 256 bits.</p>
<div class="fragment"><div class="line"> (p+N-n) = a{N-n}</div>
<div class="line">...</div>
<div class="line"> (p+N-2) = a{N-2}</div>
<div class="line"> (p+N-1) = a{N-1}</div>
</div><!-- fragment --><p>This function results in several instructions. It is best not to use it in inner loops.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><em>p</em> must be aligned to 16 bytes. </dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><em>p</em> must be aligned to 32 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a717be328c9b42a1ac2206afe4ce7f276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves values from two vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+2), *(p+4), ... , *(p+M*2-2) ] = a</div>
<div class="line">[ *(p+1), *(p+3), *(p+5), ... , *(p+M*2-1) ] = b</div>
</div><!-- fragment --></dd></dl>
<p>Here M is the number of elements in the vector</p>
<p><em>p</em> must be aligned to the vector size in bytes </p>

</div>
</div>
<a class="anchor" id="a32c7905c8e7a5a932f089ee917158f52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 , class V3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves values from three vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+3), *(p+6), ... , *(p+M*3-3) ] = a</div>
<div class="line">[ *(p+1), *(p+4), *(p+7), ... , *(p+M*3-2) ] = b</div>
<div class="line">[ *(p+2), *(p+5), *(p+8), ... , *(p+M*3-1) ] = c</div>
</div><!-- fragment --></dd></dl>
<p>Here M is the number of elements in the vector</p>
<p><em>p</em> must be aligned to the vector size in bytes </p>

</div>
</div>
<a class="anchor" id="a506e25cb408021324450a48d2b026711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 , class V3 , class V4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::store_packed4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves values from four vectors and stores the result into successive locations starting from <em>p</em>. </p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">[ *(p),   *(p+4), *(p+8),  ... , *(p+M*4-4) ] = a</div>
<div class="line">[ *(p+1), *(p+5), *(p+9),  ... , *(p+M*4-3) ] = b</div>
<div class="line">[ *(p+2), *(p+6), *(p+10), ... , *(p+M*4-2) ] = c</div>
<div class="line">[ *(p+3), *(p+7), *(p+11), ... , *(p+M*4-1) ] = d</div>
</div><!-- fragment --></dd></dl>
<p>Here M is the number of elements in the vector</p>
<p><em>p</em> must be aligned to the vector size in bytes </p>

</div>
</div>
<a class="anchor" id="adbefc2f4e28510d793e341155120a398"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::stream </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec&lt; N, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a 128-bit or 256-bit integer, 32-bit or 64-bit floating point vector to memory without polluting the caches, if possible. </p>
<dl class="section user"><dt>128-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">(p) = a[0..127]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 16 bytes.</p>
<dl class="section user"><dt>256-bit version:</dt><dd></dd></dl>
<div class="fragment"><div class="line">(p) = a[0..255]</div>
</div><!-- fragment --><p> <em>p</em> must be aligned to 32 bytes. </p>
<ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In AVX (integer vectors) this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a661b7fbbfce252cc3d7d12c18a11b45c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00056.html">expr_sub</a>&lt;<a class="el" href="a00020.html">float32</a>&lt;N,E1&gt;, <a class="el" href="a00020.html">float32</a>&lt;N,E2&gt; &gt; &gt; simdpp::sub </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substracts the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 - b0</div>
<div class="line">...</div>
<div class="line">rN = aN - bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aef11196954334c758c3eb1ca30217ba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00056.html">expr_sub</a>&lt;<a class="el" href="a00135.html">uint8</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00135.html">uint8</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::sub </td>
          <td>(</td>
          <td class="paramtype">const any_int8&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int8&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts 8-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 - b0</div>
<div class="line">...</div>
<div class="line">rN = aN - bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad0994a9fa406d277e8cb46701173ebcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00056.html">expr_sub</a>&lt;<a class="el" href="a00021.html">float64</a>&lt;N,E1&gt;, <a class="el" href="a00021.html">float64</a>&lt;N,E2&gt; &gt; &gt; simdpp::sub </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the values of two vectors. </p>
<div class="fragment"><div class="line">r0 = a0 - b0</div>
<div class="line">...</div>
<div class="line">rN = aN - bN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-SSE4.1 this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1e51b1fe2b6f952f6c3aafd7da49187e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00056.html">expr_sub</a>&lt;<a class="el" href="a00123.html">uint16</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00123.html">uint16</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::sub </td>
          <td>(</td>
          <td class="paramtype">const any_int16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts 16-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 - b0</div>
<div class="line">...</div>
<div class="line">rN = aN - bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa18c68c697f1e216cfbf240de0811402"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00056.html">expr_sub</a>&lt;<a class="el" href="a00127.html">uint32</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00127.html">uint32</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::sub </td>
          <td>(</td>
          <td class="paramtype">const any_int32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts 32-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 - b0</div>
<div class="line">...</div>
<div class="line">rN = aN - bN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6ad8cdb5972da2368a4780317b5faaa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, <a class="el" href="a00056.html">expr_sub</a>&lt;<a class="el" href="a00131.html">uint64</a>&lt;N, typename V1::expr_type&gt;, <a class="el" href="a00131.html">uint64</a>&lt;N, typename V2::expr_type&gt; &gt; &gt;::type simdpp::sub </td>
          <td>(</td>
          <td class="paramtype">const any_int64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_int64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts 64-bit integer values. </p>
<div class="fragment"><div class="line">r0 = a0 - b0</div>
<div class="line">...</div>
<div class="line">rN = aN - bN</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 5-6 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 10-11 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac798e60e201fd395b55b42c46abe1e74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">int8</a>&lt;N, <a class="el" href="a00057.html">expr_sub_sat</a>&lt;<a class="el" href="a00025.html">int8</a>&lt;N,E1&gt;, <a class="el" href="a00025.html">int8</a>&lt;N,E2&gt; &gt; &gt; simdpp::sub_sat </td>
          <td>(</td>
          <td class="paramtype">int8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts and saturaters signed 8-bit integer values. </p>
<div class="fragment"><div class="line">r0 = saturated(a0 - b0)</div>
<div class="line">...</div>
<div class="line">rN = saturated(aN - bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a80d52ec632124731fdc1ac573aa59495"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">int16</a>&lt;N, <a class="el" href="a00057.html">expr_sub_sat</a>&lt;<a class="el" href="a00022.html">int16</a>&lt;N,E1&gt;, <a class="el" href="a00022.html">int16</a>&lt;N,E2&gt; &gt; &gt; simdpp::sub_sat </td>
          <td>(</td>
          <td class="paramtype">int16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts and saturaters signed 16-bit integer values. </p>
<div class="fragment"><div class="line">r0 = saturated(a0 - b0)</div>
<div class="line">...</div>
<div class="line">rN = saturated(aN - bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1f0447c92c7905445af2b86c728bcb58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00057.html">expr_sub_sat</a>&lt;<a class="el" href="a00135.html">uint8</a>&lt;N,E1&gt;, <a class="el" href="a00135.html">uint8</a>&lt;N,E2&gt; &gt; &gt; simdpp::sub_sat </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts and saturaters unsigned 8-bit integer values. </p>
<div class="fragment"><div class="line">r0 = saturated(a0 - b0)</div>
<div class="line">...</div>
<div class="line">rN = saturated(aN - bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6200c5737cdf5e7636a56e6f0ae3711c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00057.html">expr_sub_sat</a>&lt;<a class="el" href="a00123.html">uint16</a>&lt;N,E1&gt;, <a class="el" href="a00123.html">uint16</a>&lt;N,E2&gt; &gt; &gt; simdpp::sub_sat </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts and saturaters unsigned 16-bit integer values. </p>
<div class="fragment"><div class="line">r0 = saturated(a0 - b0)</div>
<div class="line">...</div>
<div class="line">rN = saturated(aN - bN)</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abedd53be61669845b7dc8b40b800edce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> simdpp::to_float32 </td>
          <td>(</td>
          <td class="paramtype">int32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 32-bit integer values to 32-bit float values. </p>
<p>SSE specific:</p>
<p>If only inexact conversion can be performed, the current rounding mode is used.</p>
<p>NEON, ALTIVEC specific:</p>
<p>If only inexact conversion can be performed, round to nearest mode is used.</p>
<div class="fragment"><div class="line">r0 = (float) a0</div>
<div class="line">...</div>
<div class="line">rN = (<span class="keywordtype">float</span>) aN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab664dde884f3d1b3024ab93d7210d781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N&gt; simdpp::to_float32 </td>
          <td>(</td>
          <td class="paramtype">int32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts 32-bit integer values to 32-bit float values. </p>
<p>SSE specific:</p>
<p>If only inexact conversion can be performed, the current rounding mode is used.</p>
<p>NEON, ALTIVEC specific:</p>
<p>If only inexact conversion can be performed, round to nearest mode is used.</p>
<div class="fragment"><div class="line">r0 = (float) a0</div>
<div class="line">...</div>
<div class="line">rN = (<span class="keywordtype">float</span>) aN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a32d8eb3c717b5f5be926d92d77ee11e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#ab2892535dd751dc65998ffb71e1aaeb8">float32x4</a> simdpp::to_float32 </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 64-bit float values to 32-bit float values. </p>
<p>SSE specific:</p>
<p>If only inexact conversion can be performed, the value is rounded according to the current rounding mode.</p>
<p>NEON specific:</p>
<p>If only inexact conversion can be performed, the value is truncated.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><div class="fragment"><div class="line">r0 = (float) a0</div>
<div class="line">r1 = (<span class="keywordtype">float</span>) a1</div>
<div class="line">r2 = 0.0f</div>
<div class="line">r3 = 0.0f</div>
</div><!-- fragment --></dd></dl>
<ul>
<li>Not vectorized in NEON and .</li>
</ul>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">r0 = (float) a0</div>
<div class="line">...</div>
<div class="line">r3 = (<span class="keywordtype">float</span>) a3</div>
<div class="line">r4 = 0.0f</div>
<div class="line">...</div>
<div class="line">r7 = 0.0f</div>
</div><!-- fragment --></dd></dl>
<ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>

</div>
</div>
<a class="anchor" id="a4de0a98825cd64942cda55345e20f89c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> simdpp::to_float64 </td>
          <td>(</td>
          <td class="paramtype">int32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the 32-bit integer values to 64-bit float values. </p>
<p>SSE specific:</p>
<p>If only inexact conversion can be performed, the value is rounded according to the current rounding mode.</p>
<p>NEON specific:</p>
<p>If only inexact conversion can be performed, the value is rounded to the nearest representable value.</p>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">r0 = (double) a0</div>
<div class="line">...</div>
<div class="line">r3 = (<span class="keywordtype">double</span>) a3</div>
</div><!-- fragment --></dd></dl>
<ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>

</div>
</div>
<a class="anchor" id="a3a31451c628d1165fec02f1db37b555c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a5c6da1e3ea4a68551086bddb9c0f54f7">float64x4</a> simdpp::to_float64 </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the 32-bit float values to 64-bit float values. </p>
<p>SSE specific:</p>
<p>If only inexact conversion can be performed, the value is rounded according to the current rounding mode.</p>
<p>NEON specific:</p>
<p>If only inexact conversion can be performed, the value is rounded to the nearest representable value.</p>
<dl class="section user"><dt>256-bit version:</dt><dd><div class="fragment"><div class="line">r0 = (double) a0</div>
<div class="line">...</div>
<div class="line">r3 = (<span class="keywordtype">double</span>) a3</div>
</div><!-- fragment --></dd></dl>
<ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
<li>Not vectorized in NEON and . </li>
</ul>

</div>
</div>
<a class="anchor" id="a376f8c92d44d07b0c03d834a837a135f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> simdpp::to_int16 </td>
          <td>(</td>
          <td class="paramtype">int8x16&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign extends the 16 values of a signed int8x16 vector to 16-bits. </p>
<div class="fragment"><div class="line">r0 = (int16_t) a0</div>
<div class="line">...</div>
<div class="line">r15 = (int16_t) a15</div>
</div><!-- fragment --><ul>
<li>In SSE4.1-AVX this intrinsic results in at least 3 instructions. </li>
<li>In SSE2-SSSE3 this intrinsic results in at least 4 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9effcb099bd1d651e6a8e9847e53616c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a6f51af32fa2f6caf3538118beb1beeb1">uint16x16</a> simdpp::to_int16 </td>
          <td>(</td>
          <td class="paramtype">uint8x16&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the 16 values of a unsigned int8x16 vector to 16-bits. </p>
<div class="fragment"><div class="line">r0 = (uint16_t) a0</div>
<div class="line">...</div>
<div class="line">r15 = (uint16_t) a15</div>
</div><!-- fragment --> <ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7349a89131862d8d7669d04c14b31873"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#ae3c0263ee6d69f8fe2891c69359440ea">int32x8</a> simdpp::to_int32 </td>
          <td>(</td>
          <td class="paramtype">int16x8&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign extends the first 8 values of a signed int16x16 vector to 32-bits. </p>
<div class="fragment"><div class="line">r0 = (int32_t) a0</div>
<div class="line">...</div>
<div class="line">r7 = (int32_t) a7</div>
</div><!-- fragment --> <ul>
<li>In SSE4.1-AVX this intrinsic results in at least 3 instructions. </li>
<li>In SSE2-SSSE3 this intrinsic results in at least 4 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a67d6fc7f844f1091901d5e5e757f68aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> simdpp::to_int32 </td>
          <td>(</td>
          <td class="paramtype">float32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the values of a float32x4 vector into signed int32_t representation using truncation if only an inexact conversion can be performed. </p>
<p>The behavior is undefined if the value can not be represented in the result type.</p>
<p>SSE specific: If the value can not be represented by int32_t, <code>0x80000000</code> is returned TODO: NaN handling</p>
<p>NEON, ALTIVEC specific: If the value can not be represented by int32_t, either <code>0x80000000</code> or <code>0x7fffffff</code> is returned depending on the sign of the operand (saturation occurs). Conversion of NaNs results in <em>0</em>.</p>
<div class="fragment"><div class="line">r0 = (int32_t) a0</div>
<div class="line">...</div>
<div class="line">rN = (int32_t) aN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9077a37c4d6c107a48c9de643a94e122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#ad58023c756757d023687e5daa41f3be4">int32x4</a> simdpp::to_int32 </td>
          <td>(</td>
          <td class="paramtype">float64x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the values of a doublex2 vector into int32_t representation using truncation. </p>
<p>The behavior is undefined if the value can not be represented in the result type.</p>
<p>SSE specific: If the value can not be represented by int32_t, <code>0x80000000</code> is returned </p>
<dl class="todo"><dt><b><a class="el" href="a00422.html#_todo000006">Todo:</a></b></dt><dd>NaN handling</dd></dl>
<p>NEON VFP specific: If the value can not be represented by int32_t, either <code>0x80000000</code> or <code>0x7fffffff</code> is returned depending on the sign of the operand. Conversion of NaNs results in <em>0</em>.</p>
<dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
<div class="fragment"><div class="line">r0 = (int32_t) a0</div>
<div class="line">r1 = (int32_t) a1</div>
<div class="line">r2 = (int32_t) a2</div>
<div class="line">r3 = (int32_t) a3</div>
</div><!-- fragment --></dd></dl>
<ul>
<li>In SSE2-SSE4.1 this intrinsic results in at least 3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac3a569752132430cba7b86bbb2392d23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N&gt; simdpp::to_int32x8 </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the values of a float32x4 vector into signed int32_t representation using truncation if only an inexact conversion can be performed. </p>
<p>The behavior is undefined if the value can not be represented in the result type.</p>
<p>SSE specific: If the value can not be represented by int32_t, <code>0x80000000</code> is returned TODO: NaN handling</p>
<p>NEON, ALTIVEC specific: If the value can not be represented by int32_t, either <code>0x80000000</code> or <code>0x7fffffff</code> is returned depending on the sign of the operand (saturation occurs). Conversion of NaNs results in <em>0</em>.</p>
<div class="fragment"><div class="line">r0 = (int32_t) a0</div>
<div class="line">...</div>
<div class="line">rN = (int32_t) aN</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ace2349f5a9358fe2c69abfb5be14cd85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a> simdpp::to_int64 </td>
          <td>(</td>
          <td class="paramtype">int32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the values of a signed int32x4 vector to 64-bits. </p>
<div class="fragment"><div class="line">r0 = (int64_t) a0</div>
<div class="line">...</div>
<div class="line">r3 = (int64_t) a3</div>
</div><!-- fragment --><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 5 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 3-4 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a979c58a8b0274077eb9281b89e8fb671"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00156.html#a6695b8dbe92c54e1fc4844174b4623ae">uint64x4</a> simdpp::to_int64 </td>
          <td>(</td>
          <td class="paramtype">uint32x4&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the values of an unsigned int32x4 vector to 64-bits. </p>
<div class="fragment"><div class="line">r0 = (uint64_t) a0</div>
<div class="line">...</div>
<div class="line">r3 = (uint64_t) a3</div>
</div><!-- fragment --><ul>
<li>In SSE2-AVX this intrinsic results in at least 3 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aff9c828143157bf361752e069be179fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::transpose8 </td>
          <td>(</td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x8 &amp;&#160;</td>
          <td class="paramname"><em>a7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes a 8x8 16-bit matrix within eight int16x8 vectors. </p>
<div class="fragment"><div class="line">r0 = [ a0_0; a1_0; a2_0; a3_0 ...; a7_0 ]</div>
<div class="line">r1 = [ a0_1; a1_1; a2_1; a3_1 ...; a7_1 ]</div>
<div class="line">...</div>
<div class="line">r7 = [ a0_7; a1_7; a2_7; a3_7 ...; a7_7 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 24 instructions. </li>
<li>In NEON this intrinsic results in at least 12 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 48 instructions. </li>
<li>In AVX2 this intrinsic results in at least 24 instructions. </li>
<li>In NEON this intrinsic results in at least 24 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="ac292e7c75739b96e30a3c956130126be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::transpose8 </td>
          <td>(</td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x8 &amp;&#160;</td>
          <td class="paramname"><em>a7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8fb9870d5f0e174f81895e188e22c57b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::transpose8 </td>
          <td>(</td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16x16 &amp;&#160;</td>
          <td class="paramname"><em>a7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a64f7d3163b10dab73fa2212d1961be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdpp::transpose8 </td>
          <td>(</td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16x16 &amp;&#160;</td>
          <td class="paramname"><em>a7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e3a347efa588f683aaba41da8b8973e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::trunc </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E &gt;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds the values of a vector towards zero. </p>
<div class="fragment"><div class="line">r0 = <a class="code" href="a00156.html#a9e3a347efa588f683aaba41da8b8973e" title="Rounds the values of a vector towards zero. ">trunc</a>(a0)</div>
<div class="line">...</div>
<div class="line">rN = <a class="code" href="a00156.html#a9e3a347efa588f683aaba41da8b8973e" title="Rounds the values of a vector towards zero. ">trunc</a>(aN)</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 7-9 instructions. </li>
<li>In NEON this intrinsic results in at least 5-6 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2, SSE3 and SSSE3 this intrinsic results in at least 14-16 instructions. </li>
<li>In NEON this intrinsic results in at least 10-11 instructions. </li>
<li>In SSE4.1 and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa0c9c9cc95e346c886bb3533e1007d4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00135.html">uint8</a>&lt;N&gt; &gt; simdpp::unzip16_hi </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two int8x16 vectors. </p>
<div class="fragment"><div class="line">    | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  |</div>
<div class="line">r = [ a1  a3  a5  a7  a9  a11 a13 a15 b1  b3  b5  b7  b9  b11 b13 b15 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8a323beafc7ae25d22635e7d61efc834"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">uint8</a>&lt;N, <a class="el" href="a00135.html">uint8</a>&lt;N&gt; &gt; simdpp::unzip16_lo </td>
          <td>(</td>
          <td class="paramtype">uint8&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two int8x16 vectors. </p>
<div class="fragment"><div class="line">    | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  |</div>
<div class="line">r = [ a0  a2  a4  a6  a8  a10 a12 a14 b0  b2  b4  b6  b8  b10 b12 b14 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX this intrinsic results in at least 8-9 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac8137f2298b755e5331e18f9783d6a75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N, <a class="el" href="a00131.html">uint64</a>&lt;N&gt; &gt; simdpp::unzip2_hi </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two int64x2 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a1 b1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a26f7b085cdcc2dfc968249d39c28c166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00021.html">float64</a>&lt;N&gt; &gt; simdpp::unzip2_hi </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two float64x2 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a1 b1 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>Not vectorized in NEON and . </li>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aeffbd2ad2a07ce3f5f38e99a81ea3ccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">uint64</a>&lt;N, <a class="el" href="a00131.html">uint64</a>&lt;N&gt; &gt; simdpp::unzip2_lo </td>
          <td>(</td>
          <td class="paramtype">uint64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two int64x2 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a0 b0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a485e9564f15bb893facf54fd9e15dfb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">float64</a>&lt;N, <a class="el" href="a00021.html">float64</a>&lt;N&gt; &gt; simdpp::unzip2_lo </td>
          <td>(</td>
          <td class="paramtype">float64&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two float64x2 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  |</div>
<div class="line">r = [ a0 b0 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>Not vectorized in NEON and .</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX this intrinsic results in at least 2 instructions. </li>
<li>Not vectorized in NEON and .</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="a465862c8c577cb1be6180b12c5b863b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00127.html">uint32</a>&lt;N&gt; &gt; simdpp::unzip4_hi </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two int32x4 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a1 a3 b1 b3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ace8f01aabf4c4999ca147a62c09dff9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::unzip4_hi </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two float32x4 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a1 a3 b1 b3 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9eb5639f374f21f0d0ebd2f7b00b45d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00127.html">uint32</a>&lt;N, <a class="el" href="a00127.html">uint32</a>&lt;N&gt; &gt; simdpp::unzip4_lo </td>
          <td>(</td>
          <td class="paramtype">uint32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two int32x4 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a0 a2 b0 b2 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd><ul>
<li>In SSE2-AVX and NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions.</li>
</ul>
The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately. </dd></dl>

</div>
</div>
<a class="anchor" id="aed7100ed95653d03e8d591f61af55d81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">float32</a>&lt;N, <a class="el" href="a00020.html">float32</a>&lt;N&gt; &gt; simdpp::unzip4_lo </td>
          <td>(</td>
          <td class="paramtype">float32&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two float32x4 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  |</div>
<div class="line">r = [ a0 a2 b0 b2 ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSE4.1, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8f9e3674f2cf1c7cba35e0ade19992ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00123.html">uint16</a>&lt;N&gt; &gt; simdpp::unzip8_hi </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the even(higher) elements of two int16x8 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  6  7  |</div>
<div class="line">r = [ a1 a3 a5 a7 b1 b3 b5 b7 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-AVX2 this intrinsic results in at least 3 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX this intrinsic results in at least 6 instructions. </li>
<li>In NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
<li>In AVX2 this intrinsic results in at least 3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a997d97556f3330df92cf84a07202165d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class E1 , class E2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00123.html">uint16</a>&lt;N, <a class="el" href="a00123.html">uint16</a>&lt;N&gt; &gt; simdpp::unzip8_lo </td>
          <td>(</td>
          <td class="paramtype">uint16&lt; N, E1 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&lt; N, E2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-interleaves the odd(lower) elements of two int16x8 vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  6  7  |</div>
<div class="line">r = [ a0 a2 a4 a6 b0 b2 b4 b6 ]</div>
</div><!-- fragment --><dl class="section user"><dt>128-bit version:</dt><dd><ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 5 instructions. </li>
<li>In SSE4.1-AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 1-2 instructions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-SSSE3 this intrinsic results in at least 5 instructions. </li>
<li>In SSE4.1-AVX this intrinsic results in at least 8-9 instructions. </li>
<li>In AVX2 this intrinsic results in at least 4-5 instructions. </li>
<li>In NEON this intrinsic results in at least 2 instructions. </li>
<li>In ALTIVEC this intrinsic results in at least 2-3 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa17419954add2a414828dd078ea90e7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip16_hi </td>
          <td>(</td>
          <td class="paramtype">const any_vec8&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec8&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSV2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="abaf75ea95edfd3044789e8dc34b63691"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip16_lo </td>
          <td>(</td>
          <td class="paramtype">const any_vec8&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec8&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad58837fe38f00b5d9321b81bd87fdaf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip2_hi </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSV2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4c006705ed8ee5ef56cf17702dda9a48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip2_lo </td>
          <td>(</td>
          <td class="paramtype">const any_vec64&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec64&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5df7922ab8f779fbf68e5c9b02a0722a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip4_hi </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSV2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a12525d4e72ed06a487fab061d3c4394a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip4_lo </td>
          <td>(</td>
          <td class="paramtype">const any_vec32&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec32&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="adf3a63afcd58d77294ccc8252f62e718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip8_hi </td>
          <td>(</td>
          <td class="paramtype">const any_vec16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the higher halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0      1      2        3        ... N-2    N-1    |</div>
<div class="line">r = [ a(N/2) b(N/2) a(N/2+1) b(N/2+1) ... a(N-1) b(N-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSV2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7877fb314db391b60e8cc50c928a09e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::get_expr2_nomask&lt;V1, V2, void&gt;::empty simdpp::zip8_lo </td>
          <td>(</td>
          <td class="paramtype">const any_vec16&lt; N, V1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const any_vec16&lt; N, V2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the lower halves of two vectors. </p>
<div class="fragment"><div class="line">    | 0  1  2  3  4  5  ... N-2      N-1      |</div>
<div class="line">r = [ a0 b0 a1 b1 a2 b2 ... a(N/2-1) b(N/2-1) ]</div>
</div><!-- fragment --><dl class="section user"><dt>256-bit version:</dt><dd>The lower and higher 128-bit halves are processed as if 128-bit instruction was applied to each of them separately.</dd></dl>
<ul>
<li>In SSE2-AVX, NEON and ALTIVEC this intrinsic results in at least 2 instructions. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 8 2014 03:14:35 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</div>
</body>
</html>
