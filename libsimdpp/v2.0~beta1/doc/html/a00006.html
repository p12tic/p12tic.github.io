<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>libsimdpp: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="main">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>&#160;&#160;The overview assumes the reader already knows basic concepts of SIMD programming.</p>
<h3>Vector types</h3>
<p>libsimdpp supports vectors holding data of 10 different data formats. For each of these formats, a separate vector type is provided. These following data formats are supported:</p>
<ul>
<li>8-bit signed and unsigned integers (<code>int8</code>, <code>uint8</code>)</li>
<li>16-bit signed and unsigned integers (<code>int16</code>, <code>uint16</code>)</li>
<li>32-bit signed and unsigned integers (<code>int32</code>, <code>uint32</code>)</li>
<li>64-bit signed and unsigned integers (<code>int64</code>, <code>uint64</code>)</li>
<li>32-bit floating-point numbers (<code>float32</code>)</li>
<li>64-bit floating-point numbers (<code>float64</code>)</li>
</ul>
<p>In addition to these, 6 mask formats are provided.</p>
<p>A mask is a vector that contains elements with either all set bits or all unset bits. It is possible to represent the data on such vector using just single bit per element. Some architectures such as AVX-512 use separate vector registers for masks, which allows much improved performance. Having separate type for masks thus allows to fully use the potential on such architectures.</p>
<p>The following mask types are provided:</p>
<ul>
<li>mask for 8-bit integer elements (<code>mask_int8</code>)</li>
<li>mask for 16-bit integer elements (<code>mask_int16</code>)</li>
<li>mask for 32-bit integer elements (<code>mask_int32</code>)</li>
<li>mask for 64-bit integer elements (<code>mask_int64</code>)</li>
<li>mask for 32-bit floating-point elements (<code>mask_float32</code>)</li>
<li>mask for 64-bit floating-point elements (<code>mask_float64</code>)</li>
</ul>
<p>Each vector type is implemented as a template that accepts 2 arguments (here <em>vector_type</em> is any of the vector types mentioned above):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> NumElements, <span class="keyword">class</span> Expression = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><span class="keyword">class </span>_vector_type_ { ... };</div>
</div><!-- fragment --><p>The first parameter defines the number of elements in a vector. <code>NumElements</code> must be any power of two such that the size of the resulting vector is not less than 16 bytes. If the target instruction set does not support vector of such size, then the library automatically uses the widest vector type for the particular type. For example, on AVX, <code>int8&lt;128&gt;</code> uses <code>__m128i</code>, whereas <code>float32&lt;32&gt;</code> uses <code>__m256</code>.</p>
<p>Using unnecessarily long vectors increases register pressure, so the developers are expected to use the lowest vector length that is needed to implement their algorithms efficiently.</p>
<p>The second parameter is implementation detail, i.e. non-<code>void</code> types are reserved. Vectors with <code>Expression</code> parameter being <code>void</code> are <em>value</em> vectors, that is, they directly correspond to one or more instances of native vector types, as would be expected. Vectors with <code>Expression</code> parameter being non-<code>void</code> are <em>expression</em> vectors, that is, they hold an expression with all its parameters.</p>
<p>This technique is called "expression templates" and allows to pick more efficient algorithm for entire expression. For example, <code>add(a, mul(b, c))</code> will be optimized into a single multiple-add operation on architectures where it is available. Even though this optimization can be easily done at the compiler level, usually the compilers are very reluctant to optimize low level intrinsic functions that this library uses. This makes the expression template usage necessary rather than optional.</p>
<p>For the user, expression vector types should be viewed as some wrapper type that can be implicitly converted to the corresponding value vector type. To obtain a value vector without inconvenience of typing the type name, use the <code>.eval()</code> member function which is provided for both value and expression vectors.</p>
<h3>Casts</h3>
<p>The vector types can be casted from one to another rather easily. The following casts are supported:</p>
<ul>
<li>Any non-mask value vector can be explicitly constructed from any other non-mask value vector of the same size (mask vectors may be created only as results of vector comparison functions).</li>
<li>A non-mask value vector can be assigned a value of any vector type of the same size.</li>
<li>An <em>expression</em> vector can be implicitly converted to a corresponding <em>value</em> vector.</li>
</ul>
<p>Mask types may only be assigned to or constructed from the same mask type. The only way to create a mask is by using comparison functions such as <code>cmp_eq</code> or <code>cmp_lt</code>.</p>
<p>Note that expression vectors are not meant to be created or assigned to by the user. Assignment can happen quite easily if C++11 <code>auto</code> is used, e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code" href="a00156.html#a41841a925565233350d53362752a34c6" title="Adds the values of two vectors. ">add</a>(a, b);</div>
<div class="line">v = <a class="code" href="a00156.html#a41841a925565233350d53362752a34c6" title="Adds the values of two vectors. ">add</a>(v, c);</div>
</div><!-- fragment --><p>The second line, even if compiles, is not supported and not supposed to be used by the user.</p>
<h3>Vector categorization hierarchy</h3>
<p>The vector types inherit from several common types using Curiously recurrint template pattern (CRTP). The resulting inheritance hierarchy is used to categorize vector types so that it's possible to write function templates that operate on some category of vector types.</p>
<p>For example, bitwise AND is implemented as a single function template that accepts any two vectors of the same size. Implementing this functionality without some kind of categorization would require 256 overloads, which is not feasible.</p>
<p>The hierarchy is as follows. Note that the users of the library do not ever need to use any of the following types directly. Knowing the categorization hierarchy is only useful when reading the documentation.</p>
<ul>
<li>any_vec&lt;B,V&gt; - any vector with size of B bytes<ul>
<li>any_vec8&lt;N,V&gt; - any vector with N 8-bit elements<ul>
<li>any_int8&lt;N,V&gt; - any integer vector with N 8-bit elements</li>
</ul>
</li>
<li>any_vec16&lt;N,V&gt; - any vector with N 16-bit elements<ul>
<li>any_int16&lt;N,V&gt; - any integer vector with N 16-bit elements</li>
</ul>
</li>
<li>any_vec32&lt;N,V&gt; - any vector with N 32-bit elements<ul>
<li>any_int32&lt;N,V&gt; - any integer vector with N 32-bit elements</li>
<li>any_float32&lt;N,V&gt; - any floating-point vector with N 32-bit elements</li>
</ul>
</li>
<li>any_vec64&lt;N,V&gt; - any vector with N 64-bit elements<ul>
<li>any_int64&lt;N,V&gt; - any integer vector with N 64-bit elements</li>
<li>any_float64&lt;N,V&gt; - any floating-point vector with N 64-bit elements</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The <code>any_vec</code> template has <code>vec()</code> member function that converts <code>*this</code> to the actual vector type <code>V</code>. Users of the library should never need to call this. It is only useful to implementers of generic function templates.</p>
<h3>Vector promotion</h3>
<p>As mentioned in the above section, some generic operations are implemented as function templates that accept a variety of vector types. The type of the returned vector is determined by rules that are very similar to the C++ type promotion rules and thus are called "vector promotion" rules. The same set of rules is used throughout the library, with a single exception related to masks.</p>
<p>The rules are as follows (it may be clearer just to look at the table below):</p>
<ul>
<li>The <code>mask_int</code>, <code>mask_float</code>, <code>int</code>, <code>uint</code> and <code>float</code> vector types are assigned ranks in an increasing order irrespective of number of elements. The result type of a generic operation always has the highest rank among the argument types. I.e. <code>int @ uint -&gt; uint</code>, <code>mask_int @ float -&gt; float</code>.</li>
<li>If the arguments of a generic operation have different element widths, then the result type has elements with largest element width (or smallest number of elements). I.e. <code>float32 @ int64 -&gt; float64</code>.</li>
<li>If the arguments are two masks with different element widths, then the result type is an unsigned integer vector. The element width is governed by the second rule.</li>
</ul>
<p>The following list illustrates the conversion rules. The first two items are the argument types and the third item is the result type.</p>
<div class="fragment"><div class="line">[ Same element sizes ]</div>
<div class="line"></div>
<div class="line">       intXX |        intXX -&gt;        intXX</div>
<div class="line">       intXX |       uintXX -&gt;       uintXX</div>
<div class="line">      uintXX |       uintXX -&gt;       uintXX</div>
<div class="line">     floatXX |        intXX -&gt;      floatXX</div>
<div class="line">     floatXX |       uintXX -&gt;      floatXX</div>
<div class="line">     floatXX |      floatXX -&gt;      floatXX</div>
<div class="line">  mask_intXX |        intXX -&gt;       uintXX</div>
<div class="line">  mask_intXX |       uintXX -&gt;       uintXX</div>
<div class="line">  mask_intXX |   mask_intXX -&gt;   mask_intXX</div>
<div class="line">  mask_intXX |      floatXX -&gt;      floatXX</div>
<div class="line">  mask_intXX | mask_floatXX -&gt; mask_floatXX</div>
<div class="line">mask_floatXX |      floatXX -&gt;      floatXX</div>
<div class="line">mask_floatXX | mask_floatXX -&gt; mask_floatXX</div>
<div class="line"></div>
<div class="line">[ Different element sizes ]</div>
<div class="line"></div>
<div class="line">       intXX |        intYY -&gt;        <span class="keywordtype">int</span>{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">       intXX |       uintYY -&gt;       uint{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">      uintXX |       uintYY -&gt;       uint{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">     floatXX |        intYY -&gt;      <span class="keywordtype">float</span>{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">     floatXX |       uintYY -&gt;      <span class="keywordtype">float</span>{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">     floatXX |      floatYY -&gt;      <span class="keywordtype">float</span>{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">  mask_intXX |        intYY -&gt;       uint{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">  mask_intXX |       uintYY -&gt;       uint{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">  mask_intXX |   mask_intYY -&gt;       uint{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">  mask_intXX |      floatYY -&gt;      <span class="keywordtype">float</span>{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">  mask_intXX | mask_floatYY -&gt;       uint{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">mask_floatXX |      floatYY -&gt;      <span class="keywordtype">float</span>{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
<div class="line">mask_floatXX | mask_floatYY -&gt;       uint{ <a class="code" href="a00156.html#a7aa59db112d340032eba1ebf5ded06e2" title="Computes maxima of the values of two vectors. ">max</a>(XX, YY) }</div>
</div><!-- fragment --><p>If a particular operation does not support masks, the masks are expanded internally. If both arguments are masks, then the result type is unsigned integer vector if both masks are <code>mask_int</code> and floating-point vector otherwise. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 8 2014 03:14:34 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</div>
</body>
</html>
