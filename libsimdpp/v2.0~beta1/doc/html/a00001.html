<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>libsimdpp: design-internal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="main">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsimdpp
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">design-internal </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>&#160;&#160;&#160;&#160;This is incomplete internal documentation</p>
<h2>Design of the library</h2>
<ul>
<li>If you find some part of the documentation of the library design unclear or missing, please open a bug.</li>
</ul>
<h2>Architecture of the library </h2>
<p>In most basic terms, libsimdpp consists of two parts:</p>
<ul>
<li>a number of vector types that wrap vector types available in the target instruction set</li>
<li>a number of functions that operate on these vectors</li>
</ul>
<h2>Vector types </h2>
<p>The vector types are templates which accept two parameters: the number of elements and expression type.</p>
<ul>
<li>Width</li>
</ul>
<p>The first parameter allows the vectors to have arbitrarily large number of elements. Native vectors are implemented as template specializations, so, for example, <code>float32&lt;4&gt;</code> holds a <code>__m128</code> object on SSE#. On AVX, <code>float32&lt;8&gt;</code> is also defined, which holds a <code>__m256</code> object.</p>
<p>Long vectors consist of a number of vectors of largest natively supported width. For example, <code>float32&lt;32&gt;</code> internally holds 8 <code>float32&lt;4&gt;</code> objects on SSE# and 4 <code>float32&lt;8&gt;</code> objects on AVX. Any operation on such vector will simply loop through the internal vector objects.</p>
<p>Naturally, using unnecessarily long vectors increases register pressure, so the developers are expected to use the lowest vector length that is needed to implement their algorithms efficiently.</p>
<ul>
<li>Expressions</li>
</ul>
<p>The second, expression parameter is there to allow use of expression templates.</p>
<p>The reason for combining vector and expression types into the same template lies in the fact that implicit conversions are not allowed whet deducing template parameters. So, if expression type was different, then for each function template accepting two vectors, four variants would need to be written. Fortunately, combining vector and expression types does not have any complications except being a bit confusing: by using template specializations the vector and expression types have been made completely separate.</p>
<p>'void' expression type (default) corresponds to a value vector, i.e. a vector that is not an expression. Any other type corresponds to an expression. All useful expression types are defined in libsimdpp/expr.h .</p>
<p>Thus, for example:</p>
<ul>
<li><code>float&lt;4,void&gt;</code> or just <code>float&lt;4&gt;</code> is a SSE <code>__m128</code> (or NEON <code>float32x4_t</code>, etc.) vector</li>
<li><code>float&lt;4,expr_add&lt;float&lt;4&gt;, float&lt;4&gt;&gt;&gt;</code> is an add expression. The object stores two <code>float&lt;4&gt;</code> vectors. It's possible to store other expressions instead of the <code>float&lt;4&gt;</code> vectors, thus building a tree-like structure. The resulting type are later matched by overloads of <code>simdpp::detail::expr_eval</code> function, which could optimize the expression. For example:</li>
<li><code>float&lt;4,expr_add&lt;float&lt;4&gt;,float&lt;4,expr_mul&lt;float&lt;4&gt;, float&lt;4&gt;&gt;&gt;&gt;&gt;</code> denotes a multiply-add expression that can be executed by a single instruction on processors that have FMA instruction.</li>
</ul>
<p>Both vector and expression types have <code>eval()</code> member function that in the case of vector types returns <code>*this</code> and in the case of expression types, evaluates the expression using <code>simdpp::detail::expr_eval</code> and returns the resulting vector.</p>
<p>Expression types are <em>almost</em> invisible to the user. One practical difference is that expression types can't be implicitly converted to the native type, thus the user can't use the result of, say, <code>bit_and</code> directly as an argument to <code>_mm_add_ps</code>. Also, if the expression type is captused via <code>auto</code> in C++11, the resulting object is inferior as it can't be assigned a value to, etc. This needs to be properly documented, if it isn't already.</p>
<ul>
<li>Vector types</li>
</ul>
<p>There are 14 different vector types in libsimdpp: 4 signed integer vector types, 4 unsigned integer vector types, 2 floating-point vector types, 4 integer mask types and 2 floating-point mask types:</p>
<p><code>int8</code>, <code>uint8</code>, <code>mask_int8</code>, <code>int16</code>, <code>uint16</code>, <code>mask_int16</code>, <code>int32</code>, <code>uint32</code>, <code>mask_int32</code>, <code>int64</code>, <code>uint64</code>, <code>mask_int64</code>, <code>float32</code>, <code>mask_float32</code>, <code>float64</code>, <code>mask_float64</code></p>
<p>The reason for mask types is that on some SIMD instruction sets (e.g. AVX512) there are separate registers for vector masks, using which for masking operations is considerably more efficient.</p>
<p>Also, the library does not vectorize all code paths on e.g. NEON, so storing results of comparisons as <code>bool</code> values allows the compiler to properly devectorize the code. That is code such as the following: </p>
<pre class="fragment">float64&lt;2&gt; r = blend(a, b, cmp_lt(a, b))
</pre><p>is properly converted to something equivalent to the following: </p>
<pre class="fragment">for (unsigned i = 0; i &lt; 2; ++i) {
    r[i] = (a[i] &lt; b[i]) ? a[i] : b[i];
}
</pre><h2>Hierarchy </h2>
<p>Vector and expression types inherit from several common types using Curiously recurrint template pattern (CRTP). The resulting inheritance hierarchy is used to categorize vector types (see simdpp/types/any.h) so that it's possible to write function templates that operate on some category of vector types, such as, e.g. any vectors that have size of 16 bytes, or any vectors that have 4 32-bit elements, etc.</p>
<p>The hierarchy is as follows:</p>
<ul>
<li>any_vec&lt;B,V&gt; - any vector with size of B bytes<ul>
<li>any_vec8&lt;N,V&gt; - any vector with N 8-bit elements<ul>
<li>any_int8&lt;N,V&gt; - any integer vector with N 8-bit elements</li>
</ul>
</li>
<li>any_vec16&lt;N,V&gt; - any vector with N 16-bit elements<ul>
<li>any_int16&lt;N,V&gt; - any integer vector with N 16-bit elements</li>
</ul>
</li>
<li>any_vec32&lt;N,V&gt; - any vector with N 32-bit elements<ul>
<li>any_int32&lt;N,V&gt; - any integer vector with N 32-bit elements</li>
<li>any_float32&lt;N,V&gt; - any floating-point vector with N 32-bit elements</li>
</ul>
</li>
<li>any_vec64&lt;N,V&gt; - any vector with N 64-bit elements<ul>
<li>any_int64&lt;N,V&gt; - any integer vector with N 64-bit elements</li>
<li>any_float64&lt;N,V&gt; - any floating-point vector with N 64-bit elements</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The <code>any_vec</code> template has <code>vec()</code> member function that converts <code>*this</code> to the actual vector type <code>V</code>.</p>
<h2>Functions </h2>
<p>All functions that operate on vectors are implemented in roughly the following way: there's a simple interface in one of the files in simdpp/core directory, which wraps an internal implementation in simdpp/detail/insn and possibly in simdpp/detail/expr directories. Collectively, the public interface is called the front-end and the internal implementation is called the back-end.</p>
<p>The back-end of a function usually consists of many overloads. Each of them reside in simdpp::detail::insn namespace and have prefix <code>i_</code> to prevent name clashes whenever a front-end function needs to be used.</p>
<p>For each vector type there's a template that loops over arbitrarily long vectors and a separate overload for each native vector type. The latter are what</p>
<p>Proper implementation is selected via conditional inclusion depending on macro constants that are set in simdpp/setup_arch.h file. This header must be directly or indirectly included into each source file of the library.</p>
<h2>Namespace </h2>
<p>All functionality of the library is put into a namespace whose name depends on the currently enabled instruction sets. This allows to avoid violations of One Definition Rule when the same source file is compiled seeral times for different SIMD instruction sets and linked into the same target executable or library. The namespace is set up as a macro SIMDPP_ARCH_NAMESPACE in simdpp/setup_arch.h header file. This header file must be directly or indirectly included into all files of the libsimdpp library.</p>
<h2>Why there's so much duplication in type definitions? </h2>
<p>It's not possible to implement the specializations of core templates (int8, uint16, mask_int32) as templates themselves in C++98. It's only possible in C++11. Thus we're simply duplicating stuff until the library can drop the C++98 support (i.e. that is not planned). </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 8 2014 03:14:34 for libsimdpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</div>
</body>
</html>
